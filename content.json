{"pages":[{},{},{}],"posts":[{"title":"Welcome Zhou jun wei's Wiki Site","date":"2020-10-05T08:27:35.037Z","path":"2020/10/05/index/","text":"","tags":[]},{"title":"生活学习","date":"2020-10-04T08:22:36.000Z","path":"2020/10/04/生活学习/生活学习/","text":"","tags":[]},{"title":"艺术","date":"2020-10-04T08:22:36.000Z","path":"2020/10/04/艺术/艺术/","text":"","tags":[]},{"title":"c++","date":"2020-09-29T15:23:24.000Z","path":"2020/09/29/程序语言/C++/c++/","text":"","tags":[{"name":"c++","slug":"c","permalink":"https://zh-wiki.github.io/tags/c/"}]},{"title":"UML","date":"2020-09-29T15:23:24.000Z","path":"2020/09/29/程序语言/UML/UML/","text":"","tags":[{"name":"UML","slug":"UML","permalink":"https://zh-wiki.github.io/tags/UML/"}]},{"title":"高通 Camx 问题总结","date":"2019-12-31T16:01:00.000Z","path":"2020/01/01/技术研发/Camera Driver/高通 Camx/高通 Camx 问题总结/","text":"帧率问题人像模式在暗环境，帧率过低，预览卡顿 首先确认一下信息 测试环境有多暗 lux（是否有量变的过程） camera 镜头距离拍摄物多远 查看sensor 出帧是否正常 开启内核双摄帧同步的log 12adb shell &quot;echo 0x1000018 &gt; ./sys/module/cam_debug_util/parameters/debug_mdl&quot;adb logcat -b kernel &gt; kmd.log 正常环境log 1234Line 3662: 01-02 02:37:40.256 0 0 I CAM_DBG : CAM-ISP: __cam_isp_ctx_send_sof_timestamp: 666: request id:64 frame number:66 SOF time stamp:0x4ceb8d14a14Line 3679: 01-02 02:37:40.256 0 0 I CAM_DBG : CAM-ISP: __cam_isp_ctx_send_sof_timestamp: 666: request id:64 frame number:66 SOF time stamp:0x4ceb8d5cc41Line 4564: 01-02 02:37:40.289 0 0 I CAM_DBG : CAM-ISP: __cam_isp_ctx_send_sof_timestamp: 666: request id:65 frame number:67 SOF time stamp:0x4cebacd4843Line 4618: 01-02 02:37:40.290 0 0 I CAM_DBG : CAM-ISP: __cam_isp_ctx_send_sof_timestamp: 666: request id:65 frame number:67 SOF time stamp:0x4cebad1caa4 通过上述log，发现 request id 和 frame number 都是成双成对的。分别对应主摄和辅摄的出帧。 For Example ：request id:65 frame number:67 Line 4564: 01-02 02:37:40.289 Line 4618: 01-02 02:37:40.290 通过分析log ，可以看出主摄和辅摄只差1ms，同步OK. 暗环境下的log 12345Line 124973: 01-02 03:00:15.035 0 0 I CAM_DBG : CAM-ISP: __cam_isp_ctx_send_sof_timestamp: 666: request id:0 frame number:193 SOF time stamp:0x60a27f1067bLine 124990: 01-02 03:00:15.035 0 0 I CAM_DBG : CAM-ISP: __cam_isp_ctx_send_sof_timestamp: 666: request id:0 frame number:110 SOF time stamp:0x60a27f5890fLine 131018: 01-02 03:00:16.055 0 0 I CAM_DBG : CAM-ISP: __cam_isp_ctx_send_sof_timestamp: 666: request id:0 frame number:213 SOF time stamp:0x60a64afe776Line 131041: 01-02 03:00:16.055 0 0 I CAM_DBG : CAM-ISP: __cam_isp_ctx_send_sof_timestamp: 666: request id:74 frame number:121 SOF time stamp:0x60a64b469d7 很明显没有同步，分别算一下帧率 16.055 - 15.035 = 1.5s 主摄 (213-193)/1.5 = 13fps 辐射 (121-110)/1.5 = 7.3fps 解决方法 方案一 找Tuning的同事固定帧率，调试曝光表","tags":[]},{"title":"高通 Camx Bring up","date":"2019-12-31T16:00:30.000Z","path":"2020/01/01/技术研发/Camera Driver/高通 Camx/高通 Camx Bring up/","text":"Bring Up SensorHAL层的配置 移植驱动代码到相应的路径 vendor/qcom/proprietary/chi-cdk/oem/qcom/sensor/ 驱动文件名字根据项目而定 sensor xml 相关配置 lime_sunny_hi259_macro_sensor.xml 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374&lt;slaveInfo&gt; &lt;!--Name of the sensor --&gt; &lt;sensorName&gt;lime_sunny_hi259_macro&lt;/sensorName&gt; &lt;!--8-bit or 10-bit write slave address For External Sensors for which camx needs not probe the slave address shoule be as 0 --&gt; &lt;slaveAddress&gt;0x60&lt;/slaveAddress&gt; &lt;!--Register address / data size in bytes --&gt; &lt;regAddrType range=&quot;[1,4]&quot;&gt;2&lt;/regAddrType&gt; &lt;!--Register address / data size in bytes --&gt; &lt;regDataType range=&quot;[1,4]&quot;&gt;2&lt;/regDataType&gt; &lt;!--Register address for sensor Id --&gt; &lt;sensorIdRegAddr&gt;0x04&lt;/sensorIdRegAddr&gt; &lt;!--Sensor Id 0xE1--&gt; &lt;sensorId&gt;0x113&lt;/sensorId&gt; &lt;!--Mask for sensor id. Sensor Id may only be few bits --&gt; &lt;sensorIdMask&gt;4294967295&lt;/sensorIdMask&gt; &lt;!--I2C frequency mode of slave Supported modes are: STANDARD (100 KHz), FAST (400 KHz), FAST_PLUS (1 MHz), CUSTOM (Custom frequency in DTSI) --&gt; &lt;i2cFrequencyMode&gt;FAST&lt;/i2cFrequencyMode&gt; &lt;!--Sequence of power configuration type and configuration value required to control power to the device --&gt; &lt;powerUpSequence&gt; &lt;powerSetting&gt; &lt;configType&gt;RESET&lt;/configType&gt; &lt;configValue&gt;1&lt;/configValue&gt; &lt;delayMs&gt;1&lt;/delayMs&gt; &lt;/powerSetting&gt; &lt;powerSetting&gt; &lt;configType&gt;CUSTOM_GPIO1&lt;/configType&gt; &lt;configValue&gt;1&lt;/configValue&gt; &lt;delayMs&gt;0&lt;/delayMs&gt; &lt;/powerSetting&gt; &lt;powerSetting&gt; &lt;configType&gt;CUSTOM_GPIO2&lt;/configType&gt; &lt;configValue&gt;1&lt;/configValue&gt; &lt;delayMs&gt;2&lt;/delayMs&gt; &lt;/powerSetting&gt; &lt;powerSetting&gt; &lt;configType&gt;MCLK&lt;/configType&gt; &lt;configValue&gt;24000000&lt;/configValue&gt; &lt;delayMs&gt;8&lt;/delayMs&gt; &lt;/powerSetting&gt; &lt;powerSetting&gt; &lt;configType&gt;RESET&lt;/configType&gt; &lt;configValue&gt;0&lt;/configValue&gt; &lt;delayMs&gt;1&lt;/delayMs&gt; &lt;/powerSetting&gt; &lt;/powerUpSequence&gt; &lt;!--Sequence of power configuration type and configuration value required to control power to the device --&gt; &lt;powerDownSequence&gt; &lt;!--Power setting configuration Contains: configType, configValue and delay in milli seconds --&gt; &lt;powerSetting&gt; &lt;configType&gt;RESET&lt;/configType&gt; &lt;configValue&gt;1&lt;/configValue&gt; &lt;delayMs&gt;1&lt;/delayMs&gt; &lt;/powerSetting&gt; &lt;powerSetting&gt; &lt;configType&gt;MCLK&lt;/configType&gt; &lt;configValue&gt;0&lt;/configValue&gt; &lt;delayMs&gt;0&lt;/delayMs&gt; &lt;/powerSetting&gt; &lt;powerSetting&gt; &lt;configType&gt;CUSTOM_GPIO1&lt;/configType&gt; &lt;configValue&gt;0&lt;/configValue&gt; &lt;delayMs&gt;0&lt;/delayMs&gt; &lt;/powerSetting&gt; &lt;powerSetting&gt; &lt;configType&gt;CUSTOM_GPIO2&lt;/configType&gt; &lt;configValue&gt;0&lt;/configValue&gt; &lt;delayMs&gt;1&lt;/delayMs&gt; &lt;/powerSetting&gt; &lt;/powerDownSequence&gt; &lt;/slaveInfo&gt; sensor name 跟sensor 文件夹名字一致 slaveAddress IIC 从机地址 sensor id 寄存器地址 以及 sensor id 上下电时序 (为了保险首先将reset引脚设置为禁止状态) module xml 配置 lime_sunny_hi259_macro_module.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;&lt;!--========================================================================--&gt;&lt;!-- Copyright (c) 2018 Qualcomm Technologies, Inc. --&gt;&lt;!-- All Rights Reserved. --&gt;&lt;!-- Confidential and Proprietary - Qualcomm Technologies, Inc. --&gt;&lt;!--========================================================================--&gt;&lt;cameraModuleData xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:noNamespaceSchemaLocation=&quot;..\\..\\..\\api\\sensor\\camxmoduleconfig.xsd&quot;&gt; &lt;module_version major_revision=&quot;1&quot; minor_revision=&quot;0&quot; incr_revision=&quot;0&quot;/&gt; &lt;!--Module group can contain either 1 module or 2 modules Dual camera, stereo camera use cases contain 2 modules in the group --&gt; &lt;moduleGroup&gt; &lt;!--Module configuration --&gt; &lt;moduleConfiguration description=&quot;Module configuration&quot;&gt; &lt;!--CameraId is the id to which DTSI node is mapped. Typically CameraId is the slot Id for non combo mode. --&gt; &lt;cameraId&gt;3&lt;/cameraId&gt; &lt;!--Name of the module integrator --&gt; &lt;moduleName&gt;sunny&lt;/moduleName&gt; &lt;!--Name of the sensor in the image sensor module --&gt; &lt;sensorName&gt;lime_sunny_hi259_macro&lt;/sensorName&gt; &lt;!--Actuator name in the image sensor module This is an optional element. Skip this element if actuator is not present --&gt; &lt;actuatorName&gt;&lt;/actuatorName&gt; &lt;oisName&gt;&lt;/oisName&gt; &lt;!--EEPROM name in the image sensor module This is an optional element. Skip this element if EEPROM is not present --&gt; &lt;eepromName&gt;&lt;/eepromName&gt; &lt;!--Flash name is used to used to open binary. Binary name is of form flashName_flash.bin Ex:- pmic_flash.bin --&gt; &lt;flashName&gt;&lt;/flashName&gt; &lt;!--Chromatix name is used to used to open binary. Binary name is of the form sensor_model_chromatix.bin --&gt; &lt;chromatixName&gt;lime_sunny_hi259_macro&lt;/chromatixName&gt; &lt;!--Position of the sensor module. Valid values are: REAR, FRONT, REAR_AUX, FRONT_AUX, EXTERNAL --&gt; &lt;position&gt;REAR_AUX&lt;/position&gt; &lt;!--CSI Information --&gt; &lt;CSIInfo description=&quot;CSI Information&quot;&gt; &lt;laneAssign&gt;2&lt;/laneAssign&gt; &lt;isComboMode&gt;1&lt;/isComboMode&gt; &lt;/CSIInfo&gt; &lt;!--Lens information --&gt; &lt;lensInfo description=&quot;Lens Information&quot;&gt; &lt;!--Focal length of the lens in millimeters. --&gt; &lt;focalLength&gt;4.71&lt;/focalLength&gt; &lt;!--F-Number of the optical system. --&gt; &lt;fNumber&gt;1.79&lt;/fNumber&gt; &lt;!--Minimum focus distance in meters. --&gt; &lt;minFocusDistance&gt;0.1&lt;/minFocusDistance&gt; &lt;!--Total focus distance in meters. --&gt; &lt;maxFocusDistance&gt;1.9&lt;/maxFocusDistance&gt; &lt;!--Horizontal view angle in degrees. --&gt; &lt;horizontalViewAngle&gt;67&lt;/horizontalViewAngle&gt; &lt;!--Vertical view angle in degrees. --&gt; &lt;verticalViewAngle&gt;53&lt;/verticalViewAngle&gt; &lt;!--Maximum Roll Degree. Valid values are: 0, 90, 180, 270, 360 --&gt; &lt;maxRollDegree&gt;270&lt;/maxRollDegree&gt; &lt;!--Maximum Pitch Degree. Valid values are: 0 to 359 --&gt; &lt;maxPitchDegree&gt;360&lt;/maxPitchDegree&gt; &lt;!--Maximum Yaw Degree. Valid values are: 0 to 359 --&gt; &lt;maxYawDegree&gt;360&lt;/maxYawDegree&gt; &lt;/lensInfo&gt; &lt;pdafName&gt;&lt;/pdafName&gt; &lt;/moduleConfiguration&gt; &lt;/moduleGroup&gt;&lt;/cameraModuleData&gt; 配置 CameraId 与kernel dts 相对应 配置sensorname 与 sensor xml 保持一致 配置 chromatixName 与 sensor name 保持一致 配置 position 摄像头位置 前摄 后摄 或者 后辅 配置 CSIInfo mipi 通道 Dump EEprom Data1adb shell &quot;echo dumpSensorEEPROMData=1 &gt;&gt; /vendor/etc/camera/camxoverridesettings.txt&quot; 数据存放位置： /data/vendor/camera/xxx_kbuffer_OTP.txt","tags":[]},{"title":"高通 Camx capture result 代码流程","date":"2019-12-31T16:00:06.000Z","path":"2020/01/01/技术研发/Camera Driver/高通 Camx/高通 Camx capture result 代码流程/","text":"预览和拍照的 result 代码流程","tags":[]},{"title":"高通 Camx capture request 代码流程","date":"2019-12-31T16:00:05.000Z","path":"2020/01/01/技术研发/Camera Driver/高通 Camx/高通 Camx capture request 代码流程/","text":"预览和拍照的 request 代码流程主体框架图 详细代码调用流程123456789101112chi_override_process_request() //chxextensioninterface.cpp OverrideProcessRequest() //chxextensionmodule.cpp ProcessCaptureRequest()//chxusecase.cpp ExecuteCaptureRequest() //chxadvancedcamerausecase.cpp result = pFeature-&gt;ExecuteProcessRequest(pRequest); //会调到chifeature2wrapper.cpp:494 ExecuteProcessRequest() ExecuteProcessRequest() //chifeature2wrapper.cpp 开始进入算法的领域 SubmitRequestToSession() //经过一系类调用会走到 chifeature2base.cpp result = ExtensionModule::GetInstance()-&gt;ActivatePipeline() OnSubmitRequestToSession() ProcessFeatureMessage() ProcessMessageCb() //通过回调又重新回到 chifeature2wrapper.cpp result = pFeature2Wrapper-&gt;m_pUsecaseBase-&gt;SubmitRequest(&amp;submitRequest); //将 request 下到 camx session 中 CHI feature 通过 usecase 提交 request 到 session, 套路还是一样的（chxextensionmodule.cpp 通过这条链路转到Camx） 12result = pSession-&gt;ProcessCaptureRequest(pRequest); //camxchicontext.cpp feature submit request 会调到这里从这里开始步入 session CamxResult Session::ProcessCaptureRequest(); //camxsession.cpp","tags":[]},{"title":"高通 Camx config stream 代码流程","date":"2019-12-31T16:00:04.000Z","path":"2020/01/01/技术研发/Camera Driver/高通 Camx/高通 Camx config stream 代码流程/","text":"","tags":[]},{"title":"Arch Linux 开发环境的搭建","date":"2019-12-31T16:00:03.000Z","path":"2020/01/01/计算机基础知识/Arch Linux 开发环境的搭建/","text":"Arch Linux 系统安装主要进行分区，系统的安装，图形服务和必要驱动的安装 分区 查看当前分区信息 1fdisk -l 设置分区 1cfdisk /dev/sda 1)首先选择分区类型 ​ MBR 选择 dos ​ GPT 选择 gpt 2)MBR启动一般分为2个分区 ​ 主分区 （选择为boot标志） ​ 交换分区（内存的2倍） 格式化分区 格式化主分区 1mkfs.ext4 /dev/sda1 格式化交换分区 1mkswap /dev/sda2 启动交换分区 1swapon /dev/sda2 挂载分区 1mount /dev/sda1 /mnt 编辑镜像源1vim /etc/pacman.d/mirrorlist 将中国的源放在文件的开头 安装系统基本组件1pacstrap /mnt base linux linux-firmware 安装基本开发工具包12arch-chroot /mntpacman -S base-devel 安装 sudo123arch-chroot /mntpacman -S sudo vi vimvisudo 删除这一行注释 %wheel ALL = (ALL) ALL 创建用户123arch-chroot /mntuseradd -G wheel -m 用户名passwad 用户名 安装 Grub1234arch-chroot /mntpacman -S grubgrub-install --target=i386-pc /dev/sdagrub-mkconfig -o /boot/grub/grub.cfg 生成 fstab该配置不需要 arch-chroot 1genfstab /mnt &gt; /mnt/etc/fstab 安装 Xorg 图形管理1pacstrap /mnt xorg-server xorg-xinit xorg-apps 安装网络组件12345pacstrap /mnt dhcpcd wpa_supplicant networkmanagerarch-chroot /mntsystemctl enable dhcpcdsystemctl enable wpa_supplicantsystemctl enable networkmanager 安装显卡驱动12lspci | grep VGA //查看显卡是什么型号pacman -S xf86-video-intel //intel 显卡驱动 安装音频组件12pacstrap /mnt alsa-utils pulseaudiopacstrap /mnt pulseaudio-alsa Arch Linux 桌面环境安装窗口管理器 dwm 安装终端内置浏览器 w3m 1sudo pacman -S w3m 下载 dwm 1w3m suckless.org 安装 1sudo make clean install 运行dwm 12vim ~/.xinitrcstartx 在 .xinitrc 中 加入 exec dwm 窗口管理器 i3 Arch Linux 基础配置安装中文字体 12sudo pacman -S noto-fonts noto-fonts-cjk noto-fonts-emojisudo vim /etc/locale.gen 取消 /etc/locale.gen 中 以下 的注释 en_US.UTF-8 UTF-8 zh_CN.UTF-8 UTF-8 zh_TW.UTF-8 UTF-8 生成 locale 1sudo locale-gen 设置 archlinuxcn123sudo vim /etc/pacman.confsudo pacman -Sysudo pacman -S archlinuxcn-keyring 在文件的末尾插入 [archlinuxcn] Server = https://mirrors.ustc.edu.cn/archlinuxcn/$arch 安装 Chrome1sudo pacman -S google-chrome 安装中文输入法 安装输入法以及配置工具 1sudo pacman -S fcitx fcitx-im kcm-fcitx fcitx-qt5 fcitx-gtk2 fcitx-gtk3 fcitx-configtool 配置输入法 1vim ~/.xprofile 输入以下内容 export GTK_IM_MODULE=fcitxexport QT_IM_MODULE=fcitxexport XMODIFIERS=”@im=fcitx” SSH 的安装与配置 安装ssh 1pacman -Sy openssh 生成密钥 1ssh-keygen -t rsa -C &quot;xxxxx@xxxxx.com&quot; 通过 SSH 远程连接问题 1vim /etc/ssh/sshd_config 在文件的末尾加以下配置 LoginGraceTime 120PermitRootLogin yesStrictModes yes","tags":[{"name":"Arch Linux","slug":"Arch-Linux","permalink":"https://zh-wiki.github.io/tags/Arch-Linux/"}]},{"title":"高通 Camx Camx open camera","date":"2019-12-31T16:00:03.000Z","path":"2020/01/01/技术研发/Camera Driver/高通 Camx/高通 Camx open camera/","text":"Open Camera 的流程简介当用户打开了相机设备之后，便会发生如下过程： APP调用CameraManager的openCamera方法，层层调用之后最终调用到Camera Service层中的CameraService::connectDevice方法 然后通过ICameraDevice::open()这一个HIDL接口通知Camera Provider层 在Camera Provider层内部又通过调用之前获取的camera_module_t中methods的open方法来获取一个Camera 设备，对应于HAL中的camera3_device_t结构体 在Camera Provider层调用获取到的camera3_device_t的initialize方法进行初始化动作 代码大概流程走向 12345678910//APP 端 open CameraCameraManager::openCamera() //Camera Server CameraService::connectDevice() //通过HIDL接口 ICameraDevice::open() //camera provider camera_module_t::methods::open() //接下来就是进行一些初始化操作 camera3_device_t::initialize() APP Open Camera 流程App端主要做了以下几点工作 获取 CameraManager 服务 打开指定的 Camera 获取 Camera Server 调用 cameraService.connectDevice() 去连接打开设备，并且将上层传下来的回调传入Camera Server 返回Device给App端 123456789101112131415161718192021//apk端获取CameraManager 服务mCamManager = (CameraManager)getSystemService(Context.CAMERA_SERVICE); //打开指定camera--&gt; mCamManager.openCamera(mCameraId, mStateCallback, null); //frameworks/base/core/java/android/hardware/camera2/CameraManager.javapublic void openCamera(@NonNull String cameraId, @NonNull @CallbackExecutor Executor executor, @NonNull final CameraDevice.StateCallback callback) |--&gt; openCameraForUid(cameraId, callback, executor, USE_CALLING_UID) | |--&gt; openCameraDeviceUserAsync(cameraId, callback, executor, clientUid); | | |--&gt; CameraDevice device = null; //初始化CameraDevice | | | //实例化 new android.hardware.camera2.impl.CameraDeviceImpl | | |--&gt; android.hardware.camera2.impl.CameraDeviceImpl deviceImpl = new android.hardware.camera2.impl.CameraDeviceImpl(...) | | |--&gt; ICameraDeviceCallbacks callbacks = deviceImpl.getCallbacks(); //获取回调 | | |--&gt; ICameraService cameraService = CameraManagerGlobal.get().getCameraService(); //获取CameraService 服务 | | |--&gt; cameraUser = cameraService.connectDevice(callbacks, cameraId, mContext.getOpPackageName(), uid); //连接打开camera | | |--&gt; goto CONNECTDEVICE: //跳转到下面CONNECTDEVICE处进行分析 | | |--&gt; deviceImpl.setRemoteDevice(cameraUser); | | | |--&gt; mRemoteDevice = new ICameraDeviceUserWrapper(remoteDevice); | | | |--&gt; mDeviceExecutor.execute(mCallOnOpened); //这里是一个线程池 | | | | |--&gt; sessionCallback = mSessionStateCallback; //获取session cb | | | | |--&gt; sessionCallback.onOpened(CameraDeviceImpl.this); //通过session cb 返回device | | | | |--&gt; mDeviceCallback.onOpened(CameraDeviceImpl.this); //通过device cb 返回device,这里就是返回给apk端的CameraDevice了 Camera Server Open 流程对于打开相机设备动作,主要由connectDevice来实现，当CameraFramework通过调用ICameraService的connectDevice接口的时候,主要做了两件事情： 创建CameraDeviceClient。 对CameraDeviceClient进行初始化,并将其返回给Framework。 创建 CameraDevcieClientCameraDeviceClient 该类在打开设备的时候被实例化，一次打开设备的操作对应一个该类对象，它实现了ICameraDeviceUser接口，以AIDL方式暴露接口给Camera Framework进行调用，于此同时,该类在打开设备的过程中，获取了来自Camera Framework对于ICameraDeviceCallback接口的实现代理，通过该代理可以将结果上传至Camera Framewor中。我个人的理解其实这个类就是 framework 与 Camera 的通信入口。 代码流程如下： 首先实例化一个CameraDeviceClient 将来自Framework针对ICameraDeviceCallback的实现存入CameraDeviceClient中，一旦有结果产生便可以将结果通过这个回调回传给Framework 123456789//frameworks/av/services/camera/libcameraservice/CameraService.cppStatus CameraService::connectDevice(const sp&lt;hardware::camera2::ICameraDeviceCallbacks&gt;&amp; cameraCb, const String16&amp; cameraId, const String16&amp; clientPackageName, int clientUid, sp&lt;hardware::camera2::ICameraDeviceUser&gt;* device) //最后一个参数是返回值 |--&gt; connectHelper&lt;hardware::camera2::ICameraDeviceCallbacks,CameraDeviceClient&gt;(...) //模板，CALLBACK 为hardware::camera2::ICameraDeviceCallbacks， CLIENT： CameraDeviceClient | |--&gt; validateConnectLocked(...) //关于一些权限的判断，如果没有权限或者非法访问这里会直接退出 | |--&gt; int deviceVersion = getDeviceVersion(cameraId, /*out*/&amp;facing) //获取device version, 为之后的实例化哪一个client 做准备 | |--&gt; makeClient(..., deviceVersion, effectiveApiLevel, ...) //这里主要是这两个参数决定了实例化哪一个client， | |--&gt; *client = new CameraDeviceClient(cameraService, tmp, packageName, cameraId,facing, clientPid, clientUid, servicePid) //这里是实例化了CameraDeviceClient | |--&gt; client = static_cast&lt;CLIENT*&gt;(tmp.get()); //取得makeClient中实例化好的client | |--&gt; client-&gt;initialize(mCameraProviderManager, mMonitorTags); //开始初始化 初始化 CameraDevcieClientCameraDeviceClient的初始化工作流程： 调用父类Camera2ClientBase的initialize方法进行初始化 实例化FrameProcessorBase对象并且将内部的Camera3Device对象传入其中,这样就建立了和Camera3Device的联系,之后将内部线程运行起来,等待来自Camera3Device的结果 将CameraDeviceClient注册到内部,这样就建立了与CameraDeviceClient的联系 123456789//file : frameworks/av/services/camera/libcameraservice/api2/CameraDeviceClient.cppstatus_t CameraDeviceClient::initialize(sp&lt;CameraProviderManager&gt; manager, const String8&amp; monitorTags) |--&gt; initializeImpl(manager, monitorTags) |--&gt; mFrameProcessor = new FrameProcessorBase(mDevice); //实例化FrameProcessorBase对象 | |--&gt; Camera2ClientBase::initialize(providerPtr, monitorTags) //file: frameworks/av/services/camera/libcameraservice/common/Camera2ClientBase.cpp | |--&gt; status_t Camera2ClientBase&lt;TClientBase&gt;::initialize(sp&lt;CameraProviderManager&gt; manager, const String8&amp; monitorTags) | | |--&gt; initializeImpl(manager, monitorTags) | | | |--&gt; mDevice-&gt;initialize(providerPtr, monitorTags) //这里的mDevice 是在 Camera2ClientBase初始化的时候传入的 mDevice(new Camera3Device(cameraId)) Camera3Device 结构介绍 主要实现了对Camera Provider 的ICameraDeviceCallbacks会调接口的实现，通过该接口接收来自Provider的结果上传进而传给CameraDeviceClient Camera3Device会将事件通过notify方法给到CameraDeviceClient Camera3Device中RequestThread主要用于处理Request的接收与下发工作 Camera3Device 初始化 通过调用CameraProviderManager的openSession方法打开并获取一个Provider中的ICameraDeviceSession代理 实例化一个HalInterface对象,将之前获取的ICameraDeviceSession代理存入其中,最后将RequestThread线程运行起来,等待request的下发 123456789//file: device3/Camera3Device.cpp status_t Camera3Device::initialize(sp&lt;CameraProviderManager&gt; manager, const String8&amp; monitorTags) |--&gt; status_t res = manager-&gt;openSession(mId.string(), this, /*out*/ &amp;session) //CameraProviderManager openSession //file: common/CameraProviderManager.cpp | |--&gt; status_t CameraProviderManager::openSession(const std::string &amp;id, const sp&lt;device::V3_2::ICameraDeviceCallback&gt;&amp; callback, sp&lt;device::V3_2::ICameraDeviceSession&gt; *session) | | |--&gt; auto interface = deviceInfo3-&gt;startDeviceInterface&lt;CameraProviderManager::ProviderInfo::DeviceInfo3::InterfaceT&gt;() | | | |--&gt; const sp&lt;provider::V2_4::ICameraProvider&gt; interface = startProviderInterface() //获取provider | | | |--&gt; interface-&gt;getCameraDeviceInterface_V3_x(name, [&amp;status, &amp;cameraInterface](hidl_cb) //这里的hidl_cb 指的是回调接口，provider 会将device 指针返回回来，当然这个指针是跨进程能够调用的，具体怎么实现的暂时不清楚，暂且不管 | | |--&gt; interface-&gt;open(callback, [&amp;status, &amp;session](Status s, const sp&lt;device::V3_2::ICameraDeviceSession&gt;&amp; cameraSession) //这里就调用的provider部分的Device的open接口 FrameProcessBase 结构介绍 meta data以及image data 会给到 FrameProcessBase FrameProcessBase主要用于metadata以及image data的中转处理 Provider Open 流程123456789//file: device/3.2/default/CameraDevice.cppReturn&lt;void&gt; CameraDevice::open(const sp&lt;ICameraDeviceCallback&gt;&amp; callback, ICameraDevice::open_cb _hidl_cb) //这里的mModule 是CameraModule实例，在provider调用etCameraDeviceInterface_V3_x 方法时通过实例化device deviceImpl = new //android::hardware::camera::device::V3_4::implementation::CameraDevice(mModule, cameraId, mCameraDeviceNames) 传入， //而mModule 是在provider初始化的时候创建，里面获取了camera hw module实例,关于proviser的初始化参见provider_initialize |--&gt; mModule-&gt;open(mCameraId.c_str(), reinterpret_cast&lt;hw_device_t**&gt;(&amp;device)) //file: common/1.0/default/CameraModule.cpp |--&gt; int CameraModule::open(const char* id, struct hw_device_t** device) | |--&gt; filterOpenErrorCode(mModule-&gt;common.methods-&gt;open(&amp;mModule-&gt;common, id, device)) Camx Open 流程","tags":[]},{"title":"Centos 开发环境的搭建","date":"2019-12-31T16:00:02.000Z","path":"2020/01/01/计算机基础知识/Centos 开发环境的搭建/","text":"同一网段外部浏览器不能访问Tomcat 问题产生背景和原因 背景：服务器已经安装好tomcat, 服务器主机通过 ip+8080 的方式可以进行访问, 但是其他在同一网段下的客户端机器通过同样方式不能访问. 原因：服务器未将 8080 端口进行开放 解决方法 1)查看防火墙状态 1firewall-cmd --state 2)添加需要开放的端口 1firewall-cmd --permanent --zone=public --add-port=8080/tcp 3)加载配置使其生效 1firewall-cmd --reload 4)查看配置是否生效 1firewall-cmd --permanent --zone=public --list-ports 5)重新访问 Tomcat (IP+8080) 防火墙的相关操作 开启防火墙的命令 1systemctl start firewalld.service 关闭防火墙的命令 1systemctl stop firewalld.service 开机自动启动 1systemctl enable firewalld.service 关闭开机自动启动 1systemctl disable firewalld.service 查看防火墙状态 1systemctl status firewalld","tags":[{"name":"Centos","slug":"Centos","permalink":"https://zh-wiki.github.io/tags/Centos/"}]},{"title":"Repo 常用命令","date":"2019-12-31T16:00:02.000Z","path":"2020/01/01/技术研发/Linux 命令/Repo 常用指令/","text":"repo 拉下来的代码如何新建分支 repo start xxx(分支名) –all repo sync 的时候如果有本地未提交的修改 repo forall -cv “git reset HEAD –hard; git clean -df “ -j32","tags":[]},{"title":"高通 Camx init 流程","date":"2019-12-31T16:00:02.000Z","path":"2020/01/01/技术研发/Camera Driver/高通 Camx/高通 Camx init 流程/","text":"概览Camx-CHI 整体框架如下 其中 camx 代表了通用功能性接口的代码实现集合，chi-cdk代表了可定制化需求的代码实现集合，从图中不难看出camx部分对上作为HAL3接口的实现,对下通过v4l2框架与Kernel保持通讯,中间通过互相dlopen so库并获取对方操作接口的方式保持着与CHI的交互。 camx/中有如下几个主要目录: core/ : 用于存放camx的核心实现模块,其中还包含了主要用于实现hal3接口的hal/目录,以及负责与CHI进行交互的chi/目录 csl/: 用于存放主要负责camx与camera driver的通讯模块,为camx提供了统一的Camera driver控制接口 hwl/: 用于存放自身具有独立运算能力的硬件node,该部分node受csl管理 swl/: 用于存放自身并不具有独立运算能力,必须依靠CPU才能实现的node chi-cdk/中有如下几个主要目录: chioverride/: 用于存放CHI实现的核心模块,负责与camx进行交互并且实现了CHI的总体框架以及具体的业务处理。 bin/: 用于存放平台相关的配置项 topology/: 用于存放用户自定的Usecase xml配置文件 node/: 用于存放用户自定义功能的node module/: 用于存放不同sensor的配置文件,该部分在初始化sensor的时候需要用到 tuning/: 用于存放不同场景下的效果参数的配置文件 sensor/: 用于存放不同sensor的自有信息以及寄存器配置参数 actuator/: 用于存放不同对焦模块的配置信息 ois/: 用于存放防抖模块的配置信息 flash/: 存放着闪光灯模块的配置信息 eeprom/: 存放着eeprom外部存储模块的配置信息 fd/: 存放了人脸识别模块的配置信息 Camx Init 总体概览通过分析 Camera Provider ，已经知道了上层是如何调到底层的Camera Init 流程，大概框架如下 接下来我们将按照模块化分析camx的内部初始化流程","tags":[]},{"title":"Hexo 博客搭建","date":"2019-12-31T16:00:01.000Z","path":"2020/01/01/计算机基础知识/Hexo 博客搭建/","text":"安装 Hexo1sudo npm install --unsafe-perm --verbose -g hexo 同步本地图片与网络图片 安装插件 1npm install https://github.com/CodeFalling/hexo-asset-image --save 配置Typora 编译 有以下log说明配置成功","tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://zh-wiki.github.io/tags/Hexo/"}]},{"title":"Git 常用命令","date":"2019-12-31T16:00:01.000Z","path":"2020/01/01/技术研发/Linux 命令/Git 常用命令/","text":"撤销指令 撤销工作区的修改 git checkout 文件名 git checkout 目录 -f 从暂存区撤销到工作区（可以理解为git add的反向动作） git reset HEAD 从版本库撤销到暂存区 git reset –soft HEAD^ 从版本库撤销到工作区 git reset –mixed HEAD^ 撤销到上一次提交（本地修改丢失） git reset –hard HEAD^ 保存恢复指令 保存本地未追踪的修改 git stash save 路径 将保存的内容导出 git stash pop stash@{index} 获取保存列表 git stash list 解决冲突这里我分为两种情况： 代码提到服务器上。 a. 首先把自己的提交reset掉。 b.更新代码 c.将自己的代码从服务器上拉下来。 d.冲突用code工具解决掉。然后add 修改文件，重新commit 代码在本地提交 a.将本地提交撤回到工作区。 b.保存本地修改 c.更新代码 d.将保存的代码还原。 e.冲突用code工具解决掉。然后add 修改文件，重新commit","tags":[]},{"title":"高通 Camx camera provider","date":"2019-12-31T16:00:01.000Z","path":"2020/01/01/技术研发/Camera Driver/高通 Camx/高通 Camx camera provider/","text":"概览 通过图片可以看出Camera Provider 分为两部分 通过 HIDL 与Camera Service 跨进程通信 通过 dlopen 方式加载一系列动态库 （Camera HAL3结构的so），在高通Camera 是指 camx-chi 架构 camera provider 和 camera hal3 的联系HAL硬件抽象层(Hardware Abstraction Layer),是谷歌开发的用于屏蔽底层硬件抽象出来的一个软件层，该层定义了自己的一套通用标准接口,平台厂商务必按照以下规则定义自己的Module 每一个硬件都通过hw_module_t来描述,具有固定的名字HMI 每一个硬件都必须实现hw_module_t里面的open方法,用于打开硬件设备,并返回对应的操作接口集合 硬件的操作接口集合使用hw_device_t 来描述,并可以通过自定义一个更大的包含hw_device_t的结构体来拓展硬件操作集合 HAL3 结构体介绍 hw_module_t 1234567891011121314151617typedef struct hw_module_t &#123; uint32_t tag; uint16_t module_api_version;#define version_major module_api_version uint16_t hal_api_version;#define version_minor hal_api_version const char *id; const char *name; const char *author; struct hw_module_methods_t* methods; void* dso;#ifdef __LP64__ uint64_t reserved[32-7];#else uint32_t reserved[32-7];#endif&#125; hw_module_t; hw_module_methods_t 12345typedef struct hw_module_methods_t &#123; /** Open a specific device */ int (*open)(const struct hw_module_t* module, const char* id, struct hw_device_t** device);&#125; hw_module_methods_t; hw_device_t 12345678910111213typedef struct hw_device_t &#123; uint32_t tag; uint32_t version; struct hw_module_t* module;#ifdef __LP64__ uint64_t reserved[12];#else uint32_t reserved[12];#endif int (*close)(struct hw_device_t* device); &#125; hw_device_t; 从上面的定义可以看出 hw_module_t 代表了模块，通过其open方法用来打开一个设备 设备是用hw_device_t来表示，其中除了用来关闭设备的close方法外,并无其它方法 由此可见谷歌定义的HAL接口,并不能满足绝大部分HAL模块的需要,所以谷歌想出了一个比较好的解决方式,那便是将这两个基本结构嵌入到更大的结构体内部,同时在更大的结构内部定义了各自模块特有的方法,用于实现模块的功能,这样,一来对上保持了HAL的统一规范,二来也扩展了模块的功能 高通 camx HAL3 结构体 camera_module_t 123456789101112131415typedef struct camera_module &#123; hw_module_t common; int (*get_number_of_cameras)(void); int (*get_camera_info)(int camera_id, struct camera_info *info); int (*set_callbacks)(const camera_module_callbacks_t *callbacks); void (*get_vendor_tag_ops)(vendor_tag_ops_t* ops); int (*open_legacy)(const struct hw_module_t* module, const char* id, uint32_t halVersion, struct hw_device_t** device); int (*set_torch_mode)(const char* camera_id, bool enabled); int (*init)(); int (*get_physical_camera_info)(int physical_camera_id, camera_metadata_t **static_metadata); int (*is_stream_combination_supported)(int camera_id, const camera_stream_combination_t *streams); void (*notify_device_state_change)(uint64_t deviceState); int (*get_camera_device_version)(int camera_id, uint32_t *version); void* reserved[1];&#125; camera_module_t; camera3_device_t 12345typedef struct camera3_device &#123; hw_device_t common; camera3_device_ops_t *ops; void *priv;&#125; camera3_device_t; camera_module_t包含了hw_module_t，主要用于表示Camera模块，其中定义了诸如get_number_of_cameras以及set_callbacks等扩展方法 camera3_device_t包含了hw_device_t,主要用来表示Camera设备,其中定义了camera3_device_ops操作方法集合,用来实现正常获取图像数据以及控制Camera的功能 Camera HAL3 的实现1234567891011121314151617181920CAMX_VISIBILITY_PUBLIC camera_module_t HAL_MODULE_INFO_SYM =&#123; .common = &#123; .tag = HARDWARE_MODULE_TAG, .module_api_version = CAMERA_MODULE_API_VERSION_CURRENT, .hal_api_version = HARDWARE_HAL_API_VERSION, .id = CAMERA_HARDWARE_MODULE_ID, .name = &quot;QTI Camera HAL&quot;, .author = &quot;Qualcomm Technologies, Inc.&quot;, .methods = &amp;CamX::g_hwModuleMethods &#125;, .get_number_of_cameras = CamX::get_number_of_cameras, .get_camera_info = CamX::get_camera_info, .set_callbacks = CamX::set_callbacks, .get_vendor_tag_ops = CamX::get_vendor_tag_ops, .open_legacy = NULL, .set_torch_mode = CamX::set_torch_mode, .init = CamX::init&#125;; 没错高通 camx hal3 的入口就是这个，在遵循HAL3规范的前提下，实例化各个接口。Provider 将会调用 hw_get_module() 来获取该入口。 各个接口映射到 camxhal3.cpp 1static Dispatch g_dispatchHAL3(&amp;g_jumpTableHAL3); 123456789101112131415161718192021222324252627JumpTableHAL3 g_jumpTableHAL3 =&#123; open, get_number_of_cameras, get_camera_info, set_callbacks, get_vendor_tag_ops, open_legacy, set_torch_mode, init, get_tag_count, get_all_tags, get_section_name, get_tag_name, get_tag_type, close, initialize, configure_streams, construct_default_request_settings, process_capture_request, dump, flush, camera_device_status_change, torch_mode_status_change, process_capture_result, notify&#125;; Provider init 代码流程 在系统初始化的时候，系统会去运行”&#x61;&#x6e;&#x64;&#114;&#111;&#x69;&#100;&#46;&#x68;&#97;&#114;&#100;&#119;&#x61;&#114;&#101;&#46;&#x63;&#97;&#109;&#x65;&#x72;&#97;&#x2e;&#x70;&#114;&#111;&#118;&#105;&#x64;&#101;&#114;&#64;&#x32;&#x2e;&#x34;&#45;&#x73;&#x65;&#x72;&#118;&#105;&#x63;&#101;&#x5f;&#x36;&#52;“程序启动Provider进程，并加入HW Service Manager中接受统一管理。在改过程中实例化一个 LegacyCameraProviderImpl_2_4 对象，通过 hw_get_module 标准方法 获取HAL 模块。这边指的是 camera.qcom.so 。 Camera Provider Init 函数总括123456789101112131415161718192021// hardware/interfaces/camera/provider/2.4/default/LegacyCameraProviderImpl_2_4.cppbool LegacyCameraProviderImpl_2_4::initialize() &#123; camera_module_t *rawModule; //获取 camera.qcom.so 可以理解为和 camxhal3entry.cpp 建立联系 int err = hw_get_module(CAMERA_HARDWARE_MODULE_ID, (const hw_module_t **)&amp;rawModule); //将 camera.qcom.so 获取的句柄保存在 mModule 对象中 ，该函数定义在 CameraModule.cpp mModule = new CameraModule(rawModule); //我们可以跟进去看看 init() 非常明显 实际就是进行 camx 的初始化，camxhal3entry.cpp &#123; CAMX:: init()&#125; //int CameraModule::init() 这个函数将会调用 getNumberOfCameras() //就此 camx-chi 的一系列初始化操作 拉开序幕 err = mModule-&gt;init(); // 设置回调函数，用于接受camx-chi的数据和事件 err = mModule-&gt;setCallbacks(this); mNumberOfLegacyCameras = mModule-&gt;getNumberOfCameras(); return false; // mInitFailed&#125; init 函数结束之后，Camera Provider进程便一直便存在于系统中,监听着来自Camera Service的调用。 Camera Provider Init 分解通过上面的总括可以理解为 Provider 最终目的获取 Camx-Chi 的 setting 以及 HW 资源。然后保存起来返回给上层，供后面使用。 二话不说先上一张大图 get_number_of_cameras 函数介绍这个函数是一切美好的开始，她的最先调用就是上面介绍的provide init 函数的 CameraModule::init() 123456789101112131415//hardware/interfaces/camera/common/1.0/default/CameraModule.cppint CameraModule::init() &#123; ATRACE_CALL(); int res = OK; if (getModuleApiVersion() &gt;= CAMERA_MODULE_API_VERSION_2_4 &amp;&amp; mModule-&gt;init != NULL) &#123; ATRACE_BEGIN(&quot;camera_module-&gt;init&quot;); res = mModule-&gt;init(); ATRACE_END(); &#125; //将会走到 vendor/proprietary/camx/src/coer/hal/camxhal3.cpp中 mNumberOfCameras = getNumberOfCameras(); mCameraInfoMap.setCapacity(mNumberOfCameras); return res;&#125; CameraModule::init() ，这个函数调用 getNumberOfCameras() 。最终调用到 get_number_of_cameras() 这个函数已经是干到camx了。 1234567891011//vendor/proprietary/camx/src/coer/hal/camxhal3.cppstatic int get_number_of_cameras(void)&#123; ...... INT numCameras; //将会走到 vendor/proprietary/camx/src/coer/hal/camxhal3module.cpp中 //会调用到 HAL3Module的构造函数 numCameras = static_cast&lt;int&gt;(HAL3Module::GetInstance()-&gt;GetNumCameras()); ...... return numCameras;&#125; 这个函数主要有两个作用： 是通过 HAL3Module 类的构造函数会获取 CAMX-CHI 的信息 加载 com.qti.chi.override.so 模块，映射 CAMX-CHI 之间的接口 12345678910111213141516//vendor/proprietary/camx/src/coer/hal/camxhal3module.cppHAL3Module::HAL3Module()&#123; CamxResult result = CamxResultSuccess; CSLCameraPlatform CSLPlatform = &#123;&#125;; CAMX_LOG_CONFIG(CamxLogGroupHAL, &quot;***************************************************&quot;); CAMX_LOG_CONFIG(CamxLogGroupHAL, &quot;SHA1: %s&quot;, CAMX_SHA1); CAMX_LOG_CONFIG(CamxLogGroupHAL, &quot;COMMITID: %s&quot;, CAMX_COMMITID); CAMX_LOG_CONFIG(CamxLogGroupHAL, &quot;BUILD TS: %s&quot;, CAMX_BUILD_TS); CAMX_LOG_CONFIG(CamxLogGroupHAL, &quot;***************************************************&quot;); ...... //到了这个位置已经是很亲切了，干到camx了 m_pStaticSettings = HwEnvironment::GetInstance()-&gt;GetStaticSettings(); ......&#125; HwEnvironment::Initialize() 函数介绍通过 HAL3Module 构造函数会调用 HwEnvironment 类的构造，主体功能在 HwEnvironment::Initialize() 中实现 HwEnvironment::Initialize() 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192//vendor/proprietary/camx/src/coer/camxhwenvironment.cppCamxResult HwEnvironment::Initialize()&#123; CamxResult result = CamxResultSuccess; CSLInitializeParams params = &#123; 0 &#125;; SettingsManager* pStaticSettingsManager = SettingsManager::Create(NULL); ExternalComponentInfo* pExternalComponent = GetExternalComponent(); if (NULL != pStaticSettingsManager) &#123; const StaticSettings* pStaticSettings = pStaticSettingsManager-&gt;GetStaticSettings(); if (NULL != pStaticSettings) &#123; params.mode = pStaticSettings-&gt;CSLMode; params.emulatedSensorParams.enableSensorSimulation = pStaticSettings-&gt;enableSensorEmulation; params.emulatedSensorParams.dumpSensorEmulationOutput = pStaticSettings-&gt;dumpSensorEmulationOutput; OsUtils::StrLCpy(params.emulatedSensorParams.sensorEmulatorPath, pStaticSettings-&gt;sensorEmulatorPath, sizeof(pStaticSettings-&gt;sensorEmulatorPath)); OsUtils::StrLCpy(params.emulatedSensorParams.sensorEmulator, pStaticSettings-&gt;sensorEmulator, sizeof(pStaticSettings-&gt;sensorEmulator)); result = CSLInitialize(&amp;params); if (CamxResultSuccess == result) &#123; // Query the camera platform result = QueryHwContextStaticEntryMethods(); &#125; if (CamxResultSuccess == result) &#123; m_pHwFactory = m_staticEntryMethods.CreateHwFactory(); if (NULL == m_pHwFactory) &#123; CAMX_ASSERT_ALWAYS_MESSAGE(&quot;Failed to create the HW factory&quot;); result = CamxResultEFailed; &#125; &#125; if (CamxResultSuccess == result) &#123; m_pSettingsManager = m_pHwFactory-&gt;CreateSettingsManager(); if (NULL == m_pSettingsManager) &#123; CAMX_ASSERT_ALWAYS_MESSAGE(&quot;Failed to create the HW settings manager&quot;); result = CamxResultEFailed; &#125; &#125; if (CamxResultSuccess == result) &#123; m_staticEntryMethods.GetHWBugWorkarounds(&amp;m_workarounds); &#125; &#125; pStaticSettingsManager-&gt;Destroy(); pStaticSettingsManager = NULL; &#125; CAMX_ASSERT(NULL != pExternalComponent); if ((CamxResultSuccess == result) &amp;&amp; (NULL != pExternalComponent)) &#123; result = ProbeChiComponents(pExternalComponent, &amp;m_numExternalComponent); &#125; if (CamxResultSuccess == result) &#123; // Load the OEM sensor capacity customization functions CAMXCustomizeCAMXInterface camxInterface; camxInterface.pGetHWEnvironment = HwEnvironment::GetInstance; CAMXCustomizeEntry(&amp;m_pOEMInterface, &amp;camxInterface); &#125; if (CamxResultSuccess != result) &#123; CAMX_LOG_ERROR(CamxLogGroupCore, &quot;FATAL ERROR: Raise SigAbort. HwEnvironment initialization failed&quot;); m_numberSensors = 0; OsUtils::RaiseSignalAbort(); &#125; else &#123; m_initCapsStatus = InitCapsInitialize; &#125; return result;&#125; 通过上面的代码可以看出 HwEnvironment::Initialize() 做的事情还是挺多的。下面我们开始分析 获取camx的相关配置 SettingsManager* pStaticSettingsManager = SettingsManager::Create(NULL); 经过一系列调用最终会调到以下代码，加载配置参数 123456789101112131415161718192021//vendor/proprietary/camx/src/coer/camxsettingsmanager.cppCamxResult SettingsManager::Initialize( StaticSettings* pStaticSettings)&#123; ...... // Populate the default settings InitializeDefaultSettings(); InitializeDefaultDebugSettings(); // Load the override settings from our override settings stores result = LoadOverrideSettings(m_pOverrideSettingsStore); result = LoadOverrideProperties(m_pOverrideSettingsStore, TRUE); result = ValidateSettings(); DumpSettings(); m_pOverrideSettingsStore-&gt;DumpOverriddenSettings(); ...... UpdateLogSettings(); return result;&#125; 利用加载好的配置参数去初始化相关模块 result = CSLInitialize(&amp;params); 经过一个跳转表格进入以下代码 CamxResult CSLInitializeHW() 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768//vendor/proprietary/camx/src/csl/hw/camxcslhw.cppCamxResult CSLInitializeHW()&#123; CamxResult result = CamxResultEFailed; CHAR syncDeviceName[CSLHwMaxDevName] = &#123;0&#125;; if (FALSE == CSLHwIsHwInstanceValid()) &#123; if (TRUE == CSLHwEnumerateAndAddCSLHwDevice(CSLInternalHwVideodevice, CAM_VNODE_DEVICE_TYPE)) &#123; if (TRUE == CSLHwEnumerateAndAddCSLHwDevice(CSLInternalHwVideoSubdevice, CAM_CPAS_DEVICE_TYPE)) &#123; CAMX_LOG_VERBOSE(CamxLogGroupCSL, &quot;Platform family=%d, version=%d.%d.%d, cpas version=%d.%d.%d&quot;, g_CSLHwInstance.pCameraPlatform.family, g_CSLHwInstance.pCameraPlatform.platformVersion.majorVersion, g_CSLHwInstance.pCameraPlatform.platformVersion.minorVersion, g_CSLHwInstance.pCameraPlatform.platformVersion.revVersion, g_CSLHwInstance.pCameraPlatform.CPASVersion.majorVersion, g_CSLHwInstance.pCameraPlatform.CPASVersion.minorVersion, g_CSLHwInstance.pCameraPlatform.CPASVersion.revVersion); if (FALSE == CSLHwEnumerateAndAddCSLHwDevice(CSLInternalHwVideoSubdeviceAll, 0)) &#123; CAMX_LOG_ERROR(CamxLogGroupCSL, &quot;No KMD devices found&quot;); &#125; else &#123; CAMX_LOG_VERBOSE(CamxLogGroupCSL, &quot;Total KMD subdevices found =%d&quot;, g_CSLHwInstance.kmdDeviceCount); &#125; // Init the memory manager data structures here CamX::Utils::Memset(g_CSLHwInstance.memManager.bufferInfo, 0, sizeof(g_CSLHwInstance.memManager.bufferInfo)); // Init the sync manager here g_CSLHwInstance.lock-&gt;Lock(); g_CSLHwInstance.pSyncFW = CamX::SyncManager::GetInstance(); if (NULL != g_CSLHwInstance.pSyncFW) &#123; CSLHwGetSyncHwDevice(syncDeviceName, CSLHwMaxDevName); CAMX_LOG_VERBOSE(CamxLogGroupCSL, &quot;Sync device found = %s&quot;, syncDeviceName); result = g_CSLHwInstance.pSyncFW-&gt;Initialize(syncDeviceName); if (CamxResultSuccess != result) &#123; CAMX_LOG_ERROR(CamxLogGroupCSL, &quot;CSL failed to initialize SyncFW&quot;); result = g_CSLHwInstance.pSyncFW-&gt;Destroy(); g_CSLHwInstance.pSyncFW = NULL; &#125; &#125; g_CSLHwInstance.lock-&gt;Unlock(); CSLHwInstanceSetState(CSLHwValidState); result = CamxResultSuccess; CAMX_LOG_VERBOSE(CamxLogGroupCSL, &quot;Successfully acquired requestManager&quot;); &#125; else &#123; CAMX_LOG_ERROR(CamxLogGroupCSL, &quot;Failed to acquire CPAS&quot;); &#125; &#125; else &#123; CAMX_LOG_ERROR(CamxLogGroupCSL, &quot;Failed to acquire requestManager invalid&quot;); &#125; &#125; else &#123; CAMX_LOG_ERROR(CamxLogGroupCSL, &quot;CSL in Invalid State&quot;); &#125; return result;&#125; 这一部分我个人理解为，遍历所有kernel端的设备。获取相关接口以及需要的事件。与HAL层建立联系。具体分析以后可以单独写一篇文章分析 根据平台获取对应的入口方法 这个暂时不知道是个什么鬼，先这样理解 result = QueryHwContextStaticEntryMethods(); 经过一系列的调用最终是跑到了这里 12345678910111213141516//vendor/proprietary/camx/src/csl/hwl/titan17x/camxtitan17xhwl.cppCamxResult Titan17xGetStaticEntryMethods( HwContextStaticEntry* pStaticEntry)&#123; CamxResult result = CamxResultSuccess; pStaticEntry-&gt;Create = &amp;Titan17xContext::Create; pStaticEntry-&gt;GetStaticMetadataKeysInfo = &amp;Titan17xContext::GetStaticMetadataKeysInfo; pStaticEntry-&gt;GetStaticCaps = &amp;Titan17xContext::GetStaticCaps; pStaticEntry-&gt;CreateHwFactory = &amp;Titan17xFactory::Create; pStaticEntry-&gt;QueryVendorTagsInfo = &amp;Titan17xContext::QueryVendorTagsInfo; pStaticEntry-&gt;GetHWBugWorkarounds = &amp;Titan17xContext::GetHWBugWorkarounds; pStaticEntry-&gt;QueryExternalComponentVendorTagsInfo = &amp;Titan17xContext::QueryExternalComponentVendorTagsInfo; return result;&#125; 获取CHI各个节点的接口 result = ProbeChiComponents(pExternalComponent, &amp;m_numExternalComponent); 遍历所有chi相关的.so库，将各个接口保存起来。这一块的代码撸的比较少，先记录这么多 到此处 HwEnvironment::Initialize() 这个函数就介绍的差不多了。日后慢慢完善 HwEnvironment::InitCaps() 函数介绍 HwEnvironment::InitCaps() 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//vendor/proprietary/camx/src/coer/camxhwenvironment.cppVOID HwEnvironment::InitCaps()&#123; CamxResult result = CamxResultSuccess; m_pHWEnvLock-&gt;Lock(); if (InitCapsRunning == m_initCapsStatus || InitCapsDone == m_initCapsStatus) &#123; m_pHWEnvLock-&gt;Unlock(); return; &#125; m_initCapsStatus = InitCapsRunning; if (CamxResultSuccess == result) &#123; EnumerateDevices(); ProbeImageSensorModules(); EnumerateSensorDevices(); InitializeSensorSubModules(); InitializeSensorStaticCaps(); result = m_staticEntryMethods.GetStaticCaps(&amp;m_platformCaps[0]); // copy the static capacity to remaining sensor&#x27;s for (UINT index = 1; index &lt; m_numberSensors; index++) &#123; Utils::Memcpy(&amp;m_platformCaps[index], &amp;m_platformCaps[0], sizeof(m_platformCaps[0])); &#125; if (NULL != m_pOEMInterface-&gt;pInitializeExtendedPlatformStaticCaps) &#123; m_pOEMInterface-&gt;pInitializeExtendedPlatformStaticCaps(&amp;m_platformCaps[0], m_numberSensors); &#125; &#125; CAMX_ASSERT(CamxResultSuccess == result); if (CamxResultSuccess == result) &#123; InitializeHwEnvironmentStaticCaps(); &#125; m_initCapsStatus = InitCapsDone; m_pHWEnvLock-&gt;Unlock();&#125; 这一波操作应该就是枚举各个Camera模组，检测硬件是否可以通信成功。 Probe Sensor 经过上述函数中 ProbeImageSensorModules() 会走到 ImageSensorModuleData::Probe() 1234567891011121314151617//vendor/proprietary/camx/src/core/camximagesensormoduledata.cppCamxResult ImageSensorModuleData::Probe( BOOL* pDetected, INT32* pDeviceIndex)&#123; ...... //获取上下电时序 UINT powerUpCmdSize = GetSensorDataObject()-&gt;GetPowerSequenceCmdSize(TRUE); UINT powerDownCmdSize = GetSensorDataObject()-&gt;GetPowerSequenceCmdSize(FALSE); //创建命令包管理 result = CmdBufferManager::Create(&quot;ImageSensorPacketManager&quot;, &amp;packetResourceParams, &amp;pPacketManager); //向CSL下发probe命令 result = CSLImageSensorProbe(pProbePacket-&gt;GetMemHandle(), pProbePacket-&gt;GetOffset(), &amp;probeResult); ......&#125; 该函数的主要作用就是创建probe sensor 的命令包，然后下发到CSL 将命令包提交到 CSL 通过ioctl下发到 Kernel 123456789101112131415//vendor/qcom/proprietary/camx/src/csl/hw/camxcslhwinternalsensor.cppCamxResult CSLHwInternalProbeSensorHW( CSLMemHandle hPacket, SIZE_T offset, INT32* pDeviceIndex)&#123; ...... ioctlCmd.op_code = CAM_SENSOR_PROBE_CMD; ioctlCmd.size = sizeof(ioctlCmd.handle); ioctlCmd.handle_type = CAM_HANDLE_MEM_HANDLE; ioctlCmd.reserved = 0; ioctlCmd.handle = hPacket; result = pLoophw-&gt;deviceOp.Ioctl(pLoophw, VIDIOC_CAM_CONTROL, &amp;ioctlCmd); ......&#125;","tags":[]},{"title":"Ubuntu 开发环境的搭建","date":"2019-12-31T16:00:00.000Z","path":"2020/01/01/计算机基础知识/Ubuntu 开发环境的搭建/","text":"ubuntu18.04 virtualBox windows 支持usb 执行命令sudo usermod -aG vboxusers 用户名（让virtualbox 能识别到主机的usb） cat /etc/group | grep vboxusers （查看是否已经添加成功） 下载插件 下载链接. 下载插件比较慢，已经提前下载好的。适用于（virtualbox 5.2.34) 安装插件 设置 USB 协议的支持 reboot （重启ubuntu） 如果重启电脑之后，虚拟机可以扫描到USB设备，但是Ｗin7中提示驱动未能安装成功。解决方法：下载驱动精灵。安装USB驱动。 VirtualBox 修复’modprobe vboxdrv’ 报错 问题发生背景 Linux 内核版本升级之后，virtualbox 的驱动没有更新成功。 解决方法 a.更新整个系统 12sudo apt updatesudo apt upgrade b.重新安装对应内核版本的头文件,和virtualbox的驱动 1sudo apt install --reinstall linux-headers-$(uname -r) virtualbox-dkms dkms c.加载驱动重启 12sudo modprobe vboxdrvreboot 注意事项 更新驱动的时候，会重新编译驱动，所以要选择对应的gcc编译器，太老的估计会凉。 支持多版本的gcc 系统安装ok后默认gcc 版本是 v-7.x。我们先搞一个低版本的gcc 1234sudo apt-get install gcc-4.8sudo apt-get install g++-4.8sudo ln -sf /usr/bin/g++-4.8 /usr/bin/g++sudo ln -sf /usr/bin/gcc-4.8 /usr/bin/gcc 管理多个版本的gcc a.查看存在几个版本的gcc 1ls -l /usr/bin/gcc b.分别为gcc和g++添加管理组 12sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-4.8 40sudo update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++-4.8 40 c.能添加就能删除,从管理组中删除 1sudo update-alternatives --remove gcc /usr/bin/gcc-4.8 设置ok使用以下指令选择gcc的版本 12sudo update-alternatives --config gccsudo update-alternatives --config g++","tags":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://zh-wiki.github.io/tags/Ubuntu/"}]},{"title":"Android 研发总结","date":"2019-12-31T16:00:00.000Z","path":"2020/01/01/技术研发/Android 研发总结/经验总结/","text":"在.mk中添加条件判断如果 TARGET_PRODUCT 等于 lime 或者 citrus 就走if 否则走 else 12345ifeq ($(TARGET_PRODUCT), $(filter $(TARGET_PRODUCT), lime citrus))COMPOSER_TARGET_INPUT := $(CAMX_PATH)/src/settings/$(TARGET_PRODUCT)/camxsettings.xmlelseCOMPOSER_TARGET_INPUT := $(CAMX_PATH)/src/settings/$(TARGET_BOARD_PLATFORM)/camxsettings.xmlendif 如何编译 selinux 编译命令 1make selinux_policy 生成的文件 path : out/target/product/lime/vendor/etc/selinux 如何将最近指定时间(45min)内生成的文件 push 到 指定 的路径1find . -mmin -45 -type f|grep -v SHARED_LIBRARIES|grep -v STATIC_LIBRARIES|grep -Ei &quot;so|bin&quot;|grep -v symbols|xargs -t -I &#x27;&#123;&#125;&#x27; adb push &#123;&#125; /vendor/lib64/&#123;&#125; 如何在安卓中自定义 log12#include &lt;android/log.h&gt; #define GC02M1B_DBG(fmt, args...) __android_log_print(ANDROID_LOG_ERROR, &quot;GC02M1B&quot;,fmt, ##args) Trace 的使用 systrace.py 的路径 path：项目代码/native/external/chromium-trace 如何打开 trace 的 html 在谷歌浏览器输入 chrome://tracing/","tags":[{"name":"Android","slug":"Android","permalink":"https://zh-wiki.github.io/tags/Android/"}]},{"title":"Camera 成像原理和专业名词介绍","date":"2019-12-31T16:00:00.000Z","path":"2020/01/01/技术研发/Camera 专业知识/Camera 成像原理和专业名词/","text":"","tags":[{"name":"Camera","slug":"Camera","permalink":"https://zh-wiki.github.io/tags/Camera/"}]},{"title":"高通 ISP 介绍","date":"2019-12-31T16:00:00.000Z","path":"2020/01/01/技术研发/Camera 专业知识/高通 ISP 相关/","text":"","tags":[{"name":"Camera","slug":"Camera","permalink":"https://zh-wiki.github.io/tags/Camera/"}]},{"title":"ADB 常用命令","date":"2019-12-31T16:00:00.000Z","path":"2020/01/01/技术研发/Linux 命令/ADB 常用命令/","text":"通用命令检测usb设备1adb wait-for-usb-device 属性相关123adb shell setprop 属性名adb shell getpropadb shell getprop | grep -i xxx 安装与卸载apk123adb install xxx.apkadb uninstall com.xxx.xxxadb shell pm list packages | grep xxx 设置屏幕1adb shell input keyevent 26 Cam相关指令dump camera的相关信息1adb shell dumpsys media.camera &gt; cam 查看camera个数1watch -n 1 -d &quot;adb shell dumpsys media.camera|grep Number&quot; 打开摄像头1adb shell am start -a android.media.action.STILL_IMAGE_CAMERA 打开前置摄像头1adb shell am start -a android.media.action.IMAGE_CAPTURE --ei android.intent.extras.CAMERA_FACING 1 高通平台 Camera 相关开启高通相机选择camera id1adb shell setprop persist.sys.camera.devoption.debug 100 使能多摄像1adb shell setprop persist.vendor.camera.multicam 1 开启支持多摄的权限123adb shell setprop vendor.camera.aux.packagelist org.codeaurora.snapcamadb shell setprop persist.vendor.camera.privapp.list org.codeaurora.snapcamadb shell setprop vendor.camera.aux.packagelist &quot;org.codeaurora.snapcam,com.huaqin.cameraautotest,com.huaqin.factory&quot; 高通 Camx 杀死 camera 进程1adb shell ps -A|grep camera |awk &#x27;&#123;print $2&#125;&#x27;|xargs adb shell kill -9 命令解释: awk ‘{print $2}’ 这个命令会把 ps -A | grep camera 得出的进程id 输出到终端 （$2 是第二字段也就是 进程id） xargs adb shell kill -9 这个命令会把 awk 获取到的线程id 当做参数传递给 kill -9 这个命令 高通 Camx dump metadata1adb shell dumpsys media.camera &gt;meta.log ADB 常见问题ADB 连接不上报以下错误 解决方法： 12cd /etc/udev/rules.dsudo vim 51-android.rules 在文件中写入：SUBSYSTEM==”usb”, ENV{DEVTYPE}==”usb_device”, MODE=”0666”","tags":[]},{"title":"小米J19S项目随笔","date":"2019-12-31T16:00:00.000Z","path":"2020/01/01/技术研发/项目随笔/小米J19S项目随笔/","text":"工模测试后辐全不亮解决方法：添加CameraAutoTest 相机权限 路径：device/qcom/qssi/system.prop 12 #Expose aux camera for below packagesvendor.camera.aux.packagelist=org.codeaurora.snapcam,com.huaqin.cameraautotest,com.huaqin.factory 路径：device/xiaomi/lime/system.prop 12#Expose aux camera for below packagesvendor.camera.aux.packagelist=org.codeaurora.snapcam,com.huaqin.cameraautotest,com.huaqin.factory 通过getprop 属性区分主二供方案 module xml 中的 vendorName 配置为：如 sunny_i 或者 sunny_ii ,分别代表主供和二供 将camx解析到的数据传递给chi 在chi中logicalId映射的位置设置属性 实现方法camx 和 chi 的通信 1234567//chxextensionmodule.cppExtensionModule::ExtensionModule()&#123; //这个就是函数接口的映射，核心就在这个全局句柄 g_chiContextOps PCHIENTRY funcPChiEntry = reinterpret_cast&lt;PCHIENTRY&gt;(ChxUtils::LibGetAddr(handle, &quot;ChiEntry&quot;)); funcPChiEntry(&amp;g_chiContextOps);&#125; 12345678910111213//vendor/qcom/proprietary/camx/src/core/chi/camxchi.cppCAMX_VISIBILITY_PUBLIC VOID ChiEntry( ChiContextOps* pChiContextOps)&#123; if (NULL != pChiContextOps) &#123; pChiContextOps-&gt;size = sizeof(ChiContextOps); pChiContextOps-&gt;majorVersion = CHI_API_MAJOR_VERSION; pChiContextOps-&gt;pGetNumCameras = CamX::ChiGetNumCameras; pChiContextOps-&gt;pGetCameraInfo = CamX::ChiGetCameraInfo; pChiContextOps-&gt;pGetModuleName = CamX::ChiGetModuleName; &#125; 很显然如果要扩展功能只需要在ChiContextOps 这个结构体中add一个接口指针。在camxchi.cpp 这个文件中实现改方法，然后在ChiEntry()中进行指针映射。具体方法的实现可以参考别的接口。 针对该需要我实现的接口 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110//chxextensionmodule.cppCDKResult ExtensionModule::EnumerateCameras()&#123; result &amp;= g_chiContextOps.pGetModuleName(m_hCHIContext, i, pModuleName); SetPersistCameraModuleInfo(cameraInfo.sensorCaps.pSensorName, pModuleName);&#125;//chxextensionmodule.cppCDKResult ExtensionModule::SetPersistCameraModuleInfo(CHAR* sensor_name, CHAR* module_name)&#123; char buf[50]=&#123;0&#125;; char name_buf[50]=&#123;0&#125;; char prop_buf[50]=&quot;persist.vendor.camera.&quot;; char *pstr,*pstr_save; if((!sensor_name) || (!module_name)) return CDKResultEFailed; CHX_LOG_INFO(&quot;sensor_name %s module_name %s&quot;,sensor_name,module_name); strcpy(buf, sensor_name); pstr = strchr(buf, &#x27;_&#x27;); if(!pstr) return CDKResultEFailed; snprintf(name_buf, strlen(pstr), &quot;%s&quot;, &amp;pstr[1]); while(pstr) &#123; pstr++; pstr_save = pstr; pstr = strchr(pstr,&#x27;_&#x27;); &#125; strcat(prop_buf, pstr_save); memset(buf,0,sizeof(buf)); strcpy(buf, module_name); pstr = strchr(buf, &#x27;_&#x27;); if(!pstr) return CDKResultEFailed; strcat(name_buf, pstr); if(property_set(prop_buf, name_buf) &lt; 0) &#123; CHX_LOG_ERROR(&quot;property_set is error&quot;); return CDKResultEFailed; &#125; CHX_LOG_INFO(&quot;property_set is success&quot;); return CDKResultSuccess;&#125;//vendor/qcom/proprietary/camx/src/core/chi/camxchi.cppstatic CDKResult ChiGetModuleName( CHIHANDLE hChiContext, UINT32 cameraId, CHAR* pModuleName)&#123; CDKResult result = CDKResultSuccess; ChiContext* pChiContext = GetChiContext(hChiContext); /// @todo (CAMX-2491) CDKResult to CamxResult result = pChiContext-&gt;GetModuleName(cameraId, pModuleName); return result;&#125;//vendor/qcom/proprietary/camx/src/core/chi/camxchicontext.cppCamxResult ChiContext::GetModuleName( UINT32 cameraId, CHAR* pModuleName)&#123; CamxResult result = CamxResultSuccess; if ((cameraId &lt; GetNumCameras())) &#123; ImageSensorModuleData* pImageSensorModuleData = // NOWHINE CP036a: Since the function is const, had to add the const_cast const_cast&lt;ImageSensorModuleData*&gt;(m_pHwEnvironment-&gt;GetImageSensorModuleData(cameraId)); pImageSensorModuleData-&gt;GetModuleName(pModuleName); &#125; else &#123; CAMX_LOG_WARN(CamxLogGroupHAL, &quot;Invalid arguments cameraId = %d, m_numImageSensors = %d&quot;, cameraId, GetNumCameras()); result = CamxResultEInvalidArg; &#125; return result;&#125;//vendor/qcom/proprietary/camx/src/core/camximagesensormoduledata.cppCamxResult ImageSensorModuleData::GetModuleName( CHAR* pModuleName ) const&#123; CamxResult result = CamxResultSuccess; if (NULL != m_pCameraModuleData-&gt;moduleGroup.moduleConfiguration) &#123; strcpy(pModuleName, m_pCameraModuleData-&gt;moduleGroup.moduleConfiguration[m_usedModuleId].moduleName); &#125; else &#123; CAMX_LOG_ERROR(CamxLogGroupSensor, &quot;m_pCameraModuleData-&gt;moduleGroup.moduleConfiguration is NULL&quot;); result = CamxResultEInvalidPointer; &#125; return result;&#125; setprop 属性不成功-权限问题 这个文件中我认为是定义prop的样式，属性名类似与 vendor.camera.xxx， 后面的 _prop 应该是默认格式必须加 123#路径：device/qcom/sepolicy/generic/vendor/common/property.te#camera fuseidtype vendor_camera_fuseid_prop, property_type; 引用前面的类型，定义属性前缀并设置权限 123#路径：device/qcom/sepolicy/generic/vendor/common/property_contexts#vendor-cameravendor.camera.sensor. u:object_r:vendor_camera_fuseid_prop:s0 引用前面两个定义，使其生效 12#路径：device/qcom/sepolicy/generic/vendor/common/hal_camera.teset_prop(hal_camera, vendor_camera_fuseid_prop)","tags":[{"name":"小米项目问题","slug":"小米项目问题","permalink":"https://zh-wiki.github.io/tags/%E5%B0%8F%E7%B1%B3%E9%A1%B9%E7%9B%AE%E9%97%AE%E9%A2%98/"}]},{"title":"MarkDown 常用语法","date":"2019-12-31T16:00:00.000Z","path":"2020/01/01/程序语言/MarkDown/MarkDown 常用语法/","text":"MarkDown 插入音频1&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=330 height=86 src=&quot;音频地址&quot;&gt;&lt;/iframe&gt; MarkDown 插入视频1&lt;iframe height=498 width=510 src=&quot;视频地址&quot; frameborder=0 allowfullscreen&gt;&lt;/iframe&gt; 插入代码折叠片段12345678&lt;details&gt;&lt;summary&gt;标签名&lt;/summary&gt;``````&lt;/details&gt;","tags":[{"name":"MarkDown","slug":"MarkDown","permalink":"https://zh-wiki.github.io/tags/MarkDown/"}]},{"title":"高通 Camx camera server","date":"2019-12-31T16:00:00.000Z","path":"2020/01/01/技术研发/Camera Driver/高通 Camx/高通 Camx camera server/","text":"Camera ServerCamera Server 是一个独立的进程，对上通过AIDL来完成 Camera Framework 的一些请求；对下通过HIDL 将上层发下来的请求提交给 Camera Provider。 Camera Server 对 Camera Framework 而言属于 服务端 Camera Server 对 Camera Provider 而言属于 客户端","tags":[]}],"categories":[],"tags":[{"name":"c++","slug":"c","permalink":"https://zh-wiki.github.io/tags/c/"},{"name":"UML","slug":"UML","permalink":"https://zh-wiki.github.io/tags/UML/"},{"name":"Arch Linux","slug":"Arch-Linux","permalink":"https://zh-wiki.github.io/tags/Arch-Linux/"},{"name":"Centos","slug":"Centos","permalink":"https://zh-wiki.github.io/tags/Centos/"},{"name":"Hexo","slug":"Hexo","permalink":"https://zh-wiki.github.io/tags/Hexo/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://zh-wiki.github.io/tags/Ubuntu/"},{"name":"Android","slug":"Android","permalink":"https://zh-wiki.github.io/tags/Android/"},{"name":"Camera","slug":"Camera","permalink":"https://zh-wiki.github.io/tags/Camera/"},{"name":"小米项目问题","slug":"小米项目问题","permalink":"https://zh-wiki.github.io/tags/%E5%B0%8F%E7%B1%B3%E9%A1%B9%E7%9B%AE%E9%97%AE%E9%A2%98/"},{"name":"MarkDown","slug":"MarkDown","permalink":"https://zh-wiki.github.io/tags/MarkDown/"}]}