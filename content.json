{"pages":[{},{},{}],"posts":[{"title":"Welcome Zhou jun wei's Wiki Site","date":"2020-10-05T08:27:35.037Z","path":"2020/10/05/index/","text":"","tags":[]},{"title":"生活学习","date":"2020-10-04T08:22:36.000Z","path":"2020/10/04/生活学习/生活学习/","text":"","tags":[]},{"title":"艺术","date":"2020-10-04T08:22:36.000Z","path":"2020/10/04/艺术/艺术/","text":"","tags":[]},{"title":"c++","date":"2020-09-29T15:23:24.000Z","path":"2020/09/29/程序语言/C++/c++/","text":"","tags":[{"name":"c++","slug":"c","permalink":"https://zh-wiki.github.io/tags/c/"}]},{"title":"UML","date":"2020-09-29T15:23:24.000Z","path":"2020/09/29/程序语言/UML/UML/","text":"","tags":[{"name":"UML","slug":"UML","permalink":"https://zh-wiki.github.io/tags/UML/"}]},{"title":"高通 Camx 问题总结","date":"2019-12-31T16:01:00.000Z","path":"2020/01/01/技术研发/Camera Driver/高通 Camx/高通 Camx 问题总结/","text":"帧率问题人像模式在暗环境，帧率过低，预览卡顿 首先确认一下信息 测试环境有多暗 lux（是否有量变的过程） camera 镜头距离拍摄物多远 查看sensor 出帧是否正常 开启内核双摄帧同步的log 12adb shell &quot;echo 0x1000018 &gt; ./sys/module/cam_debug_util/parameters/debug_mdl&quot;adb logcat -b kernel &gt; kmd.log 正常环境log 1234Line 3662: 01-02 02:37:40.256 0 0 I CAM_DBG : CAM-ISP: __cam_isp_ctx_send_sof_timestamp: 666: request id:64 frame number:66 SOF time stamp:0x4ceb8d14a14Line 3679: 01-02 02:37:40.256 0 0 I CAM_DBG : CAM-ISP: __cam_isp_ctx_send_sof_timestamp: 666: request id:64 frame number:66 SOF time stamp:0x4ceb8d5cc41Line 4564: 01-02 02:37:40.289 0 0 I CAM_DBG : CAM-ISP: __cam_isp_ctx_send_sof_timestamp: 666: request id:65 frame number:67 SOF time stamp:0x4cebacd4843Line 4618: 01-02 02:37:40.290 0 0 I CAM_DBG : CAM-ISP: __cam_isp_ctx_send_sof_timestamp: 666: request id:65 frame number:67 SOF time stamp:0x4cebad1caa4 通过上述log，发现 request id 和 frame number 都是成双成对的。分别对应主摄和辅摄的出帧。 For Example ：request id:65 frame number:67 Line 4564: 01-02 02:37:40.289 Line 4618: 01-02 02:37:40.290 通过分析log ，可以看出主摄和辅摄只差1ms，同步OK. 暗环境下的log 12345Line 124973: 01-02 03:00:15.035 0 0 I CAM_DBG : CAM-ISP: __cam_isp_ctx_send_sof_timestamp: 666: request id:0 frame number:193 SOF time stamp:0x60a27f1067bLine 124990: 01-02 03:00:15.035 0 0 I CAM_DBG : CAM-ISP: __cam_isp_ctx_send_sof_timestamp: 666: request id:0 frame number:110 SOF time stamp:0x60a27f5890fLine 131018: 01-02 03:00:16.055 0 0 I CAM_DBG : CAM-ISP: __cam_isp_ctx_send_sof_timestamp: 666: request id:0 frame number:213 SOF time stamp:0x60a64afe776Line 131041: 01-02 03:00:16.055 0 0 I CAM_DBG : CAM-ISP: __cam_isp_ctx_send_sof_timestamp: 666: request id:74 frame number:121 SOF time stamp:0x60a64b469d7 很明显没有同步，分别算一下帧率 16.055 - 15.035 = 1.5s 主摄 (213-193)/1.5 = 13fps 辐射 (121-110)/1.5 = 7.3fps 解决方法 方案一 找Tuning的同事固定帧率，调试曝光表","tags":[]},{"title":"高通 Camx Bring up","date":"2019-12-31T16:00:30.000Z","path":"2020/01/01/技术研发/Camera Driver/高通 Camx/高通 Camx Bring up/","text":"Dump EEprom Data1adb shell &quot;echo dumpSensorEEPROMData=1 &gt;&gt; /vendor/etc/camera/camxoverridesettings.txt&quot; 数据存放位置： /data/vendor/camera/xxx_kbuffer_OTP.txt","tags":[]},{"title":"高通 Camx capture result 代码流程","date":"2019-12-31T16:00:06.000Z","path":"2020/01/01/技术研发/Camera Driver/高通 Camx/高通 Camx capture result 代码流程/","text":"预览和拍照的 result 代码流程","tags":[]},{"title":"高通 Camx capture request 代码流程","date":"2019-12-31T16:00:05.000Z","path":"2020/01/01/技术研发/Camera Driver/高通 Camx/高通 Camx capture request 代码流程/","text":"预览和拍照的 request 代码流程主体框架图 详细代码调用流程123456789101112chi_override_process_request() //chxextensioninterface.cpp OverrideProcessRequest() //chxextensionmodule.cpp ProcessCaptureRequest()//chxusecase.cpp ExecuteCaptureRequest() //chxadvancedcamerausecase.cpp result = pFeature-&gt;ExecuteProcessRequest(pRequest); //会调到chifeature2wrapper.cpp:494 ExecuteProcessRequest() ExecuteProcessRequest() //chifeature2wrapper.cpp 开始进入算法的领域 SubmitRequestToSession() //经过一系类调用会走到 chifeature2base.cpp result = ExtensionModule::GetInstance()-&gt;ActivatePipeline() OnSubmitRequestToSession() ProcessFeatureMessage() ProcessMessageCb() //通过回调又重新回到 chifeature2wrapper.cpp result = pFeature2Wrapper-&gt;m_pUsecaseBase-&gt;SubmitRequest(&amp;submitRequest); //将 request 下到 camx session 中 CHI feature 通过 usecase 提交 request 到 session, 套路还是一样的（chxextensionmodule.cpp 通过这条链路转到Camx） 12result = pSession-&gt;ProcessCaptureRequest(pRequest); //camxchicontext.cpp feature submit request 会调到这里从这里开始步入 session CamxResult Session::ProcessCaptureRequest(); //camxsession.cpp","tags":[]},{"title":"高通 Camx config stream 代码流程","date":"2019-12-31T16:00:04.000Z","path":"2020/01/01/技术研发/Camera Driver/高通 Camx/高通 Camx config stream 代码流程/","text":"","tags":[]},{"title":"Arch Linux 开发环境的搭建","date":"2019-12-31T16:00:03.000Z","path":"2020/01/01/计算机基础知识/Arch Linux 开发环境的搭建/","text":"Arch Linux 系统安装主要进行分区，系统的安装，图形服务和必要驱动的安装 分区 查看当前分区信息 1fdisk -l 设置分区 1cfdisk /dev/sda 1)首先选择分区类型 ​ MBR 选择 dos ​ GPT 选择 gpt 2)MBR启动一般分为2个分区 ​ 主分区 （选择为boot标志） ​ 交换分区（内存的2倍） 格式化分区 格式化主分区 1mkfs.ext4 /dev/sda1 格式化交换分区 1mkswap /dev/sda2 启动交换分区 1swapon /dev/sda2 挂载分区 1mount /dev/sda1 /mnt 编辑镜像源1vim /etc/pacman.d/mirrorlist 将中国的源放在文件的开头 安装系统基本组件1pacstrap /mnt base linux linux-firmware 安装基本开发工具包12arch-chroot /mntpacman -S base-devel 安装 sudo123arch-chroot /mntpacman -S sudo vi vimvisudo 删除这一行注释 %wheel ALL = (ALL) ALL 创建用户123arch-chroot /mntuseradd -G wheel -m 用户名passwad 用户名 安装 Grub1234arch-chroot /mntpacman -S grubgrub-install --target=i386-pc /dev/sdagrub-mkconfig -o /boot/grub/grub.cfg 生成 fstab该配置不需要 arch-chroot 1genfstab /mnt &gt; /mnt/etc/fstab 安装 Xorg 图形管理1pacstrap /mnt xorg-server xorg-xinit xorg-apps 安装网络组件12345pacstrap /mnt dhcpcd wpa_supplicant networkmanagerarch-chroot /mntsystemctl enable dhcpcdsystemctl enable wpa_supplicantsystemctl enable networkmanager 安装显卡驱动12lspci | grep VGA //查看显卡是什么型号pacman -S xf86-video-intel //intel 显卡驱动 安装音频组件12pacstrap /mnt alsa-utils pulseaudiopacstrap /mnt pulseaudio-alsa Arch Linux 桌面环境安装窗口管理器 dwm 安装终端内置浏览器 w3m 1sudo pacman -S w3m 下载 dwm 1w3m suckless.org 安装 1sudo make clean install 运行dwm 12vim ~/.xinitrcstartx 在 .xinitrc 中 加入 exec dwm 窗口管理器 i3 Arch Linux 基础配置安装中文字体 12sudo pacman -S noto-fonts noto-fonts-cjk noto-fonts-emojisudo vim /etc/locale.gen 取消 /etc/locale.gen 中 以下 的注释 en_US.UTF-8 UTF-8 zh_CN.UTF-8 UTF-8 zh_TW.UTF-8 UTF-8 生成 locale 1sudo locale-gen 设置 archlinuxcn123sudo vim /etc/pacman.confsudo pacman -Sysudo pacman -S archlinuxcn-keyring 在文件的末尾插入 [archlinuxcn] Server = https://mirrors.ustc.edu.cn/archlinuxcn/$arch 安装 Chrome1sudo pacman -S google-chrome 安装中文输入法 安装输入法以及配置工具 1sudo pacman -S fcitx fcitx-im kcm-fcitx fcitx-qt5 fcitx-gtk2 fcitx-gtk3 fcitx-configtool 配置输入法 1vim ~/.xprofile 输入以下内容 export GTK_IM_MODULE=fcitxexport QT_IM_MODULE=fcitxexport XMODIFIERS=”@im=fcitx” SSH 的安装与配置 安装ssh 1pacman -Sy openssh 生成密钥 1ssh-keygen -t rsa -C &quot;xxxxx@xxxxx.com&quot; 通过 SSH 远程连接问题 1vim /etc/ssh/sshd_config 在文件的末尾加以下配置 LoginGraceTime 120PermitRootLogin yesStrictModes yes","tags":[{"name":"Arch Linux","slug":"Arch-Linux","permalink":"https://zh-wiki.github.io/tags/Arch-Linux/"}]},{"title":"高通 Camx Camx open camera","date":"2019-12-31T16:00:03.000Z","path":"2020/01/01/技术研发/Camera Driver/高通 Camx/高通 Camx open camera/","text":"Open Camera 的流程简介当用户打开了相机设备之后，便会发生如下过程： APP调用CameraManager的openCamera方法，层层调用之后最终调用到Camera Service层中的CameraService::connectDevice方法 然后通过ICameraDevice::open()这一个HIDL接口通知Camera Provider层 在Camera Provider层内部又通过调用之前获取的camera_module_t中methods的open方法来获取一个Camera 设备，对应于HAL中的camera3_device_t结构体 在Camera Provider层调用获取到的camera3_device_t的initialize方法进行初始化动作 代码大概流程走向 12345678910//APP 端 open CameraCameraManager::openCamera() //Camera Server CameraService::connectDevice() //通过HIDL接口 ICameraDevice::open() //camera provider camera_module_t::methods::open() //接下来就是进行一些初始化操作 camera3_device_t::initialize() APP Open Camera 流程123456789101112131415161718192021//apk端获取CameraManager 服务mCamManager = (CameraManager)getSystemService(Context.CAMERA_SERVICE); //打开指定camera--&gt; mCamManager.openCamera(mCameraId, mStateCallback, null); //frameworks/base/core/java/android/hardware/camera2/CameraManager.javapublic void openCamera(@NonNull String cameraId, @NonNull @CallbackExecutor Executor executor, @NonNull final CameraDevice.StateCallback callback) |--&gt; openCameraForUid(cameraId, callback, executor, USE_CALLING_UID) | |--&gt; openCameraDeviceUserAsync(cameraId, callback, executor, clientUid); | | |--&gt; CameraDevice device = null; //初始化CameraDevice | | | //实例化 new android.hardware.camera2.impl.CameraDeviceImpl | | |--&gt; android.hardware.camera2.impl.CameraDeviceImpl deviceImpl = new android.hardware.camera2.impl.CameraDeviceImpl(...) | | |--&gt; ICameraDeviceCallbacks callbacks = deviceImpl.getCallbacks(); //获取回调 | | |--&gt; ICameraService cameraService = CameraManagerGlobal.get().getCameraService(); //获取CameraService 服务 | | |--&gt; cameraUser = cameraService.connectDevice(callbacks, cameraId, mContext.getOpPackageName(), uid); //连接打开camera | | |--&gt; goto CONNECTDEVICE: //跳转到下面CONNECTDEVICE处进行分析 | | |--&gt; deviceImpl.setRemoteDevice(cameraUser); | | | |--&gt; mRemoteDevice = new ICameraDeviceUserWrapper(remoteDevice); | | | |--&gt; mDeviceExecutor.execute(mCallOnOpened); //这里是一个线程池 | | | | |--&gt; sessionCallback = mSessionStateCallback; //获取session cb | | | | |--&gt; sessionCallback.onOpened(CameraDeviceImpl.this); //通过session cb 返回device | | | | |--&gt; mDeviceCallback.onOpened(CameraDeviceImpl.this); //通过device cb 返回device,这里就是返回给apk端的CameraDevice了 App端主要做了以下几点工作 获取 CameraManager 服务 打开指定的 Camera 获取 Camera Server 调用 cameraService.connectDevice() 去连接打开设备，并且将上层传下来的回调传入Camera Server 返回Device给App端 Camera Server Open 流程对于打开相机设备动作,主要由connectDevice来实现，当CameraFramework通过调用ICameraService的connectDevice接口的时候,主要做了两件事情： 创建CameraDeviceClient。 对CameraDeviceClient进行初始化,并将其给Framework。 创建 CameraDevcieClient CameraDeviceClient 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260class CameraDeviceClient : public Camera2ClientBase&lt;CameraDeviceClientBase&gt;, public camera2::FrameProcessorBase::FilteredListener&#123;public: /** * ICameraDeviceUser interface (see ICameraDeviceUser for details) */ // Note that the callee gets a copy of the metadata. virtual binder::Status submitRequest( const hardware::camera2::CaptureRequest&amp; request, bool streaming = false, /*out*/ hardware::camera2::utils::SubmitInfo *submitInfo = nullptr) override; // List of requests are copied. virtual binder::Status submitRequestList( const std::vector&lt;hardware::camera2::CaptureRequest&gt;&amp; requests, bool streaming = false, /*out*/ hardware::camera2::utils::SubmitInfo *submitInfo = nullptr) override; virtual binder::Status cancelRequest(int requestId, /*out*/ int64_t* lastFrameNumber = NULL) override; virtual binder::Status beginConfigure() override; virtual binder::Status endConfigure(int operatingMode, const hardware::camera2::impl::CameraMetadataNative&amp; sessionParams) override; // Verify specific session configuration. virtual binder::Status isSessionConfigurationSupported( const SessionConfiguration&amp; sessionConfiguration, /*out*/ bool* streamStatus) override; // Returns -EBUSY if device is not idle or in error state virtual binder::Status deleteStream(int streamId) override; virtual binder::Status createStream( const hardware::camera2::params::OutputConfiguration &amp;outputConfiguration, /*out*/ int32_t* newStreamId = NULL) override; // Create an input stream of width, height, and format. virtual binder::Status createInputStream(int width, int height, int format, /*out*/ int32_t* newStreamId = NULL) override; // Get the buffer producer of the input stream virtual binder::Status getInputSurface( /*out*/ view::Surface *inputSurface) override; // Create a request object from a template. virtual binder::Status createDefaultRequest(int templateId, /*out*/ hardware::camera2::impl::CameraMetadataNative* request) override; // Get the static metadata for the camera // -- Caller owns the newly allocated metadata virtual binder::Status getCameraInfo( /*out*/ hardware::camera2::impl::CameraMetadataNative* cameraCharacteristics) override; // Wait until all the submitted requests have finished processing virtual binder::Status waitUntilIdle() override; // Flush all active and pending requests as fast as possible virtual binder::Status flush( /*out*/ int64_t* lastFrameNumber = NULL) override; // Prepare stream by preallocating its buffers virtual binder::Status prepare(int32_t streamId) override; // Tear down stream resources by freeing its unused buffers virtual binder::Status tearDown(int32_t streamId) override; // Prepare stream by preallocating up to maxCount of its buffers virtual binder::Status prepare2(int32_t maxCount, int32_t streamId) override; // Update an output configuration virtual binder::Status updateOutputConfiguration(int streamId, const hardware::camera2::params::OutputConfiguration &amp;outputConfiguration) override; // Finalize the output configurations with surfaces not added before. virtual binder::Status finalizeOutputConfigurations(int32_t streamId, const hardware::camera2::params::OutputConfiguration &amp;outputConfiguration) override; /** * Interface used by CameraService */ CameraDeviceClient(const sp&lt;CameraService&gt;&amp; cameraService, const sp&lt;hardware::camera2::ICameraDeviceCallbacks&gt;&amp; remoteCallback, const String16&amp; clientPackageName, const String8&amp; cameraId, int cameraFacing, int clientPid, uid_t clientUid, int servicePid); virtual ~CameraDeviceClient(); virtual status_t initialize(sp&lt;CameraProviderManager&gt; manager, const String8&amp; monitorTags) override; virtual status_t dump(int fd, const Vector&lt;String16&gt;&amp; args); virtual status_t dumpClient(int fd, const Vector&lt;String16&gt;&amp; args); /** * Device listener interface */ virtual void notifyIdle(); virtual void notifyError(int32_t errorCode, const CaptureResultExtras&amp; resultExtras); virtual void notifyShutter(const CaptureResultExtras&amp; resultExtras, nsecs_t timestamp); virtual void notifyPrepared(int streamId); virtual void notifyRequestQueueEmpty(); virtual void notifyRepeatingRequestError(long lastFrameNumber); /** * Interface used by independent components of CameraDeviceClient. */protected: /** FilteredListener implementation **/ virtual void onResultAvailable(const CaptureResult&amp; result); virtual void detachDevice(); // Calculate the ANativeWindow transform from android.sensor.orientation status_t getRotationTransformLocked(/*out*/int32_t* transform);private: // StreamSurfaceId encapsulates streamId + surfaceId for a particular surface. // streamId specifies the index of the stream the surface belongs to, and the // surfaceId specifies the index of the surface within the stream. (one stream // could contain multiple surfaces.) class StreamSurfaceId final &#123; public: StreamSurfaceId() &#123; mStreamId = -1; mSurfaceId = -1; &#125; StreamSurfaceId(int32_t streamId, int32_t surfaceId) &#123; mStreamId = streamId; mSurfaceId = surfaceId; &#125; int32_t streamId() const &#123; return mStreamId; &#125; int32_t surfaceId() const &#123; return mSurfaceId; &#125; private: int32_t mStreamId; int32_t mSurfaceId; &#125;; // class StreamSurfaceIdprivate: /** ICameraDeviceUser interface-related private members */ /** Preview callback related members */ sp&lt;camera2::FrameProcessorBase&gt; mFrameProcessor; static const int32_t FRAME_PROCESSOR_LISTENER_MIN_ID = 0; static const int32_t FRAME_PROCESSOR_LISTENER_MAX_ID = 0x7fffffffL; std::vector&lt;int32_t&gt; mSupportedPhysicalRequestKeys; template&lt;typename TProviderPtr&gt; status_t initializeImpl(TProviderPtr providerPtr, const String8&amp; monitorTags); /** Utility members */ binder::Status checkPidStatus(const char* checkLocation); binder::Status checkOperatingModeLocked(int operatingMode) const; binder::Status checkPhysicalCameraIdLocked(String8 physicalCameraId); binder::Status checkSurfaceTypeLocked(size_t numBufferProducers, bool deferredConsumer, int surfaceType) const; static void mapStreamInfo(const OutputStreamInfo &amp;streamInfo, camera3_stream_rotation_t rotation, String8 physicalId, hardware::camera::device::V3_4::Stream *stream /*out*/); bool enforceRequestPermissions(CameraMetadata&amp; metadata); // Find the square of the euclidean distance between two points static int64_t euclidDistSquare(int32_t x0, int32_t y0, int32_t x1, int32_t y1); // Create an output stream with surface deferred for future. binder::Status createDeferredSurfaceStreamLocked( const hardware::camera2::params::OutputConfiguration &amp;outputConfiguration, bool isShared, int* newStreamId = NULL); // Set the stream transform flags to automatically rotate the camera stream for preview use // cases. binder::Status setStreamTransformLocked(int streamId); // Find the closest dimensions for a given format in available stream configurations with // a width &lt;= ROUNDING_WIDTH_CAP static const int32_t ROUNDING_WIDTH_CAP = 1920; static bool roundBufferDimensionNearest(int32_t width, int32_t height, int32_t format, android_dataspace dataSpace, const CameraMetadata&amp; info, /*out*/int32_t* outWidth, /*out*/int32_t* outHeight); //check if format is not custom format static bool isPublicFormat(int32_t format); // Create a Surface from an IGraphicBufferProducer. Returns error if // IGraphicBufferProducer&#x27;s property doesn&#x27;t match with streamInfo binder::Status createSurfaceFromGbp(OutputStreamInfo&amp; streamInfo, bool isStreamInfoValid, sp&lt;Surface&gt;&amp; surface, const sp&lt;IGraphicBufferProducer&gt;&amp; gbp, const String8&amp; physicalCameraId); // Utility method to insert the surface into SurfaceMap binder::Status insertGbpLocked(const sp&lt;IGraphicBufferProducer&gt;&amp; gbp, /*out*/SurfaceMap* surfaceMap, /*out*/Vector&lt;int32_t&gt;* streamIds, /*out*/int32_t* currentStreamId); // Check that the physicalCameraId passed in is spported by the camera // device. bool checkPhysicalCameraId(const String8&amp; physicalCameraId); // IGraphicsBufferProducer binder -&gt; Stream ID + Surface ID for output streams KeyedVector&lt;sp&lt;IBinder&gt;, StreamSurfaceId&gt; mStreamMap; // Stream ID -&gt; OutputConfiguration. Used for looking up Surface by stream/surface index KeyedVector&lt;int32_t, hardware::camera2::params::OutputConfiguration&gt; mConfiguredOutputs; struct InputStreamConfiguration &#123; bool configured; int32_t width; int32_t height; int32_t format; int32_t id; &#125; mInputStream; // Streaming request ID int32_t mStreamingRequestId; Mutex mStreamingRequestIdLock; static const int32_t REQUEST_ID_NONE = -1; int32_t mRequestIdCounter; bool mPrivilegedClient; // The list of output streams whose surfaces are deferred. We have to track them separately // as there are no surfaces available and can not be put into mStreamMap. Once the deferred // Surface is configured, the stream id will be moved to mStreamMap. Vector&lt;int32_t&gt; mDeferredStreams; // stream ID -&gt; outputStreamInfo mapping std::unordered_map&lt;int32_t, OutputStreamInfo&gt; mStreamInfoMap; KeyedVector&lt;sp&lt;IBinder&gt;, sp&lt;CompositeStream&gt;&gt; mCompositeStreamMap; static const int32_t MAX_SURFACES_PER_STREAM = 4; sp&lt;CameraProviderManager&gt; mProviderManager;&#125;; CameraDeviceClient 该类在打开设备的时候被实例化，一次打开设备的操作对应一个该类对象，它实现了ICameraDeviceUser接口，以AIDL方式暴露接口给Camera Framework进行调用，于此同时,该类在打开设备的过程中，获取了来自Camera Framework对于ICameraDeviceCallback接口的实现代理，通过该代理可以将结果上传至Camera Framewor中。 123456789//frameworks/av/services/camera/libcameraservice/CameraService.cppStatus CameraService::connectDevice(const sp&lt;hardware::camera2::ICameraDeviceCallbacks&gt;&amp; cameraCb, const String16&amp; cameraId, const String16&amp; clientPackageName, int clientUid, sp&lt;hardware::camera2::ICameraDeviceUser&gt;* device) //最后一个参数是返回值 |--&gt; connectHelper&lt;hardware::camera2::ICameraDeviceCallbacks,CameraDeviceClient&gt;(...) //模板，CALLBACK 为hardware::camera2::ICameraDeviceCallbacks， CLIENT： CameraDeviceClient | |--&gt; validateConnectLocked(...) //关于一些权限的判断，如果没有权限或者非法访问这里会直接退出 | |--&gt; int deviceVersion = getDeviceVersion(cameraId, /*out*/&amp;facing) //获取device version, 为之后的实例化哪一个client 做准备 | |--&gt; makeClient(..., deviceVersion, effectiveApiLevel, ...) //这里主要是这两个参数决定了实例化哪一个client， | |--&gt; *client = new CameraDeviceClient(cameraService, tmp, packageName, cameraId,facing, clientPid, clientUid, servicePid) //这里是实例化了CameraDeviceClient | |--&gt; client = static_cast&lt;CLIENT*&gt;(tmp.get()); //取得makeClient中实例化好的client | |--&gt; client-&gt;initialize(mCameraProviderManager, mMonitorTags); //开始初始化 初始化 CameraDevcieClient","tags":[]},{"title":"Centos 开发环境的搭建","date":"2019-12-31T16:00:02.000Z","path":"2020/01/01/计算机基础知识/Centos 开发环境的搭建/","text":"同一网段外部浏览器不能访问Tomcat 问题产生背景和原因 背景：服务器已经安装好tomcat, 服务器主机通过 ip+8080 的方式可以进行访问, 但是其他在同一网段下的客户端机器通过同样方式不能访问. 原因：服务器未将 8080 端口进行开放 解决方法 1)查看防火墙状态 1firewall-cmd --state 2)添加需要开放的端口 1firewall-cmd --permanent --zone=public --add-port=8080/tcp 3)加载配置使其生效 1firewall-cmd --reload 4)查看配置是否生效 1firewall-cmd --permanent --zone=public --list-ports 5)重新访问 Tomcat (IP+8080) 防火墙的相关操作 开启防火墙的命令 1systemctl start firewalld.service 关闭防火墙的命令 1systemctl stop firewalld.service 开机自动启动 1systemctl enable firewalld.service 关闭开机自动启动 1systemctl disable firewalld.service 查看防火墙状态 1systemctl status firewalld","tags":[{"name":"Centos","slug":"Centos","permalink":"https://zh-wiki.github.io/tags/Centos/"}]},{"title":"Repo 常用命令","date":"2019-12-31T16:00:02.000Z","path":"2020/01/01/技术研发/Linux 命令/Repo 常用指令/","text":"repo 拉下来的代码如何新建分支 repo start xxx(分支名) –all repo sync 的时候如果有本地未提交的修改 repo forall -cv “git reset HEAD –hard; git clean -df “ -j32","tags":[]},{"title":"高通 Camx init 流程","date":"2019-12-31T16:00:02.000Z","path":"2020/01/01/技术研发/Camera Driver/高通 Camx/高通 Camx init 流程/","text":"概览Camx-CHI 整体框架如下 其中 camx 代表了通用功能性接口的代码实现集合，chi-cdk代表了可定制化需求的代码实现集合，从图中不难看出camx部分对上作为HAL3接口的实现,对下通过v4l2框架与Kernel保持通讯,中间通过互相dlopen so库并获取对方操作接口的方式保持着与CHI的交互。 camx/中有如下几个主要目录: core/ : 用于存放camx的核心实现模块,其中还包含了主要用于实现hal3接口的hal/目录,以及负责与CHI进行交互的chi/目录 csl/: 用于存放主要负责camx与camera driver的通讯模块,为camx提供了统一的Camera driver控制接口 hwl/: 用于存放自身具有独立运算能力的硬件node,该部分node受csl管理 swl/: 用于存放自身并不具有独立运算能力,必须依靠CPU才能实现的node chi-cdk/中有如下几个主要目录: chioverride/: 用于存放CHI实现的核心模块,负责与camx进行交互并且实现了CHI的总体框架以及具体的业务处理。 bin/: 用于存放平台相关的配置项 topology/: 用于存放用户自定的Usecase xml配置文件 node/: 用于存放用户自定义功能的node module/: 用于存放不同sensor的配置文件,该部分在初始化sensor的时候需要用到 tuning/: 用于存放不同场景下的效果参数的配置文件 sensor/: 用于存放不同sensor的自有信息以及寄存器配置参数 actuator/: 用于存放不同对焦模块的配置信息 ois/: 用于存放防抖模块的配置信息 flash/: 存放着闪光灯模块的配置信息 eeprom/: 存放着eeprom外部存储模块的配置信息 fd/: 存放了人脸识别模块的配置信息 Camx Init 总体概览通过分析 Camera Provider ，已经知道了上层是如何调到底层的Camera Init 流程，大概框架如下 接下来我们将按照模块化分析camx的内部初始化流程","tags":[]},{"title":"Hexo 博客搭建","date":"2019-12-31T16:00:01.000Z","path":"2020/01/01/计算机基础知识/Hexo 博客搭建/","text":"安装 Hexo1sudo npm install --unsafe-perm --verbose -g hexo 同步本地图片与网络图片 安装插件 1npm install https://github.com/CodeFalling/hexo-asset-image --save 配置Typora 编译 有以下log说明配置成功","tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://zh-wiki.github.io/tags/Hexo/"}]},{"title":"Git 常用命令","date":"2019-12-31T16:00:01.000Z","path":"2020/01/01/技术研发/Linux 命令/Git 常用命令/","text":"撤销指令 撤销工作区的修改 git checkout 文件名 git checkout 目录 -f 从暂存区撤销到工作区（可以理解为git add的反向动作） git reset HEAD 从版本库撤销到暂存区 git reset –soft HEAD^ 从版本库撤销到工作区 git reset –mixed HEAD^ 撤销到上一次提交（本地修改丢失） git reset –hard HEAD^ 保存恢复指令 保存本地未追踪的修改 git stash save 路径 将保存的内容导出 git stash pop stash@{index} 获取保存列表 git stash list 解决冲突这里我分为两种情况： 代码提到服务器上。 a. 首先把自己的提交reset掉。 b.更新代码 c.将自己的代码从服务器上拉下来。 d.冲突用code工具解决掉。然后add 修改文件，重新commit 代码在本地提交 a.将本地提交撤回到工作区。 b.保存本地修改 c.更新代码 d.将保存的代码还原。 e.冲突用code工具解决掉。然后add 修改文件，重新commit","tags":[]},{"title":"高通 Camx camera provider","date":"2019-12-31T16:00:01.000Z","path":"2020/01/01/技术研发/Camera Driver/高通 Camx/高通 Camx camera provider/","text":"概览 通过图片可以看出Camera Provider 分为两部分 通过 HIDL 与Camera Service 跨进程通信 通过 dlopen 方式加载一系列动态库 （Camera HAL3结构的so），在高通Camera 是指 camx-chi 架构 camera provider 和 camera hal3 的联系HAL硬件抽象层(Hardware Abstraction Layer),是谷歌开发的用于屏蔽底层硬件抽象出来的一个软件层，该层定义了自己的一套通用标准接口,平台厂商务必按照以下规则定义自己的Module 每一个硬件都通过hw_module_t来描述,具有固定的名字HMI 每一个硬件都必须实现hw_module_t里面的open方法,用于打开硬件设备,并返回对应的操作接口集合 硬件的操作接口集合使用hw_device_t 来描述,并可以通过自定义一个更大的包含hw_device_t的结构体来拓展硬件操作集合 HAL3 结构体介绍 hw_module_t 1234567891011121314151617typedef struct hw_module_t &#123; uint32_t tag; uint16_t module_api_version;#define version_major module_api_version uint16_t hal_api_version;#define version_minor hal_api_version const char *id; const char *name; const char *author; struct hw_module_methods_t* methods; void* dso;#ifdef __LP64__ uint64_t reserved[32-7];#else uint32_t reserved[32-7];#endif&#125; hw_module_t; hw_module_methods_t 12345typedef struct hw_module_methods_t &#123; /** Open a specific device */ int (*open)(const struct hw_module_t* module, const char* id, struct hw_device_t** device);&#125; hw_module_methods_t; hw_device_t 12345678910111213typedef struct hw_device_t &#123; uint32_t tag; uint32_t version; struct hw_module_t* module;#ifdef __LP64__ uint64_t reserved[12];#else uint32_t reserved[12];#endif int (*close)(struct hw_device_t* device); &#125; hw_device_t; 从上面的定义可以看出 hw_module_t 代表了模块，通过其open方法用来打开一个设备 设备是用hw_device_t来表示，其中除了用来关闭设备的close方法外,并无其它方法 由此可见谷歌定义的HAL接口,并不能满足绝大部分HAL模块的需要,所以谷歌想出了一个比较好的解决方式,那便是将这两个基本结构嵌入到更大的结构体内部,同时在更大的结构内部定义了各自模块特有的方法,用于实现模块的功能,这样,一来对上保持了HAL的统一规范,二来也扩展了模块的功能 高通 camx HAL3 结构体 camera_module_t 123456789101112131415typedef struct camera_module &#123; hw_module_t common; int (*get_number_of_cameras)(void); int (*get_camera_info)(int camera_id, struct camera_info *info); int (*set_callbacks)(const camera_module_callbacks_t *callbacks); void (*get_vendor_tag_ops)(vendor_tag_ops_t* ops); int (*open_legacy)(const struct hw_module_t* module, const char* id, uint32_t halVersion, struct hw_device_t** device); int (*set_torch_mode)(const char* camera_id, bool enabled); int (*init)(); int (*get_physical_camera_info)(int physical_camera_id, camera_metadata_t **static_metadata); int (*is_stream_combination_supported)(int camera_id, const camera_stream_combination_t *streams); void (*notify_device_state_change)(uint64_t deviceState); int (*get_camera_device_version)(int camera_id, uint32_t *version); void* reserved[1];&#125; camera_module_t; camera3_device_t 12345typedef struct camera3_device &#123; hw_device_t common; camera3_device_ops_t *ops; void *priv;&#125; camera3_device_t; camera_module_t包含了hw_module_t，主要用于表示Camera模块，其中定义了诸如get_number_of_cameras以及set_callbacks等扩展方法 camera3_device_t包含了hw_device_t,主要用来表示Camera设备,其中定义了camera3_device_ops操作方法集合,用来实现正常获取图像数据以及控制Camera的功能 Camera HAL3 的实现1234567891011121314151617181920CAMX_VISIBILITY_PUBLIC camera_module_t HAL_MODULE_INFO_SYM =&#123; .common = &#123; .tag = HARDWARE_MODULE_TAG, .module_api_version = CAMERA_MODULE_API_VERSION_CURRENT, .hal_api_version = HARDWARE_HAL_API_VERSION, .id = CAMERA_HARDWARE_MODULE_ID, .name = &quot;QTI Camera HAL&quot;, .author = &quot;Qualcomm Technologies, Inc.&quot;, .methods = &amp;CamX::g_hwModuleMethods &#125;, .get_number_of_cameras = CamX::get_number_of_cameras, .get_camera_info = CamX::get_camera_info, .set_callbacks = CamX::set_callbacks, .get_vendor_tag_ops = CamX::get_vendor_tag_ops, .open_legacy = NULL, .set_torch_mode = CamX::set_torch_mode, .init = CamX::init&#125;; 没错高通 camx hal3 的入口就是这个，在遵循HAL3规范的前提下，实例化各个接口。Provider 将会调用 hw_get_module() 来获取该入口。 各个接口映射到 camxhal3.cpp 1static Dispatch g_dispatchHAL3(&amp;g_jumpTableHAL3); 123456789101112131415161718192021222324252627JumpTableHAL3 g_jumpTableHAL3 =&#123; open, get_number_of_cameras, get_camera_info, set_callbacks, get_vendor_tag_ops, open_legacy, set_torch_mode, init, get_tag_count, get_all_tags, get_section_name, get_tag_name, get_tag_type, close, initialize, configure_streams, construct_default_request_settings, process_capture_request, dump, flush, camera_device_status_change, torch_mode_status_change, process_capture_result, notify&#125;; Provider init 代码流程 在系统初始化的时候，系统会去运行”&#97;&#110;&#x64;&#x72;&#x6f;&#105;&#100;&#x2e;&#x68;&#x61;&#114;&#100;&#x77;&#x61;&#114;&#x65;&#46;&#99;&#x61;&#109;&#101;&#114;&#x61;&#46;&#112;&#x72;&#111;&#118;&#105;&#100;&#101;&#114;&#x40;&#x32;&#46;&#52;&#45;&#115;&#x65;&#x72;&#118;&#x69;&#x63;&#101;&#x5f;&#x36;&#x34;“程序启动Provider进程，并加入HW Service Manager中接受统一管理。在改过程中实例化一个 LegacyCameraProviderImpl_2_4 对象，通过 hw_get_module 标准方法 获取HAL 模块。这边指的是 camera.qcom.so 。 Camera Provider Init 函数总括123456789101112131415161718192021// hardware/interfaces/camera/provider/2.4/default/LegacyCameraProviderImpl_2_4.cppbool LegacyCameraProviderImpl_2_4::initialize() &#123; camera_module_t *rawModule; //获取 camera.qcom.so 可以理解为和 camxhal3entry.cpp 建立联系 int err = hw_get_module(CAMERA_HARDWARE_MODULE_ID, (const hw_module_t **)&amp;rawModule); //将 camera.qcom.so 获取的句柄保存在 mModule 对象中 ，该函数定义在 CameraModule.cpp mModule = new CameraModule(rawModule); //我们可以跟进去看看 init() 非常明显 实际就是进行 camx 的初始化，camxhal3entry.cpp &#123; CAMX:: init()&#125; //int CameraModule::init() 这个函数将会调用 getNumberOfCameras() //就此 camx-chi 的一系列初始化操作 拉开序幕 err = mModule-&gt;init(); // 设置回调函数，用于接受camx-chi的数据和事件 err = mModule-&gt;setCallbacks(this); mNumberOfLegacyCameras = mModule-&gt;getNumberOfCameras(); return false; // mInitFailed&#125; init 函数结束之后，Camera Provider进程便一直便存在于系统中,监听着来自Camera Service的调用。 Camera Provider Init 分解通过上面的总括可以理解为 Provider 最终目的获取 Camx-Chi 的 setting 以及 HW 资源。然后保存起来返回给上层，供后面使用。 二话不说先上一张大图 get_number_of_cameras 函数介绍这个函数是一切美好的开始，她的最先调用就是上面介绍的provide init 函数的 CameraModule::init() 123456789101112131415//hardware/interfaces/camera/common/1.0/default/CameraModule.cppint CameraModule::init() &#123; ATRACE_CALL(); int res = OK; if (getModuleApiVersion() &gt;= CAMERA_MODULE_API_VERSION_2_4 &amp;&amp; mModule-&gt;init != NULL) &#123; ATRACE_BEGIN(&quot;camera_module-&gt;init&quot;); res = mModule-&gt;init(); ATRACE_END(); &#125; //将会走到 vendor/proprietary/camx/src/coer/hal/camxhal3.cpp中 mNumberOfCameras = getNumberOfCameras(); mCameraInfoMap.setCapacity(mNumberOfCameras); return res;&#125; CameraModule::init() ，这个函数调用 getNumberOfCameras() 。最终调用到 get_number_of_cameras() 这个函数已经是干到camx了。 1234567891011//vendor/proprietary/camx/src/coer/hal/camxhal3.cppstatic int get_number_of_cameras(void)&#123; ...... INT numCameras; //将会走到 vendor/proprietary/camx/src/coer/hal/camxhal3module.cpp中 //会调用到 HAL3Module的构造函数 numCameras = static_cast&lt;int&gt;(HAL3Module::GetInstance()-&gt;GetNumCameras()); ...... return numCameras;&#125; 这个函数主要有两个作用： 是通过 HAL3Module 类的构造函数会获取 CAMX-CHI 的信息 加载 com.qti.chi.override.so 模块，映射 CAMX-CHI 之间的接口 12345678910111213141516//vendor/proprietary/camx/src/coer/hal/camxhal3module.cppHAL3Module::HAL3Module()&#123; CamxResult result = CamxResultSuccess; CSLCameraPlatform CSLPlatform = &#123;&#125;; CAMX_LOG_CONFIG(CamxLogGroupHAL, &quot;***************************************************&quot;); CAMX_LOG_CONFIG(CamxLogGroupHAL, &quot;SHA1: %s&quot;, CAMX_SHA1); CAMX_LOG_CONFIG(CamxLogGroupHAL, &quot;COMMITID: %s&quot;, CAMX_COMMITID); CAMX_LOG_CONFIG(CamxLogGroupHAL, &quot;BUILD TS: %s&quot;, CAMX_BUILD_TS); CAMX_LOG_CONFIG(CamxLogGroupHAL, &quot;***************************************************&quot;); ...... //到了这个位置已经是很亲切了，干到camx了 m_pStaticSettings = HwEnvironment::GetInstance()-&gt;GetStaticSettings(); ......&#125; HwEnvironment::Initialize() 函数介绍通过 HAL3Module 构造函数会调用 HwEnvironment 类的构造，主体功能在 HwEnvironment::Initialize() 中实现 HwEnvironment::Initialize() 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192//vendor/proprietary/camx/src/coer/camxhwenvironment.cppCamxResult HwEnvironment::Initialize()&#123; CamxResult result = CamxResultSuccess; CSLInitializeParams params = &#123; 0 &#125;; SettingsManager* pStaticSettingsManager = SettingsManager::Create(NULL); ExternalComponentInfo* pExternalComponent = GetExternalComponent(); if (NULL != pStaticSettingsManager) &#123; const StaticSettings* pStaticSettings = pStaticSettingsManager-&gt;GetStaticSettings(); if (NULL != pStaticSettings) &#123; params.mode = pStaticSettings-&gt;CSLMode; params.emulatedSensorParams.enableSensorSimulation = pStaticSettings-&gt;enableSensorEmulation; params.emulatedSensorParams.dumpSensorEmulationOutput = pStaticSettings-&gt;dumpSensorEmulationOutput; OsUtils::StrLCpy(params.emulatedSensorParams.sensorEmulatorPath, pStaticSettings-&gt;sensorEmulatorPath, sizeof(pStaticSettings-&gt;sensorEmulatorPath)); OsUtils::StrLCpy(params.emulatedSensorParams.sensorEmulator, pStaticSettings-&gt;sensorEmulator, sizeof(pStaticSettings-&gt;sensorEmulator)); result = CSLInitialize(&amp;params); if (CamxResultSuccess == result) &#123; // Query the camera platform result = QueryHwContextStaticEntryMethods(); &#125; if (CamxResultSuccess == result) &#123; m_pHwFactory = m_staticEntryMethods.CreateHwFactory(); if (NULL == m_pHwFactory) &#123; CAMX_ASSERT_ALWAYS_MESSAGE(&quot;Failed to create the HW factory&quot;); result = CamxResultEFailed; &#125; &#125; if (CamxResultSuccess == result) &#123; m_pSettingsManager = m_pHwFactory-&gt;CreateSettingsManager(); if (NULL == m_pSettingsManager) &#123; CAMX_ASSERT_ALWAYS_MESSAGE(&quot;Failed to create the HW settings manager&quot;); result = CamxResultEFailed; &#125; &#125; if (CamxResultSuccess == result) &#123; m_staticEntryMethods.GetHWBugWorkarounds(&amp;m_workarounds); &#125; &#125; pStaticSettingsManager-&gt;Destroy(); pStaticSettingsManager = NULL; &#125; CAMX_ASSERT(NULL != pExternalComponent); if ((CamxResultSuccess == result) &amp;&amp; (NULL != pExternalComponent)) &#123; result = ProbeChiComponents(pExternalComponent, &amp;m_numExternalComponent); &#125; if (CamxResultSuccess == result) &#123; // Load the OEM sensor capacity customization functions CAMXCustomizeCAMXInterface camxInterface; camxInterface.pGetHWEnvironment = HwEnvironment::GetInstance; CAMXCustomizeEntry(&amp;m_pOEMInterface, &amp;camxInterface); &#125; if (CamxResultSuccess != result) &#123; CAMX_LOG_ERROR(CamxLogGroupCore, &quot;FATAL ERROR: Raise SigAbort. HwEnvironment initialization failed&quot;); m_numberSensors = 0; OsUtils::RaiseSignalAbort(); &#125; else &#123; m_initCapsStatus = InitCapsInitialize; &#125; return result;&#125; 通过上面的代码可以看出 HwEnvironment::Initialize() 做的事情还是挺多的。下面我们开始分析 获取camx的相关配置 SettingsManager* pStaticSettingsManager = SettingsManager::Create(NULL); 经过一系列调用最终会调到以下代码，加载配置参数 123456789101112131415161718192021//vendor/proprietary/camx/src/coer/camxsettingsmanager.cppCamxResult SettingsManager::Initialize( StaticSettings* pStaticSettings)&#123; ...... // Populate the default settings InitializeDefaultSettings(); InitializeDefaultDebugSettings(); // Load the override settings from our override settings stores result = LoadOverrideSettings(m_pOverrideSettingsStore); result = LoadOverrideProperties(m_pOverrideSettingsStore, TRUE); result = ValidateSettings(); DumpSettings(); m_pOverrideSettingsStore-&gt;DumpOverriddenSettings(); ...... UpdateLogSettings(); return result;&#125; 利用加载好的配置参数去初始化相关模块 result = CSLInitialize(&amp;params); 经过一个跳转表格进入以下代码 CamxResult CSLInitializeHW() 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768//vendor/proprietary/camx/src/csl/hw/camxcslhw.cppCamxResult CSLInitializeHW()&#123; CamxResult result = CamxResultEFailed; CHAR syncDeviceName[CSLHwMaxDevName] = &#123;0&#125;; if (FALSE == CSLHwIsHwInstanceValid()) &#123; if (TRUE == CSLHwEnumerateAndAddCSLHwDevice(CSLInternalHwVideodevice, CAM_VNODE_DEVICE_TYPE)) &#123; if (TRUE == CSLHwEnumerateAndAddCSLHwDevice(CSLInternalHwVideoSubdevice, CAM_CPAS_DEVICE_TYPE)) &#123; CAMX_LOG_VERBOSE(CamxLogGroupCSL, &quot;Platform family=%d, version=%d.%d.%d, cpas version=%d.%d.%d&quot;, g_CSLHwInstance.pCameraPlatform.family, g_CSLHwInstance.pCameraPlatform.platformVersion.majorVersion, g_CSLHwInstance.pCameraPlatform.platformVersion.minorVersion, g_CSLHwInstance.pCameraPlatform.platformVersion.revVersion, g_CSLHwInstance.pCameraPlatform.CPASVersion.majorVersion, g_CSLHwInstance.pCameraPlatform.CPASVersion.minorVersion, g_CSLHwInstance.pCameraPlatform.CPASVersion.revVersion); if (FALSE == CSLHwEnumerateAndAddCSLHwDevice(CSLInternalHwVideoSubdeviceAll, 0)) &#123; CAMX_LOG_ERROR(CamxLogGroupCSL, &quot;No KMD devices found&quot;); &#125; else &#123; CAMX_LOG_VERBOSE(CamxLogGroupCSL, &quot;Total KMD subdevices found =%d&quot;, g_CSLHwInstance.kmdDeviceCount); &#125; // Init the memory manager data structures here CamX::Utils::Memset(g_CSLHwInstance.memManager.bufferInfo, 0, sizeof(g_CSLHwInstance.memManager.bufferInfo)); // Init the sync manager here g_CSLHwInstance.lock-&gt;Lock(); g_CSLHwInstance.pSyncFW = CamX::SyncManager::GetInstance(); if (NULL != g_CSLHwInstance.pSyncFW) &#123; CSLHwGetSyncHwDevice(syncDeviceName, CSLHwMaxDevName); CAMX_LOG_VERBOSE(CamxLogGroupCSL, &quot;Sync device found = %s&quot;, syncDeviceName); result = g_CSLHwInstance.pSyncFW-&gt;Initialize(syncDeviceName); if (CamxResultSuccess != result) &#123; CAMX_LOG_ERROR(CamxLogGroupCSL, &quot;CSL failed to initialize SyncFW&quot;); result = g_CSLHwInstance.pSyncFW-&gt;Destroy(); g_CSLHwInstance.pSyncFW = NULL; &#125; &#125; g_CSLHwInstance.lock-&gt;Unlock(); CSLHwInstanceSetState(CSLHwValidState); result = CamxResultSuccess; CAMX_LOG_VERBOSE(CamxLogGroupCSL, &quot;Successfully acquired requestManager&quot;); &#125; else &#123; CAMX_LOG_ERROR(CamxLogGroupCSL, &quot;Failed to acquire CPAS&quot;); &#125; &#125; else &#123; CAMX_LOG_ERROR(CamxLogGroupCSL, &quot;Failed to acquire requestManager invalid&quot;); &#125; &#125; else &#123; CAMX_LOG_ERROR(CamxLogGroupCSL, &quot;CSL in Invalid State&quot;); &#125; return result;&#125; 这一部分我个人理解为，遍历所有kernel端的设备。获取相关接口以及需要的事件。与HAL层建立联系。具体分析以后可以单独写一篇文章分析 根据平台获取对应的入口方法 这个暂时不知道是个什么鬼，先这样理解 result = QueryHwContextStaticEntryMethods(); 经过一系列的调用最终是跑到了这里 12345678910111213141516//vendor/proprietary/camx/src/csl/hwl/titan17x/camxtitan17xhwl.cppCamxResult Titan17xGetStaticEntryMethods( HwContextStaticEntry* pStaticEntry)&#123; CamxResult result = CamxResultSuccess; pStaticEntry-&gt;Create = &amp;Titan17xContext::Create; pStaticEntry-&gt;GetStaticMetadataKeysInfo = &amp;Titan17xContext::GetStaticMetadataKeysInfo; pStaticEntry-&gt;GetStaticCaps = &amp;Titan17xContext::GetStaticCaps; pStaticEntry-&gt;CreateHwFactory = &amp;Titan17xFactory::Create; pStaticEntry-&gt;QueryVendorTagsInfo = &amp;Titan17xContext::QueryVendorTagsInfo; pStaticEntry-&gt;GetHWBugWorkarounds = &amp;Titan17xContext::GetHWBugWorkarounds; pStaticEntry-&gt;QueryExternalComponentVendorTagsInfo = &amp;Titan17xContext::QueryExternalComponentVendorTagsInfo; return result;&#125; 获取CHI各个节点的接口 result = ProbeChiComponents(pExternalComponent, &amp;m_numExternalComponent); 遍历所有chi相关的.so库，将各个接口保存起来。这一块的代码撸的比较少，先记录这么多 到此处 HwEnvironment::Initialize() 这个函数就介绍的差不多了。日后慢慢完善 HwEnvironment::InitCaps() 函数介绍 HwEnvironment::InitCaps() 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//vendor/proprietary/camx/src/coer/camxhwenvironment.cppVOID HwEnvironment::InitCaps()&#123; CamxResult result = CamxResultSuccess; m_pHWEnvLock-&gt;Lock(); if (InitCapsRunning == m_initCapsStatus || InitCapsDone == m_initCapsStatus) &#123; m_pHWEnvLock-&gt;Unlock(); return; &#125; m_initCapsStatus = InitCapsRunning; if (CamxResultSuccess == result) &#123; EnumerateDevices(); ProbeImageSensorModules(); EnumerateSensorDevices(); InitializeSensorSubModules(); InitializeSensorStaticCaps(); result = m_staticEntryMethods.GetStaticCaps(&amp;m_platformCaps[0]); // copy the static capacity to remaining sensor&#x27;s for (UINT index = 1; index &lt; m_numberSensors; index++) &#123; Utils::Memcpy(&amp;m_platformCaps[index], &amp;m_platformCaps[0], sizeof(m_platformCaps[0])); &#125; if (NULL != m_pOEMInterface-&gt;pInitializeExtendedPlatformStaticCaps) &#123; m_pOEMInterface-&gt;pInitializeExtendedPlatformStaticCaps(&amp;m_platformCaps[0], m_numberSensors); &#125; &#125; CAMX_ASSERT(CamxResultSuccess == result); if (CamxResultSuccess == result) &#123; InitializeHwEnvironmentStaticCaps(); &#125; m_initCapsStatus = InitCapsDone; m_pHWEnvLock-&gt;Unlock();&#125; 这一波操作应该就是枚举各个Camera模组，检测硬件是否可以通信成功。 Probe Sensor 经过上述函数中 ProbeImageSensorModules() 会走到 ImageSensorModuleData::Probe() 1234567891011121314151617//vendor/proprietary/camx/src/core/camximagesensormoduledata.cppCamxResult ImageSensorModuleData::Probe( BOOL* pDetected, INT32* pDeviceIndex)&#123; ...... //获取上下电时序 UINT powerUpCmdSize = GetSensorDataObject()-&gt;GetPowerSequenceCmdSize(TRUE); UINT powerDownCmdSize = GetSensorDataObject()-&gt;GetPowerSequenceCmdSize(FALSE); //创建命令包管理 result = CmdBufferManager::Create(&quot;ImageSensorPacketManager&quot;, &amp;packetResourceParams, &amp;pPacketManager); //向CSL下发probe命令 result = CSLImageSensorProbe(pProbePacket-&gt;GetMemHandle(), pProbePacket-&gt;GetOffset(), &amp;probeResult); ......&#125; 该函数的主要作用就是创建probe sensor 的命令包，然后下发到CSL 将命令包提交到 CSL 通过ioctl下发到 Kernel 123456789101112131415//vendor/qcom/proprietary/camx/src/csl/hw/camxcslhwinternalsensor.cppCamxResult CSLHwInternalProbeSensorHW( CSLMemHandle hPacket, SIZE_T offset, INT32* pDeviceIndex)&#123; ...... ioctlCmd.op_code = CAM_SENSOR_PROBE_CMD; ioctlCmd.size = sizeof(ioctlCmd.handle); ioctlCmd.handle_type = CAM_HANDLE_MEM_HANDLE; ioctlCmd.reserved = 0; ioctlCmd.handle = hPacket; result = pLoophw-&gt;deviceOp.Ioctl(pLoophw, VIDIOC_CAM_CONTROL, &amp;ioctlCmd); ......&#125;","tags":[]},{"title":"Ubuntu 开发环境的搭建","date":"2019-12-31T16:00:00.000Z","path":"2020/01/01/计算机基础知识/Ubuntu 开发环境的搭建/","text":"VirtualBox 修复’modprobe vboxdrv’ 报错 问题发生背景 Linux 内核版本升级之后，virtualbox 的驱动没有更新成功。 解决方法 更新整个系统 12sudo apt updatesudo apt upgrade 重新安装对应内核版本的头文件,和virtualbox的驱动 1sudo apt install --reinstall linux-headers-$(uname -r) virtualbox-dkms dkms 加载驱动重启 12sudo modprobe vboxdrvreboot 注意事项 更新驱动的时候，会重新编译驱动，所以要选择对应的gcc编译器，太老的估计会凉。 支持多版本的gcc 系统安装ok后默认gcc 版本是 v-7.x。我们先搞一个低版本的gcc 1234sudo apt-get install gcc-4.8sudo apt-get install g++-4.8sudo ln -sf /usr/bin/g++-4.8 /usr/bin/g++sudo ln -sf /usr/bin/gcc-4.8 /usr/bin/gcc 管理多个版本的gcc 查看存在几个版本的gcc 1ls -l /usr/bin/gcc 分别为gcc和g++添加管理组 12sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-4.8 40sudo update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++-4.8 40 能添加就能删除,从管理组中删除 1sudo update-alternatives --remove gcc /usr/bin/gcc-4.8 设置ok使用以下指令选择gcc的版本 12sudo update-alternatives --config gccsudo update-alternatives --config g++","tags":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://zh-wiki.github.io/tags/Ubuntu/"}]},{"title":"Android 研发总结","date":"2019-12-31T16:00:00.000Z","path":"2020/01/01/技术研发/Android 研发总结/经验总结/","text":"如何编译 selinux 编译命令 1make selinux_policy 生成的文件 path : out/target/product/lime/vendor/etc/selinux 如何将最近指定时间(45min)内生成的文件 push 到 指定 的路径1find . -mmin -45 -type f|grep -v SHARED_LIBRARIES|grep -v STATIC_LIBRARIES|grep -Ei &quot;so|bin&quot;|grep -v symbols|xargs -t -I &#x27;&#123;&#125;&#x27; adb push &#123;&#125; /vendor/lib64/&#123;&#125; 如何在安卓中自定义 log12#include &lt;android/log.h&gt; #define GC02M1B_DBG(fmt, args...) __android_log_print(ANDROID_LOG_ERROR, &quot;GC02M1B&quot;,fmt, ##args) Trace 的使用 systrace.py 的路径 path：项目代码/native/external/chromium-trace 如何打开 trace 的 html 在谷歌浏览器输入 chrome://tracing/","tags":[{"name":"Android","slug":"Android","permalink":"https://zh-wiki.github.io/tags/Android/"}]},{"title":"ADB 常用命令","date":"2019-12-31T16:00:00.000Z","path":"2020/01/01/技术研发/Linux 命令/ADB 常用命令/","text":"通用命令检测usb设备1adb wait-for-usb-device 属性相关123adb shell setprop 属性名adb shell getpropadb shell getprop | grep -i xxx 安装与卸载apk123adb install xxx.apkadb uninstall com.xxx.xxxadb shell pm list packages | grep xxx 设置屏幕1adb shell input keyevent 26 Cam相关指令dump camera的相关信息1adb shell dumpsys media.camera &gt; cam 查看camera个数1watch -n 1 -d &quot;adb shell dumpsys media.camera|grep Number&quot; 打开摄像头1adb shell am start -a android.media.action.STILL_IMAGE_CAMERA 打开前置摄像头1adb shell am start -a android.media.action.IMAGE_CAPTURE --ei android.intent.extras.CAMERA_FACING 1 高通平台 Camera 相关开启高通相机选择camera id1adb shell setprop persist.sys.camera.devoption.debug 100 使能多摄像1adb shell setprop persist.vendor.camera.multicam 1 开启支持多摄的权限123adb shell setprop vendor.camera.aux.packagelist org.codeaurora.snapcamadb shell setprop persist.vendor.camera.privapp.list org.codeaurora.snapcamadb shell setprop vendor.camera.aux.packagelist &quot;org.codeaurora.snapcam,com.huaqin.cameraautotest,com.huaqin.factory&quot; 高通 Camx 杀死 camera 进程1adb shell ps -A|grep camera |awk &#x27;&#123;print $2&#125;&#x27;|xargs adb shell kill -9 命令解释: awk ‘{print $2}’ 这个命令会把 ps -A | grep camera 得出的进程id 输出到终端 （$2 是第二字段也就是 进程id） xargs adb shell kill -9 这个命令会把 awk 获取到的线程id 当做参数传递给 kill -9 这个命令 高通 Camx dump metadata1adb shell dumpsys media.camera &gt;meta.log ADB 常见问题ADB 连接不上报以下错误 解决方法： 12cd /etc/udev/rules.dsudo vim 51-android.rules 在文件中写入：SUBSYSTEM==”usb”, ENV{DEVTYPE}==”usb_device”, MODE=”0666”","tags":[]},{"title":"MarkDown 常用语法","date":"2019-12-31T16:00:00.000Z","path":"2020/01/01/程序语言/MarkDown/MarkDown 常用语法/","text":"MarkDown 插入音频1&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=330 height=86 src=&quot;音频地址&quot;&gt;&lt;/iframe&gt; MarkDown 插入视频1&lt;iframe height=498 width=510 src=&quot;视频地址&quot; frameborder=0 allowfullscreen&gt;&lt;/iframe&gt; 插入代码折叠片段12345678&lt;details&gt;&lt;summary&gt;标签名&lt;/summary&gt;``````&lt;/details&gt;","tags":[{"name":"MarkDown","slug":"MarkDown","permalink":"https://zh-wiki.github.io/tags/MarkDown/"}]},{"title":"高通 Camx camera server","date":"2019-12-31T16:00:00.000Z","path":"2020/01/01/技术研发/Camera Driver/高通 Camx/高通 Camx camera server/","text":"Camera ServerCamera Server 是一个独立的进程，对上通过AIDL来完成 Camera Framework 的一些请求；对下通过HIDL 将上层发下来的请求提交给 Camera Provider。 Camera Server 对 Camera Framework 而言属于 服务端 Camera Server 对 Camera Provider 而言属于 客户端","tags":[]}],"categories":[],"tags":[{"name":"c++","slug":"c","permalink":"https://zh-wiki.github.io/tags/c/"},{"name":"UML","slug":"UML","permalink":"https://zh-wiki.github.io/tags/UML/"},{"name":"Arch Linux","slug":"Arch-Linux","permalink":"https://zh-wiki.github.io/tags/Arch-Linux/"},{"name":"Centos","slug":"Centos","permalink":"https://zh-wiki.github.io/tags/Centos/"},{"name":"Hexo","slug":"Hexo","permalink":"https://zh-wiki.github.io/tags/Hexo/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://zh-wiki.github.io/tags/Ubuntu/"},{"name":"Android","slug":"Android","permalink":"https://zh-wiki.github.io/tags/Android/"},{"name":"MarkDown","slug":"MarkDown","permalink":"https://zh-wiki.github.io/tags/MarkDown/"}]}