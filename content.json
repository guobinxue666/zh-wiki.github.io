{"pages":[{},{},{}],"posts":[{"title":"Welcome Zh-Wiki Site","date":"2020-10-05T08:27:35.037Z","path":"2020/10/05/index/","text":"","tags":[]},{"title":"生活学习","date":"2020-10-04T08:22:36.000Z","path":"2020/10/04/生活学习/生活学习/","text":"","tags":[]},{"title":"艺术","date":"2020-10-04T08:22:36.000Z","path":"2020/10/04/艺术/艺术/","text":"","tags":[]},{"title":"c++","date":"2020-09-29T15:23:24.000Z","path":"2020/09/29/程序语言/C++/c++/","text":"","tags":[{"name":"c++","slug":"c","permalink":"https://zh-wiki.github.io/tags/c/"}]},{"title":"UML","date":"2020-09-29T15:23:24.000Z","path":"2020/09/29/程序语言/UML/UML/","text":"","tags":[{"name":"UML","slug":"UML","permalink":"https://zh-wiki.github.io/tags/UML/"}]},{"title":"高通 Camx 问题总结","date":"2019-12-31T16:01:00.000Z","path":"2020/01/01/技术研发/Camera Driver/高通 Camx/高通 Camx 问题总结/","text":"","tags":[]},{"title":"高通 Camx Bring up","date":"2019-12-31T16:00:30.000Z","path":"2020/01/01/技术研发/Camera Driver/高通 Camx/高通 Camx Bring up/","text":"Dump EEprom Data1adb shell &quot;echo dumpSensorEEPROMData=1 &gt;&gt; /vendor/etc/camera/camxoverridesettings.txt&quot; 数据存放位置： /data/vendor/camera/xxx_kbuffer_OTP.txt","tags":[]},{"title":"高通 Camx capture result 代码流程","date":"2019-12-31T16:00:06.000Z","path":"2020/01/01/技术研发/Camera Driver/高通 Camx/高通 Camx capture result 代码流程/","text":"预览和拍照的 result 代码流程","tags":[]},{"title":"高通 Camx capture request 代码流程","date":"2019-12-31T16:00:05.000Z","path":"2020/01/01/技术研发/Camera Driver/高通 Camx/高通 Camx capture request 代码流程/","text":"预览和拍照的 request 代码流程主体框架图 详细代码调用流程123456789101112chi_override_process_request() //chxextensioninterface.cpp OverrideProcessRequest() //chxextensionmodule.cpp ProcessCaptureRequest()//chxusecase.cpp ExecuteCaptureRequest() //chxadvancedcamerausecase.cpp result = pFeature-&gt;ExecuteProcessRequest(pRequest); //会调到chifeature2wrapper.cpp:494 ExecuteProcessRequest() ExecuteProcessRequest() //chifeature2wrapper.cpp 开始进入算法的领域 SubmitRequestToSession() //经过一系类调用会走到 chifeature2base.cpp result = ExtensionModule::GetInstance()-&gt;ActivatePipeline() OnSubmitRequestToSession() ProcessFeatureMessage() ProcessMessageCb() //通过回调又重新回到 chifeature2wrapper.cpp result = pFeature2Wrapper-&gt;m_pUsecaseBase-&gt;SubmitRequest(&amp;submitRequest); //将 request 下到 camx session 中 CHI feature 通过 usecase 提交 request 到 session, 套路还是一样的（chxextensionmodule.cpp 通过这条链路转到Camx） 12result = pSession-&gt;ProcessCaptureRequest(pRequest); //camxchicontext.cpp feature submit request 会调到这里从这里开始步入 session CamxResult Session::ProcessCaptureRequest(); //camxsession.cpp","tags":[]},{"title":"高通 Camx config stream 代码流程","date":"2019-12-31T16:00:04.000Z","path":"2020/01/01/技术研发/Camera Driver/高通 Camx/高通 Camx config stream 代码流程/","text":"","tags":[]},{"title":"Arch Linux 开发环境的搭建","date":"2019-12-31T16:00:03.000Z","path":"2020/01/01/计算机基础知识/Arch Linux 开发环境的搭建/","text":"Arch Linux 系统安装主要进行分区，系统的安装，图形服务和必要驱动的安装 分区 查看当前分区信息 1fdisk -l 设置分区 1cfdisk /dev/sda 1)首先选择分区类型 ​ MBR 选择 dos ​ GPT 选择 gpt 2)MBR启动一般分为2个分区 ​ 主分区 （选择为boot标志） ​ 交换分区（内存的2倍） 格式化分区 格式化主分区 1mkfs.ext4 /dev/sda1 格式化交换分区 1mkswap /dev/sda2 启动交换分区 1swapon /dev/sda2 挂载分区 1mount /dev/sda1 /mnt 编辑镜像源1vim /etc/pacman.d/mirrorlist 将中国的源放在文件的开头 安装系统基本组件1pacstrap /mnt base linus linux-firmware 安装基本开发工具包12arch-chroot /mntpacman -S base-devel 安装 sudo123arch-chroot /mntpacman -S sudo vi vimvisudo 删除这一行注释 %wheel ALL = (ALL) ALL 创建用户12arch-chroot /mntuseradd -G wheel -m 用户名 安装 Grub1234arch-chroot /mntpacman -S grubgrub-install --target=i386-pc /dev/sdagrub-mkconfig -o /boot/grub/grub.cfg 生成 fstab该配置不需要 arch-chroot 1genfstab /mnt &gt; /mnt/etc/fstab 安装 Xorg 图形管理1pacstrap /mnt xorg-server xorg-xinit xorg-apps 安装网络组件12345pacstrap /mnt dhcpcd wpa_supplicant networkmanagerarch-chroot /mntsystemctl enable dhcpcdsystemctl enable wpa_supplicantsystemctl enable networkmanager 安装显卡驱动12lspci | grep VGA //查看显卡是什么型号pacman -S xf86-video-intel //intel 显卡驱动 安装音频组件12pacstrap /mnt alsa-utils pulseaudiopacstrap /mnt pulseaudio-alsa Arch Linux 桌面环境安装窗口管理器 dwm 安装终端内置浏览器 w3m 1sudo pacman -S w3m 下载 dwm 1w3m suckless.org 安装 1sudo make clean install 运行dwm 12vim ~/.xinitrcstartx 在 .xinitrc 中 加入 exec dwm 窗口管理器 i3 Arch Linux 基础配置安装中文字体 12sudo pacman -S noto-fonts noto-fonts-cjk noto-fonts-emojisudo vim /etc/locale.gen 取消 /etc/locale.gen 中 以下 的注释 en_US.UTF-8 UTF-8 zh_CN.UTF-8 UTF-8 zh_TW.UTF-8 UTF-8 生成 locale 1sudo locale-gen 设置 archlinuxcn123sudo vim /etc/pacman.confsudo pacman -Sysudo pacman -S archlinuxcn-keyring 在文件的末尾插入 [archlinuxcn] Server = https://mirrors.ustc.edu.cn/archlinuxcn/$arch 安装 Chrome1sudo pacman -S google-chrome 安装中文输入法 安装输入法以及配置工具 1sudo pacman -S fcitx fcitx-im kcm-fcitx fcitx-qt5 fcitx-gtk2 fcitx-gtk3 fcitx-configtool 配置输入法 1vim ~/.xprofile 输入以下内容 export GTK_IM_MODULE=fcitxexport QT_IM_MODULE=fcitxexport XMODIFIERS=”@im=fcitx” SSH 的安装与配置 安装ssh 1pacman -Sy openssh 生成密钥 1ssh-keygen -t rsa -C &quot;xxxxx@xxxxx.com&quot; 通过 SSH 远程连接问题 1vim /etc/ssh/sshd_config 在文件的末尾加以下配置 LoginGraceTime 120PermitRootLogin yesStrictModes yes","tags":[{"name":"Arch Linux","slug":"Arch-Linux","permalink":"https://zh-wiki.github.io/tags/Arch-Linux/"}]},{"title":"高通 Camx Camx open camera","date":"2019-12-31T16:00:03.000Z","path":"2020/01/01/技术研发/Camera Driver/高通 Camx/高通 Camx open camera/","text":"","tags":[]},{"title":"Centos 开发环境的搭建","date":"2019-12-31T16:00:02.000Z","path":"2020/01/01/计算机基础知识/Centos 开发环境的搭建/","text":"同一网段外部浏览器不能访问Tomcat 问题产生背景和原因 背景：服务器已经安装好tomcat, 服务器主机通过 ip+8080 的方式可以进行访问, 但是其他在同一网段下的客户端机器通过同样方式不能访问. 原因：服务器未将 8080 端口进行开放 解决方法 1)查看防火墙状态 1firewall-cmd --state 2)添加需要开放的端口 1firewall-cmd --permanent --zone=public --add-port=8080/tcp 3)加载配置使其生效 1firewall-cmd --reload 4)查看配置是否生效 1firewall-cmd --permanent --zone=public --list-ports 5)重新访问 Tomcat (IP+8080) 防火墙的相关操作 开启防火墙的命令 1systemctl start firewalld.service 关闭防火墙的命令 1systemctl stop firewalld.service 开机自动启动 1systemctl enable firewalld.service 关闭开机自动启动 1systemctl disable firewalld.service 查看防火墙状态 1systemctl status firewalld","tags":[{"name":"Centos","slug":"Centos","permalink":"https://zh-wiki.github.io/tags/Centos/"}]},{"title":"Repo 常用命令","date":"2019-12-31T16:00:02.000Z","path":"2020/01/01/技术研发/Linux 命令/Repo 常用指令/","text":"repo 拉下来的代码如何新建分支 repo start xxx(分支名) –all repo sync 的时候如果有本地未提交的修改 repo forall -cv “git reset HEAD –hard; git clean -df “ -j32","tags":[]},{"title":"高通 Camx init 流程","date":"2019-12-31T16:00:02.000Z","path":"2020/01/01/技术研发/Camera Driver/高通 Camx/高通 Camx init 流程/","text":"概览Camx-CHI 整体框架如下 其中 camx 代表了通用功能性接口的代码实现集合，chi-cdk代表了可定制化需求的代码实现集合，从图中不难看出camx部分对上作为HAL3接口的实现,对下通过v4l2框架与Kernel保持通讯,中间通过互相dlopen so库并获取对方操作接口的方式保持着与CHI的交互。 camx/中有如下几个主要目录: core/ : 用于存放camx的核心实现模块,其中还包含了主要用于实现hal3接口的hal/目录,以及负责与CHI进行交互的chi/目录 csl/: 用于存放主要负责camx与camera driver的通讯模块,为camx提供了统一的Camera driver控制接口 hwl/: 用于存放自身具有独立运算能力的硬件node,该部分node受csl管理 swl/: 用于存放自身并不具有独立运算能力,必须依靠CPU才能实现的node chi-cdk/中有如下几个主要目录: chioverride/: 用于存放CHI实现的核心模块,负责与camx进行交互并且实现了CHI的总体框架以及具体的业务处理。 bin/: 用于存放平台相关的配置项 topology/: 用于存放用户自定的Usecase xml配置文件 node/: 用于存放用户自定义功能的node module/: 用于存放不同sensor的配置文件,该部分在初始化sensor的时候需要用到 tuning/: 用于存放不同场景下的效果参数的配置文件 sensor/: 用于存放不同sensor的自有信息以及寄存器配置参数 actuator/: 用于存放不同对焦模块的配置信息 ois/: 用于存放防抖模块的配置信息 flash/: 存放着闪光灯模块的配置信息 eeprom/: 存放着eeprom外部存储模块的配置信息 fd/: 存放了人脸识别模块的配置信息 Camx Init 总体概览通过分析 Camera Provider ，已经知道了上层是如何调到底层的Camera Init 流程，大概框架如下 接下来我们将按照模块化分析camx的内部初始化流程","tags":[]},{"title":"Hexo 博客搭建","date":"2019-12-31T16:00:01.000Z","path":"2020/01/01/计算机基础知识/Hexo 博客搭建/","text":"安装 Hexo1sudo npm install --unsafe-perm --verbose -g hexo 同步本地图片与网络图片 安装插件 1npm install https://github.com/CodeFalling/hexo-asset-image --save 配置Typora 编译 有以下log说明配置成功","tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://zh-wiki.github.io/tags/Hexo/"}]},{"title":"Git 常用命令","date":"2019-12-31T16:00:01.000Z","path":"2020/01/01/技术研发/Linux 命令/Git 常用命令/","text":"撤销指令 撤销工作区的修改 git checkout 文件名 git checkout 目录 -f 从暂存区撤销到工作区（可以理解为git add的反向动作） git reset HEAD 从版本库撤销到暂存区 git reset –soft HEAD^ 从版本库撤销到工作区 git reset –mixed HEAD^ 撤销到上一次提交（本地修改丢失） git reset –hard HEAD^ 保存恢复指令 保存本地未追踪的修改 git stash save 路径 将保存的内容导出 git stash pop stash@{index} 获取保存列表 git stash list 解决冲突这里我分为两种情况： 代码提到服务器上。 a. 首先把自己的提交reset掉。 b.更新代码 c.将自己的代码从服务器上拉下来。 d.冲突用code工具解决掉。然后add 修改文件，重新commit 代码在本地提交 a.将本地提交撤回到工作区。 b.保存本地修改 c.更新代码 d.将保存的代码还原。 e.冲突用code工具解决掉。然后add 修改文件，重新commit","tags":[]},{"title":"高通 Camx camera provider","date":"2019-12-31T16:00:01.000Z","path":"2020/01/01/技术研发/Camera Driver/高通 Camx/高通 Camx camera provider/","text":"概览 通过图片可以看出Camera Provider 分为两部分 通过 HIDL 与Camera Service 跨进程通信 通过 dlopen 方式加载一系列动态库 （Camera HAL3结构的so），在高通Camera 是指 camx-chi 架构 camera provider 和 camera hal3 的联系HAL硬件抽象层(Hardware Abstraction Layer),是谷歌开发的用于屏蔽底层硬件抽象出来的一个软件层，该层定义了自己的一套通用标准接口,平台厂商务必按照以下规则定义自己的Module 每一个硬件都通过hw_module_t来描述,具有固定的名字HMI 每一个硬件都必须实现hw_module_t里面的open方法,用于打开硬件设备,并返回对应的操作接口集合 硬件的操作接口集合使用hw_device_t 来描述,并可以通过自定义一个更大的包含hw_device_t的结构体来拓展硬件操作集合 HAL3 结构体介绍 hw_module_t 1234567891011121314151617typedef struct hw_module_t &#123; uint32_t tag; uint16_t module_api_version;#define version_major module_api_version uint16_t hal_api_version;#define version_minor hal_api_version const char *id; const char *name; const char *author; struct hw_module_methods_t* methods; void* dso;#ifdef __LP64__ uint64_t reserved[32-7];#else uint32_t reserved[32-7];#endif&#125; hw_module_t; hw_module_methods_t 12345typedef struct hw_module_methods_t &#123; /** Open a specific device */ int (*open)(const struct hw_module_t* module, const char* id, struct hw_device_t** device);&#125; hw_module_methods_t; hw_device_t 12345678910111213typedef struct hw_device_t &#123; uint32_t tag; uint32_t version; struct hw_module_t* module;#ifdef __LP64__ uint64_t reserved[12];#else uint32_t reserved[12];#endif int (*close)(struct hw_device_t* device); &#125; hw_device_t; 从上面的定义可以看出 hw_module_t 代表了模块，通过其open方法用来打开一个设备 设备是用hw_device_t来表示，其中除了用来关闭设备的close方法外,并无其它方法 由此可见谷歌定义的HAL接口,并不能满足绝大部分HAL模块的需要,所以谷歌想出了一个比较好的解决方式,那便是将这两个基本结构嵌入到更大的结构体内部,同时在更大的结构内部定义了各自模块特有的方法,用于实现模块的功能,这样,一来对上保持了HAL的统一规范,二来也扩展了模块的功能 高通 camx HAL3 结构体 camera_module_t 123456789101112131415typedef struct camera_module &#123; hw_module_t common; int (*get_number_of_cameras)(void); int (*get_camera_info)(int camera_id, struct camera_info *info); int (*set_callbacks)(const camera_module_callbacks_t *callbacks); void (*get_vendor_tag_ops)(vendor_tag_ops_t* ops); int (*open_legacy)(const struct hw_module_t* module, const char* id, uint32_t halVersion, struct hw_device_t** device); int (*set_torch_mode)(const char* camera_id, bool enabled); int (*init)(); int (*get_physical_camera_info)(int physical_camera_id, camera_metadata_t **static_metadata); int (*is_stream_combination_supported)(int camera_id, const camera_stream_combination_t *streams); void (*notify_device_state_change)(uint64_t deviceState); int (*get_camera_device_version)(int camera_id, uint32_t *version); void* reserved[1];&#125; camera_module_t; camera3_device_t 12345typedef struct camera3_device &#123; hw_device_t common; camera3_device_ops_t *ops; void *priv;&#125; camera3_device_t; camera_module_t包含了hw_module_t，主要用于表示Camera模块，其中定义了诸如get_number_of_cameras以及set_callbacks等扩展方法 camera3_device_t包含了hw_device_t,主要用来表示Camera设备,其中定义了camera3_device_ops操作方法集合,用来实现正常获取图像数据以及控制Camera的功能 Camera HAL3 的实现1234567891011121314151617181920CAMX_VISIBILITY_PUBLIC camera_module_t HAL_MODULE_INFO_SYM =&#123; .common = &#123; .tag = HARDWARE_MODULE_TAG, .module_api_version = CAMERA_MODULE_API_VERSION_CURRENT, .hal_api_version = HARDWARE_HAL_API_VERSION, .id = CAMERA_HARDWARE_MODULE_ID, .name = &quot;QTI Camera HAL&quot;, .author = &quot;Qualcomm Technologies, Inc.&quot;, .methods = &amp;CamX::g_hwModuleMethods &#125;, .get_number_of_cameras = CamX::get_number_of_cameras, .get_camera_info = CamX::get_camera_info, .set_callbacks = CamX::set_callbacks, .get_vendor_tag_ops = CamX::get_vendor_tag_ops, .open_legacy = NULL, .set_torch_mode = CamX::set_torch_mode, .init = CamX::init&#125;; 没错高通 camx hal3 的入口就是这个，在遵循HAL3规范的前提下，实例化各个接口。Provider 将会调用 hw_get_module() 来获取该入口。 各个接口映射到 camxhal3.cpp 1static Dispatch g_dispatchHAL3(&amp;g_jumpTableHAL3); 123456789101112131415161718192021222324252627JumpTableHAL3 g_jumpTableHAL3 =&#123; open, get_number_of_cameras, get_camera_info, set_callbacks, get_vendor_tag_ops, open_legacy, set_torch_mode, init, get_tag_count, get_all_tags, get_section_name, get_tag_name, get_tag_type, close, initialize, configure_streams, construct_default_request_settings, process_capture_request, dump, flush, camera_device_status_change, torch_mode_status_change, process_capture_result, notify&#125;; Provider init 代码流程 在系统初始化的时候，系统会去运行”&#97;&#110;&#100;&#114;&#111;&#105;&#x64;&#46;&#104;&#97;&#x72;&#x64;&#x77;&#97;&#114;&#101;&#x2e;&#x63;&#97;&#109;&#101;&#x72;&#x61;&#x2e;&#x70;&#114;&#111;&#118;&#105;&#100;&#101;&#x72;&#64;&#50;&#46;&#x34;&#x2d;&#x73;&#101;&#114;&#x76;&#x69;&#99;&#x65;&#95;&#x36;&#52;“程序启动Provider进程，并加入HW Service Manager中接受统一管理。在改过程中实例化一个 LegacyCameraProviderImpl_2_4 对象，通过 hw_get_module 标准方法 获取HAL 模块。这边指的是 camera.qcom.so 。 Camera Provider Init 函数总括123456789101112131415161718192021// hardware/interfaces/camera/provider/2.4/default/LegacyCameraProviderImpl_2_4.cppbool LegacyCameraProviderImpl_2_4::initialize() &#123; camera_module_t *rawModule; //获取 camera.qcom.so 可以理解为和 camxhal3entry.cpp 建立联系 int err = hw_get_module(CAMERA_HARDWARE_MODULE_ID, (const hw_module_t **)&amp;rawModule); //将 camera.qcom.so 获取的句柄保存在 mModule 对象中 ，该函数定义在 CameraModule.cpp mModule = new CameraModule(rawModule); //我们可以跟进去看看 init() 非常明显 实际就是进行 camx 的初始化，camxhal3entry.cpp &#123; CAMX:: init()&#125; //int CameraModule::init() 这个函数将会调用 getNumberOfCameras() //就此 camx-chi 的一系列初始化操作 拉开序幕 err = mModule-&gt;init(); // 设置回调函数，用于接受camx-chi的数据和事件 err = mModule-&gt;setCallbacks(this); mNumberOfLegacyCameras = mModule-&gt;getNumberOfCameras(); return false; // mInitFailed&#125; init 函数结束之后，Camera Provider进程便一直便存在于系统中,监听着来自Camera Service的调用。 Camera Provider Init 分解通过上面的总括可以理解为 Provider 最终目的获取 Camx-Chi 的 setting 以及 HW 资源。然后保存起来返回给上层，供后面使用。 二话不说先上一张大图 get_number_of_cameras 函数介绍这个函数是一切美好的开始，她的最先调用就是上面介绍的provide init 函数的 CameraModule::init() 123456789101112131415//hardware/interfaces/camera/common/1.0/default/CameraModule.cppint CameraModule::init() &#123; ATRACE_CALL(); int res = OK; if (getModuleApiVersion() &gt;= CAMERA_MODULE_API_VERSION_2_4 &amp;&amp; mModule-&gt;init != NULL) &#123; ATRACE_BEGIN(&quot;camera_module-&gt;init&quot;); res = mModule-&gt;init(); ATRACE_END(); &#125; //将会走到 vendor/proprietary/camx/src/coer/hal/camxhal3.cpp中 mNumberOfCameras = getNumberOfCameras(); mCameraInfoMap.setCapacity(mNumberOfCameras); return res;&#125; CameraModule::init() ，这个函数调用 getNumberOfCameras() 。最终调用到 get_number_of_cameras() 这个函数已经是干到camx了。 1234567891011//vendor/proprietary/camx/src/coer/hal/camxhal3.cppstatic int get_number_of_cameras(void)&#123; ...... INT numCameras; //将会走到 vendor/proprietary/camx/src/coer/hal/camxhal3module.cpp中 //会调用到 HAL3Module的构造函数 numCameras = static_cast&lt;int&gt;(HAL3Module::GetInstance()-&gt;GetNumCameras()); ...... return numCameras;&#125; 这个函数主要有两个作用： 是通过 HAL3Module 类的构造函数会获取 CAMX-CHI 的信息 加载 com.qti.chi.override.so 模块，映射 CAMX-CHI 之间的接口 12345678910111213141516//vendor/proprietary/camx/src/coer/hal/camxhal3module.cppHAL3Module::HAL3Module()&#123; CamxResult result = CamxResultSuccess; CSLCameraPlatform CSLPlatform = &#123;&#125;; CAMX_LOG_CONFIG(CamxLogGroupHAL, &quot;***************************************************&quot;); CAMX_LOG_CONFIG(CamxLogGroupHAL, &quot;SHA1: %s&quot;, CAMX_SHA1); CAMX_LOG_CONFIG(CamxLogGroupHAL, &quot;COMMITID: %s&quot;, CAMX_COMMITID); CAMX_LOG_CONFIG(CamxLogGroupHAL, &quot;BUILD TS: %s&quot;, CAMX_BUILD_TS); CAMX_LOG_CONFIG(CamxLogGroupHAL, &quot;***************************************************&quot;); ...... //到了这个位置已经是很亲切了，干到camx了 m_pStaticSettings = HwEnvironment::GetInstance()-&gt;GetStaticSettings(); ......&#125; HwEnvironment::Initialize() 函数介绍通过 HAL3Module 构造函数会调用 HwEnvironment 类的构造，主体功能在 HwEnvironment::Initialize() 中实现 HwEnvironment::Initialize() 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192//vendor/proprietary/camx/src/coer/camxhwenvironment.cppCamxResult HwEnvironment::Initialize()&#123; CamxResult result = CamxResultSuccess; CSLInitializeParams params = &#123; 0 &#125;; SettingsManager* pStaticSettingsManager = SettingsManager::Create(NULL); ExternalComponentInfo* pExternalComponent = GetExternalComponent(); if (NULL != pStaticSettingsManager) &#123; const StaticSettings* pStaticSettings = pStaticSettingsManager-&gt;GetStaticSettings(); if (NULL != pStaticSettings) &#123; params.mode = pStaticSettings-&gt;CSLMode; params.emulatedSensorParams.enableSensorSimulation = pStaticSettings-&gt;enableSensorEmulation; params.emulatedSensorParams.dumpSensorEmulationOutput = pStaticSettings-&gt;dumpSensorEmulationOutput; OsUtils::StrLCpy(params.emulatedSensorParams.sensorEmulatorPath, pStaticSettings-&gt;sensorEmulatorPath, sizeof(pStaticSettings-&gt;sensorEmulatorPath)); OsUtils::StrLCpy(params.emulatedSensorParams.sensorEmulator, pStaticSettings-&gt;sensorEmulator, sizeof(pStaticSettings-&gt;sensorEmulator)); result = CSLInitialize(&amp;params); if (CamxResultSuccess == result) &#123; // Query the camera platform result = QueryHwContextStaticEntryMethods(); &#125; if (CamxResultSuccess == result) &#123; m_pHwFactory = m_staticEntryMethods.CreateHwFactory(); if (NULL == m_pHwFactory) &#123; CAMX_ASSERT_ALWAYS_MESSAGE(&quot;Failed to create the HW factory&quot;); result = CamxResultEFailed; &#125; &#125; if (CamxResultSuccess == result) &#123; m_pSettingsManager = m_pHwFactory-&gt;CreateSettingsManager(); if (NULL == m_pSettingsManager) &#123; CAMX_ASSERT_ALWAYS_MESSAGE(&quot;Failed to create the HW settings manager&quot;); result = CamxResultEFailed; &#125; &#125; if (CamxResultSuccess == result) &#123; m_staticEntryMethods.GetHWBugWorkarounds(&amp;m_workarounds); &#125; &#125; pStaticSettingsManager-&gt;Destroy(); pStaticSettingsManager = NULL; &#125; CAMX_ASSERT(NULL != pExternalComponent); if ((CamxResultSuccess == result) &amp;&amp; (NULL != pExternalComponent)) &#123; result = ProbeChiComponents(pExternalComponent, &amp;m_numExternalComponent); &#125; if (CamxResultSuccess == result) &#123; // Load the OEM sensor capacity customization functions CAMXCustomizeCAMXInterface camxInterface; camxInterface.pGetHWEnvironment = HwEnvironment::GetInstance; CAMXCustomizeEntry(&amp;m_pOEMInterface, &amp;camxInterface); &#125; if (CamxResultSuccess != result) &#123; CAMX_LOG_ERROR(CamxLogGroupCore, &quot;FATAL ERROR: Raise SigAbort. HwEnvironment initialization failed&quot;); m_numberSensors = 0; OsUtils::RaiseSignalAbort(); &#125; else &#123; m_initCapsStatus = InitCapsInitialize; &#125; return result;&#125; 通过上面的代码可以看出 HwEnvironment::Initialize() 做的事情还是挺多的。下面我们开始分析 获取camx的相关配置 SettingsManager* pStaticSettingsManager = SettingsManager::Create(NULL); 经过一系列调用最终会调到以下代码，加载配置参数 123456789101112131415161718192021//vendor/proprietary/camx/src/coer/camxsettingsmanager.cppCamxResult SettingsManager::Initialize( StaticSettings* pStaticSettings)&#123; ...... // Populate the default settings InitializeDefaultSettings(); InitializeDefaultDebugSettings(); // Load the override settings from our override settings stores result = LoadOverrideSettings(m_pOverrideSettingsStore); result = LoadOverrideProperties(m_pOverrideSettingsStore, TRUE); result = ValidateSettings(); DumpSettings(); m_pOverrideSettingsStore-&gt;DumpOverriddenSettings(); ...... UpdateLogSettings(); return result;&#125; 利用加载好的配置参数去初始化相关模块 result = CSLInitialize(&amp;params); 经过一个跳转表格进入以下代码 CamxResult CSLInitializeHW() 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768//vendor/proprietary/camx/src/csl/hw/camxcslhw.cppCamxResult CSLInitializeHW()&#123; CamxResult result = CamxResultEFailed; CHAR syncDeviceName[CSLHwMaxDevName] = &#123;0&#125;; if (FALSE == CSLHwIsHwInstanceValid()) &#123; if (TRUE == CSLHwEnumerateAndAddCSLHwDevice(CSLInternalHwVideodevice, CAM_VNODE_DEVICE_TYPE)) &#123; if (TRUE == CSLHwEnumerateAndAddCSLHwDevice(CSLInternalHwVideoSubdevice, CAM_CPAS_DEVICE_TYPE)) &#123; CAMX_LOG_VERBOSE(CamxLogGroupCSL, &quot;Platform family=%d, version=%d.%d.%d, cpas version=%d.%d.%d&quot;, g_CSLHwInstance.pCameraPlatform.family, g_CSLHwInstance.pCameraPlatform.platformVersion.majorVersion, g_CSLHwInstance.pCameraPlatform.platformVersion.minorVersion, g_CSLHwInstance.pCameraPlatform.platformVersion.revVersion, g_CSLHwInstance.pCameraPlatform.CPASVersion.majorVersion, g_CSLHwInstance.pCameraPlatform.CPASVersion.minorVersion, g_CSLHwInstance.pCameraPlatform.CPASVersion.revVersion); if (FALSE == CSLHwEnumerateAndAddCSLHwDevice(CSLInternalHwVideoSubdeviceAll, 0)) &#123; CAMX_LOG_ERROR(CamxLogGroupCSL, &quot;No KMD devices found&quot;); &#125; else &#123; CAMX_LOG_VERBOSE(CamxLogGroupCSL, &quot;Total KMD subdevices found =%d&quot;, g_CSLHwInstance.kmdDeviceCount); &#125; // Init the memory manager data structures here CamX::Utils::Memset(g_CSLHwInstance.memManager.bufferInfo, 0, sizeof(g_CSLHwInstance.memManager.bufferInfo)); // Init the sync manager here g_CSLHwInstance.lock-&gt;Lock(); g_CSLHwInstance.pSyncFW = CamX::SyncManager::GetInstance(); if (NULL != g_CSLHwInstance.pSyncFW) &#123; CSLHwGetSyncHwDevice(syncDeviceName, CSLHwMaxDevName); CAMX_LOG_VERBOSE(CamxLogGroupCSL, &quot;Sync device found = %s&quot;, syncDeviceName); result = g_CSLHwInstance.pSyncFW-&gt;Initialize(syncDeviceName); if (CamxResultSuccess != result) &#123; CAMX_LOG_ERROR(CamxLogGroupCSL, &quot;CSL failed to initialize SyncFW&quot;); result = g_CSLHwInstance.pSyncFW-&gt;Destroy(); g_CSLHwInstance.pSyncFW = NULL; &#125; &#125; g_CSLHwInstance.lock-&gt;Unlock(); CSLHwInstanceSetState(CSLHwValidState); result = CamxResultSuccess; CAMX_LOG_VERBOSE(CamxLogGroupCSL, &quot;Successfully acquired requestManager&quot;); &#125; else &#123; CAMX_LOG_ERROR(CamxLogGroupCSL, &quot;Failed to acquire CPAS&quot;); &#125; &#125; else &#123; CAMX_LOG_ERROR(CamxLogGroupCSL, &quot;Failed to acquire requestManager invalid&quot;); &#125; &#125; else &#123; CAMX_LOG_ERROR(CamxLogGroupCSL, &quot;CSL in Invalid State&quot;); &#125; return result;&#125; 这一部分我个人理解为，遍历所有kernel端的设备。获取相关接口以及需要的事件。与HAL层建立联系。具体分析以后可以单独写一篇文章分析 根据平台获取对应的入口方法 这个暂时不知道是个什么鬼，先这样理解 result = QueryHwContextStaticEntryMethods(); 经过一系列的调用最终是跑到了这里 12345678910111213141516//vendor/proprietary/camx/src/csl/hwl/titan17x/camxtitan17xhwl.cppCamxResult Titan17xGetStaticEntryMethods( HwContextStaticEntry* pStaticEntry)&#123; CamxResult result = CamxResultSuccess; pStaticEntry-&gt;Create = &amp;Titan17xContext::Create; pStaticEntry-&gt;GetStaticMetadataKeysInfo = &amp;Titan17xContext::GetStaticMetadataKeysInfo; pStaticEntry-&gt;GetStaticCaps = &amp;Titan17xContext::GetStaticCaps; pStaticEntry-&gt;CreateHwFactory = &amp;Titan17xFactory::Create; pStaticEntry-&gt;QueryVendorTagsInfo = &amp;Titan17xContext::QueryVendorTagsInfo; pStaticEntry-&gt;GetHWBugWorkarounds = &amp;Titan17xContext::GetHWBugWorkarounds; pStaticEntry-&gt;QueryExternalComponentVendorTagsInfo = &amp;Titan17xContext::QueryExternalComponentVendorTagsInfo; return result;&#125;","tags":[]},{"title":"Ubuntu 开发环境的搭建","date":"2019-12-31T16:00:00.000Z","path":"2020/01/01/计算机基础知识/Ubuntu 开发环境的搭建/","text":"VirtualBox 修复’modprobe vboxdrv’ 报错 问题发生背景 Linux 内核版本升级之后，virtualbox 的驱动没有更新成功。 解决方法 更新整个系统 12sudo apt updatesudo apt upgrade 重新安装对应内核版本的头文件,和virtualbox的驱动 1sudo apt install --reinstall linux-headers-$(uname -r) virtualbox-dkms dkms 加载驱动重启 12sudo modprobe vboxdrvreboot 注意事项 更新驱动的时候，会重新编译驱动，所以要选择对应的gcc编译器，太老的估计会凉。 支持多版本的gcc 系统安装ok后默认gcc 版本是 v-7.x。我们先搞一个低版本的gcc 1234sudo apt-get install gcc-4.8sudo apt-get install g++-4.8sudo ln -sf /usr/bin/g++-4.8 /usr/bin/g++sudo ln -sf /usr/bin/gcc-4.8 /usr/bin/gcc 管理多个版本的gcc 查看存在几个版本的gcc 1ls -l /usr/bin/gcc 分别为gcc和g++添加管理组 12sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-4.8 40sudo update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++-4.8 40 能添加就能删除,从管理组中删除 1sudo update-alternatives --remove gcc /usr/bin/gcc-4.8 设置ok使用以下指令选择gcc的版本 12sudo update-alternatives --config gccsudo update-alternatives --config g++","tags":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://zh-wiki.github.io/tags/Ubuntu/"}]},{"title":"Android 研发总结","date":"2019-12-31T16:00:00.000Z","path":"2020/01/01/技术研发/Android 研发总结/经验总结/","text":"如何编译 selinux 编译命令 1make selinux_policy 生成的文件 path : out/target/product/lime/vendor/etc/selinux 如何将最近指定时间(45min)内生成的文件 push 到 指定 的路径1find . -mmin -45 -type f|grep -v SHARED_LIBRARIES|grep -v STATIC_LIBRARIES|grep -Ei &quot;so|bin&quot;|grep -v symbols|xargs -t -I &#x27;&#123;&#125;&#x27; adb push &#123;&#125; /vendor/lib64/&#123;&#125; 如何在安卓中自定义 log12#include &lt;android/log.h&gt; #define GC02M1B_DBG(fmt, args...) __android_log_print(ANDROID_LOG_ERROR, &quot;GC02M1B&quot;,fmt, ##args) Trace 的使用 systrace.py 的路径 path：项目代码/native/external/chromium-trace 如何打开 trace 的 html 在谷歌浏览器输入 chrome://tracing/","tags":[{"name":"Android","slug":"Android","permalink":"https://zh-wiki.github.io/tags/Android/"}]},{"title":"ADB 常用命令","date":"2019-12-31T16:00:00.000Z","path":"2020/01/01/技术研发/Linux 命令/ADB 常用命令/","text":"通用命令检测usb设备1adb wait-for-usb-device 属性相关123adb shell setprop 属性名adb shell getpropadb shell getprop | grep -i xxx 安装与卸载apk123adb install xxx.apkadb uninstall com.xxx.xxxadb shell pm list packages | grep xxx 设置屏幕1adb shell input keyevent 26 Cam相关指令dump camera的相关信息1adb shell dumpsys media.camera &gt; cam 查看camera个数1watch -n 1 -d &quot;adb shell dumpsys media.camera|grep Number&quot; 打开摄像头1adb shell am start -a android.media.action.STILL_IMAGE_CAMERA 打开前置摄像头1adb shell am start -a android.media.action.IMAGE_CAPTURE --ei android.intent.extras.CAMERA_FACING 1 高通平台 Camera 相关开启高通相机选择camera id1adb shell setprop persist.sys.camera.devoption.debug 100 使能多摄像1adb shell setprop persist.vendor.camera.multicam 1 开启支持多摄的权限123adb shell setprop vendor.camera.aux.packagelist org.codeaurora.snapcamadb shell setprop persist.vendor.camera.privapp.list org.codeaurora.snapcamadb shell setprop vendor.camera.aux.packagelist &quot;org.codeaurora.snapcam,com.huaqin.cameraautotest,com.huaqin.factory&quot; 高通 Camx 杀死 camera 进程1adb shell ps -A|grep camera |awk &#x27;&#123;print $2&#125;&#x27;|xargs adb shell kill -9 命令解释: awk ‘{print $2}’ 这个命令会把 ps -A | grep camera 得出的进程id 输出到终端 （$2 是第二字段也就是 进程id） xargs adb shell kill -9 这个命令会把 awk 获取到的线程id 当做参数传递给 kill -9 这个命令 高通 Camx dump metadata1adb shell dumpsys media.camera &gt;meta.log ADB 常见问题ADB 连接不上报以下错误 解决方法： 12cd /etc/udev/rules.dsudo vim 51-android.rules 在文件中写入：SUBSYSTEM==”usb”, ENV{DEVTYPE}==”usb_device”, MODE=”0666”","tags":[]},{"title":"MarkDown 常用语法","date":"2019-12-31T16:00:00.000Z","path":"2020/01/01/程序语言/MarkDown/MarkDown 常用语法/","text":"MarkDown 插入音频1&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=330 height=86 src=&quot;音频地址&quot;&gt;&lt;/iframe&gt; MarkDown 插入视频1&lt;iframe height=498 width=510 src=&quot;视频地址&quot; frameborder=0 allowfullscreen&gt;&lt;/iframe&gt; 插入代码折叠片段12345678&lt;details&gt;&lt;summary&gt;标签名&lt;/summary&gt;``````&lt;/details&gt;","tags":[{"name":"MarkDown","slug":"MarkDown","permalink":"https://zh-wiki.github.io/tags/MarkDown/"}]},{"title":"高通 Camx camera server","date":"2019-12-31T16:00:00.000Z","path":"2020/01/01/技术研发/Camera Driver/高通 Camx/高通 Camx camera server/","text":"Camera ServerCamera Server 是一个独立的进程，对上通过AIDL来完成 Camera Framework 的一些请求；对下通过HIDL 将上层发下来的请求提交给 Camera Provider。 Camera Server 对 Camera Framework 而言属于 服务端 Camera Server 对 Camera Provider 而言属于 客户端","tags":[]}],"categories":[],"tags":[{"name":"c++","slug":"c","permalink":"https://zh-wiki.github.io/tags/c/"},{"name":"UML","slug":"UML","permalink":"https://zh-wiki.github.io/tags/UML/"},{"name":"Arch Linux","slug":"Arch-Linux","permalink":"https://zh-wiki.github.io/tags/Arch-Linux/"},{"name":"Centos","slug":"Centos","permalink":"https://zh-wiki.github.io/tags/Centos/"},{"name":"Hexo","slug":"Hexo","permalink":"https://zh-wiki.github.io/tags/Hexo/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://zh-wiki.github.io/tags/Ubuntu/"},{"name":"Android","slug":"Android","permalink":"https://zh-wiki.github.io/tags/Android/"},{"name":"MarkDown","slug":"MarkDown","permalink":"https://zh-wiki.github.io/tags/MarkDown/"}]}