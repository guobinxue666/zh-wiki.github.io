{"pages":[{},{},{}],"posts":[{"title":"Welcome Zh-Wiki Site","date":"2020-10-05T08:27:35.037Z","path":"2020/10/05/index/","text":"","tags":[]},{"title":"生活学习","date":"2020-10-04T08:22:36.000Z","path":"2020/10/04/生活学习/生活学习/","text":"","tags":[]},{"title":"艺术","date":"2020-10-04T08:22:36.000Z","path":"2020/10/04/艺术/艺术/","text":"","tags":[]},{"title":"c++","date":"2020-09-29T15:23:24.000Z","path":"2020/09/29/程序语言/C++/c++/","text":"","tags":[]},{"title":"UML","date":"2020-09-29T15:23:24.000Z","path":"2020/09/29/程序语言/UML/UML/","text":"","tags":[]},{"title":"高通 Camx 问题总结","date":"2019-12-31T16:01:00.000Z","path":"2020/01/01/技术研发/Camera Driver/高通 Camera/高通 Camx 问题总结/","text":"","tags":[]},{"title":"高通 Camx Bring up","date":"2019-12-31T16:00:30.000Z","path":"2020/01/01/技术研发/Camera Driver/高通 Camera/高通 Camx Bring up/","text":"Dump EEprom Data1adb shell &quot;echo dumpSensorEEPROMData=1 &gt;&gt; /vendor/etc/camera/camxoverridesettings.txt&quot; 数据存放位置： /data/vendor/camera/xxx_kbuffer_OTP.txt","tags":[]},{"title":"高通 Camx capture result 代码流程","date":"2019-12-31T16:00:06.000Z","path":"2020/01/01/技术研发/Camera Driver/高通 Camera/高通 Camx capture result 代码流程/","text":"预览和拍照的 result 代码流程","tags":[]},{"title":"高通 Camx capture request 代码流程","date":"2019-12-31T16:00:05.000Z","path":"2020/01/01/技术研发/Camera Driver/高通 Camera/高通 Camx capture request 代码流程/","text":"预览和拍照的 request 代码流程主体框架图 详细代码调用流程123456789101112chi_override_process_request() //chxextensioninterface.cpp OverrideProcessRequest() //chxextensionmodule.cpp ProcessCaptureRequest()//chxusecase.cpp ExecuteCaptureRequest() //chxadvancedcamerausecase.cpp result = pFeature-&gt;ExecuteProcessRequest(pRequest); //会调到chifeature2wrapper.cpp:494 ExecuteProcessRequest() ExecuteProcessRequest() //chifeature2wrapper.cpp 开始进入算法的领域 SubmitRequestToSession() //经过一系类调用会走到 chifeature2base.cpp result = ExtensionModule::GetInstance()-&gt;ActivatePipeline() OnSubmitRequestToSession() ProcessFeatureMessage() ProcessMessageCb() //通过回调又重新回到 chifeature2wrapper.cpp result = pFeature2Wrapper-&gt;m_pUsecaseBase-&gt;SubmitRequest(&amp;submitRequest); //将 request 下到 camx session 中 CHI feature 通过 usecase 提交 request 到 session, 套路还是一样的（chxextensionmodule.cpp 通过这条链路转到Camx） 12result = pSession-&gt;ProcessCaptureRequest(pRequest); //camxchicontext.cpp feature submit request 会调到这里从这里开始步入 session CamxResult Session::ProcessCaptureRequest(); //camxsession.cpp","tags":[]},{"title":"高通 Camx config stream 代码流程","date":"2019-12-31T16:00:04.000Z","path":"2020/01/01/技术研发/Camera Driver/高通 Camera/高通 Camx config stream 代码流程/","text":"","tags":[]},{"title":"Arch Linux 开发环境的搭建","date":"2019-12-31T16:00:03.000Z","path":"2020/01/01/计算机基础知识/Arch Linux 开发环境的搭建/","text":"Arch Linux 系统安装主要进行分区，系统的安装，图形服务和必要驱动的安装 分区 查看当前分区信息 1fdisk -l 设置分区 1cfdisk /dev/sda 1)首先选择分区类型 ​ MBR 选择 dos ​ GPT 选择 gpt 2)MBR启动一般分为2个分区 ​ 主分区 （选择为boot标志） ​ 交换分区（内存的2倍） 格式化分区 格式化主分区 1mkfs.ext4 /dev/sda1 格式化交换分区 1mkswap /dev/sda2 启动交换分区 1swapon /dev/sda2 挂载分区 1mount /dev/sda1 /mnt 编辑镜像源1vim /etc/pacman.d/mirrorlist 将中国的源放在文件的开头 安装系统基本组件1pacstrap /mnt base linus linux-firmware 安装基本开发工具包12arch-chroot /mntpacman -S base-devel 安装 sudo123arch-chroot /mntpacman -S sudo vi vimvisudo 删除这一行注释 %wheel ALL = (ALL) ALL 创建用户12arch-chroot /mntuseradd -G wheel -m 用户名 安装 Grub1234arch-chroot /mntpacman -S grubgrub-install --target=i386-pc /dev/sdagrub-mkconfig -o /boot/grub/grub.cfg 生成 fstab该配置不需要 arch-chroot 1genfstab /mnt &gt; /mnt/etc/fstab 安装 Xorg 图形管理1pacstrap /mnt xorg-server xorg-xinit xorg-apps 安装网络组件12345pacstrap /mnt dhcpcd wpa_supplicant networkmanagerarch-chroot /mntsystemctl enable dhcpcdsystemctl enable wpa_supplicantsystemctl enable networkmanager 安装显卡驱动12lspci | grep VGA //查看显卡是什么型号pacman -S xf86-video-intel //intel 显卡驱动 安装音频组件12pacstrap /mnt alsa-utils pulseaudiopacstrap /mnt pulseaudio-alsa Arch Linux 桌面环境安装窗口管理器 dwm 安装终端内置浏览器 w3m 1sudo pacman -S w3m 下载 dwm 1w3m suckless.org 安装 1sudo make clean install 运行dwm 12vim ~/.xinitrcstartx 在 .xinitrc 中 加入 exec dwm 窗口管理器 i3 Arch Linux 基础配置安装中文字体 12sudo pacman -S noto-fonts noto-fonts-cjk noto-fonts-emojisudo vim /etc/locale.gen 取消 /etc/locale.gen 中 以下 的注释 en_US.UTF-8 UTF-8 zh_CN.UTF-8 UTF-8 zh_TW.UTF-8 UTF-8 生成 locale 1sudo locale-gen 设置 archlinuxcn123sudo vim /etc/pacman.confsudo pacman -Sysudo pacman -S archlinuxcn-keyring 在文件的末尾插入 [archlinuxcn] Server = https://mirrors.ustc.edu.cn/archlinuxcn/$arch 安装 Chrome1sudo pacman -S google-chrome 安装中文输入法 安装输入法以及配置工具 1sudo pacman -S fcitx fcitx-im kcm-fcitx fcitx-qt5 fcitx-gtk2 fcitx-gtk3 fcitx-configtool 配置输入法 1vim ~/.xprofile 输入以下内容 export GTK_IM_MODULE=fcitxexport QT_IM_MODULE=fcitxexport XMODIFIERS=”@im=fcitx” SSH 的安装与配置 安装ssh 1pacman -Sy openssh 生成密钥 1ssh-keygen -t rsa -C &quot;xxxxx@xxxxx.com&quot; 通过 SSH 远程连接问题 1vim /etc/ssh/sshd_config 在文件的末尾加以下配置 LoginGraceTime 120PermitRootLogin yesStrictModes yes","tags":[]},{"title":"高通 Camx Camx open camera","date":"2019-12-31T16:00:03.000Z","path":"2020/01/01/技术研发/Camera Driver/高通 Camera/高通 Camx open camera/","text":"","tags":[]},{"title":"Centos 开发环境的搭建","date":"2019-12-31T16:00:02.000Z","path":"2020/01/01/计算机基础知识/Centos 开发环境的搭建/","text":"同一网段外部浏览器不能访问Tomcat 问题产生背景和原因 背景：服务器已经安装好tomcat, 服务器主机通过 ip+8080 的方式可以进行访问, 但是其他在同一网段下的客户端机器通过同样方式不能访问. 原因：服务器未将 8080 端口进行开放 解决方法 1)查看防火墙状态 1firewall-cmd --state 2)添加需要开放的端口 1firewall-cmd --permanent --zone=public --add-port=8080/tcp 3)加载配置使其生效 1firewall-cmd --reload 4)查看配置是否生效 1firewall-cmd --permanent --zone=public --list-ports 5)重新访问 Tomcat (IP+8080) 防火墙的相关操作 开启防火墙的命令 1systemctl start firewalld.service 关闭防火墙的命令 1systemctl stop firewalld.service 开机自动启动 1systemctl enable firewalld.service 关闭开机自动启动 1systemctl disable firewalld.service 查看防火墙状态 1systemctl status firewalld","tags":[]},{"title":"高通 Camx init 流程","date":"2019-12-31T16:00:02.000Z","path":"2020/01/01/技术研发/Camera Driver/高通 Camera/高通 Camx init 流程/","text":"主体流程图","tags":[]},{"title":"Hexo 博客搭建","date":"2019-12-31T16:00:01.000Z","path":"2020/01/01/计算机基础知识/Hexo 博客搭建/","text":"安装 Hexo1sudo npm install --unsafe-perm --verbose -g hexo 同步本地图片与网络图片 安装插件 1npm install https://github.com/CodeFalling/hexo-asset-image --save 配置Typora 编译 有以下log说明配置成功","tags":[]},{"title":"高通 Camx camera provider","date":"2019-12-31T16:00:01.000Z","path":"2020/01/01/技术研发/Camera Driver/高通 Camera/高通 Camx camera provider/","text":"Camera Provider概览 通过图片可以看出Camera Provider 分为两部分 通过 HIDL 与Camera Service 跨进程通信 通过 dlopen 方式加载一系列动态库 （Camera HAL3结构的so），在高通Camera 是指 camx-chi 架构 Provider init 代码流程 在系统初始化的时候，系统会去运行”&#97;&#110;&#x64;&#114;&#x6f;&#105;&#100;&#46;&#x68;&#97;&#114;&#100;&#119;&#97;&#x72;&#101;&#x2e;&#99;&#97;&#x6d;&#x65;&#x72;&#97;&#46;&#x70;&#114;&#111;&#x76;&#105;&#x64;&#101;&#x72;&#x40;&#x32;&#46;&#x34;&#x2d;&#115;&#101;&#114;&#x76;&#105;&#99;&#x65;&#95;&#x36;&#x34;“程序启动Provider进程，并加入HW Service Manager中接受统一管理。在改过程中实例化一个 LegacyCameraProviderImpl_2_4 对象，通过 hw_get_module 标准方法 获取HAL 模块。这边指的是 camera.qcom.so 。 camera provider init 函数详解 123456789101112131415161718192021// hardware/interfaces/camera/provider/2.4/default/LegacyCameraProviderImpl_2_4.cppbool LegacyCameraProviderImpl_2_4::initialize() &#123; camera_module_t *rawModule; //获取 camera.qcom.so 可以理解为和 camxhal3entry.cpp 建立联系 int err = hw_get_module(CAMERA_HARDWARE_MODULE_ID, (const hw_module_t **)&amp;rawModule); //将 camera.qcom.so 获取的句柄保存在 mModule 对象中 ，该函数定义在 CameraModule.cpp mModule = new CameraModule(rawModule); //我们可以跟进去看看 init() 非常明显 实际就是进行 camx 的初始化，camxhal3entry.cpp &#123; CAMX:: init()&#125; //int CameraModule::init() 这个函数将会调用 getNumberOfCameras() //就此 camx-chi 的一系列初始化操作 拉开序幕 err = mModule-&gt;init(); // 设置回调函数，用于接受camx-chi的数据和事件 err = mModule-&gt;setCallbacks(this); mNumberOfLegacyCameras = mModule-&gt;getNumberOfCameras(); return false; // mInitFailed&#125; init 函数结束之后，Camera Provider进程便一直便存在于系统中,监听着来自Camera Service的调用。 camera provider 和 camera hal3 的联系HAL硬件抽象层(Hardware Abstraction Layer),是谷歌开发的用于屏蔽底层硬件抽象出来的一个软件层，该层定义了自己的一套通用标准接口,平台厂商务必按照以下规则定义自己的Module 每一个硬件都通过hw_module_t来描述,具有固定的名字HMI 每一个硬件都必须实现hw_module_t里面的open方法,用于打开硬件设备,并返回对应的操作接口集合 硬件的操作接口集合使用hw_device_t 来描述,并可以通过自定义一个更大的包含hw_device_t的结构体来拓展硬件操作集合 HAL3 结构体介绍 hw_module_t 1234567891011121314151617typedef struct hw_module_t &#123; uint32_t tag; uint16_t module_api_version;#define version_major module_api_version uint16_t hal_api_version;#define version_minor hal_api_version const char *id; const char *name; const char *author; struct hw_module_methods_t* methods; void* dso;#ifdef __LP64__ uint64_t reserved[32-7];#else uint32_t reserved[32-7];#endif&#125; hw_module_t; hw_module_methods_t 12345typedef struct hw_module_methods_t &#123; /** Open a specific device */ int (*open)(const struct hw_module_t* module, const char* id, struct hw_device_t** device);&#125; hw_module_methods_t; hw_device_t 12345678910111213typedef struct hw_device_t &#123; uint32_t tag; uint32_t version; struct hw_module_t* module;#ifdef __LP64__ uint64_t reserved[12];#else uint32_t reserved[12];#endif int (*close)(struct hw_device_t* device); &#125; hw_device_t; 从上面的定义可以看出 hw_module_t 代表了模块，通过其open方法用来打开一个设备 设备是用hw_device_t来表示，其中除了用来关闭设备的close方法外,并无其它方法 由此可见谷歌定义的HAL接口,并不能满足绝大部分HAL模块的需要,所以谷歌想出了一个比较好的解决方式,那便是将这两个基本结构嵌入到更大的结构体内部,同时在更大的结构内部定义了各自模块特有的方法,用于实现模块的功能,这样,一来对上保持了HAL的统一规范,二来也扩展了模块的功能 高通 camx HAL3 结构体 camera_module_t 123456789101112131415typedef struct camera_module &#123; hw_module_t common; int (*get_number_of_cameras)(void); int (*get_camera_info)(int camera_id, struct camera_info *info); int (*set_callbacks)(const camera_module_callbacks_t *callbacks); void (*get_vendor_tag_ops)(vendor_tag_ops_t* ops); int (*open_legacy)(const struct hw_module_t* module, const char* id, uint32_t halVersion, struct hw_device_t** device); int (*set_torch_mode)(const char* camera_id, bool enabled); int (*init)(); int (*get_physical_camera_info)(int physical_camera_id, camera_metadata_t **static_metadata); int (*is_stream_combination_supported)(int camera_id, const camera_stream_combination_t *streams); void (*notify_device_state_change)(uint64_t deviceState); int (*get_camera_device_version)(int camera_id, uint32_t *version); void* reserved[1];&#125; camera_module_t; camera3_device_t 12345typedef struct camera3_device &#123; hw_device_t common; camera3_device_ops_t *ops; void *priv;&#125; camera3_device_t; camera_module_t包含了hw_module_t，主要用于表示Camera模块，其中定义了诸如get_number_of_cameras以及set_callbacks等扩展方法 camera3_device_t包含了hw_device_t,主要用来表示Camera设备,其中定义了camera3_device_ops操作方法集合,用来实现正常获取图像数据以及控制Camera的功能 Camera HAL3 的实现1234567891011121314151617181920CAMX_VISIBILITY_PUBLIC camera_module_t HAL_MODULE_INFO_SYM =&#123; .common = &#123; .tag = HARDWARE_MODULE_TAG, .module_api_version = CAMERA_MODULE_API_VERSION_CURRENT, .hal_api_version = HARDWARE_HAL_API_VERSION, .id = CAMERA_HARDWARE_MODULE_ID, .name = &quot;QTI Camera HAL&quot;, .author = &quot;Qualcomm Technologies, Inc.&quot;, .methods = &amp;CamX::g_hwModuleMethods &#125;, .get_number_of_cameras = CamX::get_number_of_cameras, .get_camera_info = CamX::get_camera_info, .set_callbacks = CamX::set_callbacks, .get_vendor_tag_ops = CamX::get_vendor_tag_ops, .open_legacy = NULL, .set_torch_mode = CamX::set_torch_mode, .init = CamX::init&#125;; 没错高通 camx hal3 的入口就是这个，在遵循HAL3规范的前提下，实例化各个接口。Provider 将会调用 hw_get_module() 来获取该入口。 各个接口映射到 camxhal3.cpp 1static Dispatch g_dispatchHAL3(&amp;g_jumpTableHAL3); 123456789101112131415161718192021222324252627JumpTableHAL3 g_jumpTableHAL3 =&#123; open, get_number_of_cameras, get_camera_info, set_callbacks, get_vendor_tag_ops, open_legacy, set_torch_mode, init, get_tag_count, get_all_tags, get_section_name, get_tag_name, get_tag_type, close, initialize, configure_streams, construct_default_request_settings, process_capture_request, dump, flush, camera_device_status_change, torch_mode_status_change, process_capture_result, notify&#125;;","tags":[]},{"title":"Ubuntu 开发环境的搭建","date":"2019-12-31T16:00:00.000Z","path":"2020/01/01/计算机基础知识/Ubuntu 开发环境的搭建/","text":"VirtualBox 修复’modprobe vboxdrv’ 报错 问题发生背景 Linux 内核版本升级之后，virtualbox 的驱动没有更新成功。 解决方法 更新整个系统 12sudo apt updatesudo apt upgrade 重新安装对应内核版本的头文件,和virtualbox的驱动 1sudo apt install --reinstall linux-headers-$(uname -r) virtualbox-dkms dkms 加载驱动重启 12sudo modprobe vboxdrvreboot 注意事项 更新驱动的时候，会重新编译驱动，所以要选择对应的gcc编译器，太老的估计会凉。 支持多版本的gcc 系统安装ok后默认gcc 版本是 v-7.x。我们先搞一个低版本的gcc 1234sudo apt-get install gcc-4.8sudo apt-get install g++-4.8sudo ln -sf /usr/bin/g++-4.8 /usr/bin/g++sudo ln -sf /usr/bin/gcc-4.8 /usr/bin/gcc 管理多个版本的gcc 查看存在几个版本的gcc 1ls -l /usr/bin/gcc 分别为gcc和g++添加管理组 12sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-4.8 40sudo update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++-4.8 40 能添加就能删除,从管理组中删除 1sudo update-alternatives --remove gcc /usr/bin/gcc-4.8 设置ok使用以下指令选择gcc的版本 12sudo update-alternatives --config gccsudo update-alternatives --config g++","tags":[]},{"title":"Android 研发总结","date":"2019-12-31T16:00:00.000Z","path":"2020/01/01/技术研发/Android 研发总结/经验总结/","text":"如何编译 selinux 编译命令 1make selinux_policy 生成的文件 patch : out/target/product/lime/vendor/etc/selinux 如何将最近指定时间(45min)内生成的文件 push 到 指定 的路径1find . -mmin -45 -type f|grep -v SHARED_LIBRARIES|grep -v STATIC_LIBRARIES|grep -Ei &quot;so|bin&quot;|grep -v symbols|xargs -t -I &#x27;&#123;&#125;&#x27; adb push &#123;&#125; /vendor/lib64/&#123;&#125; 如何在安卓中自定义 log12#include &lt;android/log.h&gt; #define GC02M1B_DBG(fmt, args...) __android_log_print(ANDROID_LOG_ERROR, &quot;GC02M1B&quot;,fmt, ##args)","tags":[]},{"title":"ADB 常用命令","date":"2019-12-31T16:00:00.000Z","path":"2020/01/01/技术研发/Linux 命令/ADB 常用命令/","text":"高通平台 Camera 相关高通 Camx 杀死 camera 进程1adb shell ps -A|grep camera |awk &#x27;&#123;print $2&#125;&#x27;|xargs adb shell kill -9 由命令引发的知识: awk 命令的介绍 1awk &#x27;&#123;print $2&#125;&#x27; 这个命令会把 ps -A | grep camera 得出的进程id 输出到终端 （$2 是第二字段也就是 进程id） xargs 命令介绍 1xargs adb shell kill -9 这个命令会把 awk 获取到的线程id 当做参数传递给 kill -9 这个命令 高通 Camx dump metadata1adb shell dumpsys media.camera &gt;meta.log","tags":[]},{"title":"MarkDown 常用语法","date":"2019-12-31T16:00:00.000Z","path":"2020/01/01/程序语言/MarkDown/MarkDown 常用语法/","text":"MarkDown 插入音频1&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=330 height=86 src=&quot;音频地址&quot;&gt;&lt;/iframe&gt; MarkDown 插入视频1&lt;iframe height=498 width=510 src=&quot;视频地址&quot; frameborder=0 allowfullscreen&gt;&lt;/iframe&gt; 插入代码折叠片段12345678&lt;details&gt;&lt;summary&gt;标签名&lt;/summary&gt;``````&lt;/details&gt;","tags":[]},{"title":"高通 Camx camera server","date":"2019-12-31T16:00:00.000Z","path":"2020/01/01/技术研发/Camera Driver/高通 Camera/高通 Camx camera server/","text":"Camera ServerCamera Server 是一个独立的进程，对上通过AIDL来完成 Camera Framework 的一些请求；对下通过HIDL 将上层发下来的请求提交给 Camera Provider。 Camera Server 对 Camera Framework 而言属于 服务端 Camera Server 对 Camera Provider 而言属于 客户端","tags":[]}],"categories":[],"tags":[]}