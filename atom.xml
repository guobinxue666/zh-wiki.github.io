<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Zhou&#39;s Wiki</title>
  
  
  <link href="https://zh-wiki.github.io/atom.xml" rel="self"/>
  
  <link href="https://zh-wiki.github.io/"/>
  <updated>2020-10-29T09:34:37.547Z</updated>
  <id>https://zh-wiki.github.io/</id>
  
  <author>
    <name>Zhoujunwei</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Welcome Zhou jun wei&#39;s Wiki Site</title>
    <link href="https://zh-wiki.github.io/2020/10/05/index/"/>
    <id>https://zh-wiki.github.io/2020/10/05/index/</id>
    <published>2020-10-05T08:27:35.037Z</published>
    <updated>2020-10-29T09:34:37.547Z</updated>
    
    <content type="html"><![CDATA[<img src="/2020/10/05/index/index.jpg" alt="维基百科" style="zoom:200%;">]]></content>
    
    
      
      
    <summary type="html">&lt;img src=&quot;/2020/10/05/index/index.jpg&quot; alt=&quot;维基百科&quot; style=&quot;zoom:200%;&quot;&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>生活学习</title>
    <link href="https://zh-wiki.github.io/2020/10/04/%E7%94%9F%E6%B4%BB%E5%AD%A6%E4%B9%A0/%E7%94%9F%E6%B4%BB%E5%AD%A6%E4%B9%A0/"/>
    <id>https://zh-wiki.github.io/2020/10/04/%E7%94%9F%E6%B4%BB%E5%AD%A6%E4%B9%A0/%E7%94%9F%E6%B4%BB%E5%AD%A6%E4%B9%A0/</id>
    <published>2020-10-04T08:22:36.000Z</published>
    <updated>2020-10-05T08:27:35.037Z</updated>
    
    
    
    
    <category term="生活学习" scheme="https://zh-wiki.github.io/categories/%E7%94%9F%E6%B4%BB%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>艺术</title>
    <link href="https://zh-wiki.github.io/2020/10/04/%E8%89%BA%E6%9C%AF/%E8%89%BA%E6%9C%AF/"/>
    <id>https://zh-wiki.github.io/2020/10/04/%E8%89%BA%E6%9C%AF/%E8%89%BA%E6%9C%AF/</id>
    <published>2020-10-04T08:22:36.000Z</published>
    <updated>2020-10-05T08:27:35.037Z</updated>
    
    
    
    
    <category term="艺术" scheme="https://zh-wiki.github.io/categories/%E8%89%BA%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>UML</title>
    <link href="https://zh-wiki.github.io/2020/09/29/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/UML/UML/"/>
    <id>https://zh-wiki.github.io/2020/09/29/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/UML/UML/</id>
    <published>2020-09-29T15:23:24.000Z</published>
    <updated>2020-10-23T06:20:45.260Z</updated>
    
    
    
    
    <category term="程序语言" scheme="https://zh-wiki.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"/>
    
    <category term="UML" scheme="https://zh-wiki.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/UML/"/>
    
    
    <category term="UML" scheme="https://zh-wiki.github.io/tags/UML/"/>
    
  </entry>
  
  <entry>
    <title>高通 Camx Bring up</title>
    <link href="https://zh-wiki.github.io/2020/01/01/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera%20Driver/%E9%AB%98%E9%80%9A%20Camx/%E9%AB%98%E9%80%9A%20Camx%20Bring%20up/"/>
    <id>https://zh-wiki.github.io/2020/01/01/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera%20Driver/%E9%AB%98%E9%80%9A%20Camx/%E9%AB%98%E9%80%9A%20Camx%20Bring%20up/</id>
    <published>2019-12-31T16:00:30.000Z</published>
    <updated>2020-11-16T09:27:06.252Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Bring-Up-Sensor"><a href="#Bring-Up-Sensor" class="headerlink" title="Bring Up Sensor"></a>Bring Up Sensor</h1><h2 id="HAL层的配置"><a href="#HAL层的配置" class="headerlink" title="HAL层的配置"></a>HAL层的配置</h2><ol><li><p>移植驱动代码到相应的路径</p><p>vendor/qcom/proprietary/chi-cdk/oem/qcom/sensor/</p><p>驱动文件名字根据项目而定</p><img src="/2020/01/01/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera%20Driver/%E9%AB%98%E9%80%9A%20Camx/%E9%AB%98%E9%80%9A%20Camx%20Bring%20up/image-20201111142550122.png" alt="驱动代码" style="zoom:200%;"></li><li><p>sensor xml 相关配置</p><details><summary>lime_sunny_hi259_macro_sensor.xml</summary><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">slaveInfo</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!--Name of the sensor --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">sensorName</span>&gt;</span>lime_sunny_hi259_macro<span class="tag">&lt;/<span class="name">sensorName</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!--8-bit or 10-bit write slave address</span></span><br><span class="line"><span class="comment">       For External Sensors for which camx needs not probe the slave address shoule be as 0 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">slaveAddress</span>&gt;</span>0x60<span class="tag">&lt;/<span class="name">slaveAddress</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!--Register address / data size in bytes --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">regAddrType</span> <span class="attr">range</span>=<span class="string">&quot;[1,4]&quot;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">regAddrType</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!--Register address / data size in bytes --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">regDataType</span> <span class="attr">range</span>=<span class="string">&quot;[1,4]&quot;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">regDataType</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!--Register address for sensor Id --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">sensorIdRegAddr</span>&gt;</span>0x04<span class="tag">&lt;/<span class="name">sensorIdRegAddr</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!--Sensor Id 0xE1--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">sensorId</span>&gt;</span>0x113<span class="tag">&lt;/<span class="name">sensorId</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!--Mask for sensor id. Sensor Id may only be few bits --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">sensorIdMask</span>&gt;</span>4294967295<span class="tag">&lt;/<span class="name">sensorIdMask</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!--I2C frequency mode of slave</span></span><br><span class="line"><span class="comment">       Supported modes are: STANDARD (100 KHz), FAST (400 KHz), FAST_PLUS (1 MHz), CUSTOM (Custom frequency in DTSI) --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">i2cFrequencyMode</span>&gt;</span>FAST<span class="tag">&lt;/<span class="name">i2cFrequencyMode</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!--Sequence of power configuration type and configuration value required to control power to the device --&gt;</span></span><br><span class="line">   </span><br><span class="line">  <span class="tag">&lt;<span class="name">powerUpSequence</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">powerSetting</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">configType</span>&gt;</span>RESET<span class="tag">&lt;/<span class="name">configType</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">configValue</span>&gt;</span>1<span class="tag">&lt;/<span class="name">configValue</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">delayMs</span>&gt;</span>1<span class="tag">&lt;/<span class="name">delayMs</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">powerSetting</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">powerSetting</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">configType</span>&gt;</span>CUSTOM_GPIO1<span class="tag">&lt;/<span class="name">configType</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">configValue</span>&gt;</span>1<span class="tag">&lt;/<span class="name">configValue</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">delayMs</span>&gt;</span>0<span class="tag">&lt;/<span class="name">delayMs</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">powerSetting</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">powerSetting</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">configType</span>&gt;</span>CUSTOM_GPIO2<span class="tag">&lt;/<span class="name">configType</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">configValue</span>&gt;</span>1<span class="tag">&lt;/<span class="name">configValue</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">delayMs</span>&gt;</span>2<span class="tag">&lt;/<span class="name">delayMs</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">powerSetting</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">powerSetting</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">configType</span>&gt;</span>MCLK<span class="tag">&lt;/<span class="name">configType</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">configValue</span>&gt;</span>24000000<span class="tag">&lt;/<span class="name">configValue</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">delayMs</span>&gt;</span>8<span class="tag">&lt;/<span class="name">delayMs</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">powerSetting</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">powerSetting</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">configType</span>&gt;</span>RESET<span class="tag">&lt;/<span class="name">configType</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">configValue</span>&gt;</span>0<span class="tag">&lt;/<span class="name">configValue</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">delayMs</span>&gt;</span>1<span class="tag">&lt;/<span class="name">delayMs</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">powerSetting</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">powerUpSequence</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!--Sequence of power configuration type and configuration value required to control power to the device --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">powerDownSequence</span>&gt;</span></span><br><span class="line">     <span class="comment">&lt;!--Power setting configuration</span></span><br><span class="line"><span class="comment">         Contains: configType, configValue and delay in milli seconds --&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">powerSetting</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">configType</span>&gt;</span>RESET<span class="tag">&lt;/<span class="name">configType</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">configValue</span>&gt;</span>1<span class="tag">&lt;/<span class="name">configValue</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">delayMs</span>&gt;</span>1<span class="tag">&lt;/<span class="name">delayMs</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">powerSetting</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">powerSetting</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">configType</span>&gt;</span>MCLK<span class="tag">&lt;/<span class="name">configType</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">configValue</span>&gt;</span>0<span class="tag">&lt;/<span class="name">configValue</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">delayMs</span>&gt;</span>0<span class="tag">&lt;/<span class="name">delayMs</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">powerSetting</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">powerSetting</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">configType</span>&gt;</span>CUSTOM_GPIO1<span class="tag">&lt;/<span class="name">configType</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">configValue</span>&gt;</span>0<span class="tag">&lt;/<span class="name">configValue</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">delayMs</span>&gt;</span>0<span class="tag">&lt;/<span class="name">delayMs</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">powerSetting</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">powerSetting</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">configType</span>&gt;</span>CUSTOM_GPIO2<span class="tag">&lt;/<span class="name">configType</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">configValue</span>&gt;</span>0<span class="tag">&lt;/<span class="name">configValue</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">delayMs</span>&gt;</span>1<span class="tag">&lt;/<span class="name">delayMs</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">powerSetting</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">powerDownSequence</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">slaveInfo</span>&gt;</span></span><br></pre></td></tr></table></figure></details><ul><li>sensor name 跟sensor  文件夹名字一致</li><li>slaveAddress IIC 从机地址</li><li>sensor id 寄存器地址 以及 sensor id</li><li>上下电时序 (为了保险首先将reset引脚设置为禁止状态)</li></ul></li><li><p>module xml 配置</p><details><summary>lime_sunny_hi259_macro_module.xml</summary><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;</span></span><br><span class="line"><span class="comment">&lt;!--========================================================================--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Copyright (c) 2018 Qualcomm Technologies, Inc.                         --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- All Rights Reserved.                                                   --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Confidential and Proprietary - Qualcomm Technologies, Inc.             --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--========================================================================--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">cameraModuleData</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:noNamespaceSchemaLocation</span>=<span class="string">&quot;..\..\..\api\sensor\camxmoduleconfig.xsd&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">module_version</span> <span class="attr">major_revision</span>=<span class="string">&quot;1&quot;</span> <span class="attr">minor_revision</span>=<span class="string">&quot;0&quot;</span> <span class="attr">incr_revision</span>=<span class="string">&quot;0&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--Module group can contain either 1 module or 2 modules</span></span><br><span class="line"><span class="comment">      Dual camera, stereo camera use cases contain 2 modules in the group --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">moduleGroup</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--Module configuration --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">moduleConfiguration</span> <span class="attr">description</span>=<span class="string">&quot;Module configuration&quot;</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--CameraId is the id to which DTSI node is mapped.</span></span><br><span class="line"><span class="comment">          Typically CameraId is the slot Id for non combo mode. --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">cameraId</span>&gt;</span>3<span class="tag">&lt;/<span class="name">cameraId</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--Name of the module integrator --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">moduleName</span>&gt;</span>sunny<span class="tag">&lt;/<span class="name">moduleName</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--Name of the sensor in the image sensor module --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">sensorName</span>&gt;</span>lime_sunny_hi259_macro<span class="tag">&lt;/<span class="name">sensorName</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--Actuator name in the image sensor module</span></span><br><span class="line"><span class="comment">          This is an optional element. Skip this element if actuator is not present --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">actuatorName</span>&gt;</span><span class="tag">&lt;/<span class="name">actuatorName</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">oisName</span>&gt;</span><span class="tag">&lt;/<span class="name">oisName</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--EEPROM name in the image sensor module</span></span><br><span class="line"><span class="comment">          This is an optional element. Skip this element if EEPROM is not present --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">eepromName</span>&gt;</span><span class="tag">&lt;/<span class="name">eepromName</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--Flash name is used to used to open binary.</span></span><br><span class="line"><span class="comment">          Binary name is of form flashName_flash.bin Ex:- pmic_flash.bin --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">flashName</span>&gt;</span><span class="tag">&lt;/<span class="name">flashName</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--Chromatix name is used to used to open binary.</span></span><br><span class="line"><span class="comment">          Binary name is of the form sensor_model_chromatix.bin --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">chromatixName</span>&gt;</span>lime_sunny_hi259_macro<span class="tag">&lt;/<span class="name">chromatixName</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--Position of the sensor module.</span></span><br><span class="line"><span class="comment">          Valid values are: REAR, FRONT, REAR_AUX, FRONT_AUX, EXTERNAL --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">position</span>&gt;</span>REAR_AUX<span class="tag">&lt;/<span class="name">position</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--CSI Information --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">CSIInfo</span> <span class="attr">description</span>=<span class="string">&quot;CSI Information&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">laneAssign</span>&gt;</span>2<span class="tag">&lt;/<span class="name">laneAssign</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">isComboMode</span>&gt;</span>1<span class="tag">&lt;/<span class="name">isComboMode</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">CSIInfo</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--Lens information --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">lensInfo</span> <span class="attr">description</span>=<span class="string">&quot;Lens Information&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--Focal length of the lens in millimeters. --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">focalLength</span>&gt;</span>4.71<span class="tag">&lt;/<span class="name">focalLength</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--F-Number of the optical system. --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">fNumber</span>&gt;</span>1.79<span class="tag">&lt;/<span class="name">fNumber</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--Minimum focus distance in meters. --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">minFocusDistance</span>&gt;</span>0.1<span class="tag">&lt;/<span class="name">minFocusDistance</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--Total focus distance in meters. --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maxFocusDistance</span>&gt;</span>1.9<span class="tag">&lt;/<span class="name">maxFocusDistance</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--Horizontal view angle in degrees. --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">horizontalViewAngle</span>&gt;</span>67<span class="tag">&lt;/<span class="name">horizontalViewAngle</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--Vertical view angle in degrees. --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">verticalViewAngle</span>&gt;</span>53<span class="tag">&lt;/<span class="name">verticalViewAngle</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--Maximum Roll Degree. Valid values are: 0, 90, 180, 270, 360 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maxRollDegree</span>&gt;</span>270<span class="tag">&lt;/<span class="name">maxRollDegree</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--Maximum Pitch Degree. Valid values are: 0 to 359 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maxPitchDegree</span>&gt;</span>360<span class="tag">&lt;/<span class="name">maxPitchDegree</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--Maximum Yaw Degree. Valid values are: 0 to 359 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maxYawDegree</span>&gt;</span>360<span class="tag">&lt;/<span class="name">maxYawDegree</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">lensInfo</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">pdafName</span>&gt;</span><span class="tag">&lt;/<span class="name">pdafName</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">moduleConfiguration</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">moduleGroup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">cameraModuleData</span>&gt;</span></span><br></pre></td></tr></table></figure></details><ul><li>配置 CameraId 与kernel dts 相对应</li><li>配置sensorname 与 sensor xml 保持一致</li><li>配置 chromatixName 与 sensor name 保持一致</li><li>配置 position 摄像头位置 前摄 后摄 或者 后辅</li><li>配置 CSIInfo mipi 通道</li></ul></li></ol><h1 id="双摄帧同步导通"><a href="#双摄帧同步导通" class="headerlink" title="双摄帧同步导通"></a>双摄帧同步导通</h1><ol><li><p>将camx平台默认的几个属性开启</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> //camxsettings.xml      </span><br><span class="line"><span class="tag">&lt;<span class="name">VariableName</span>&gt;</span>multiCameraEnable<span class="tag">&lt;/<span class="name">VariableName</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">VariableName</span>&gt;</span>multiCameraHWSyncMask<span class="tag">&lt;/<span class="name">VariableName</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">VariableName</span>&gt;</span>multiCameraFrameSyncMask<span class="tag">&lt;/<span class="name">VariableName</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">VariableName</span>&gt;</span>multiCameraFPSMatchMask<span class="tag">&lt;/<span class="name">VariableName</span>&gt;</span></span><br><span class="line">//高通的case还给了这两个，j19S项目代码中没有找到这连个配置，没有配置也是OK的</span><br><span class="line">adb shell &quot;echo multiCamera3ASync=QTI &gt;&gt; /vendor/etc/camera/camxoverridesettings.txt&quot;</span><br><span class="line">adb shell &quot;echo multiCameraSATEnable=1 &gt;&gt; /vendor/etc/camera/camxoverridesettings.txt&quot;</span><br></pre></td></tr></table></figure></li><li><p>在Camera Id 映射的位置指定双摄的Camera Id</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> LogicalCameraConfiguration logicalCameraConfigurationKamorta[] =</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*cameraId cameraType              exposeFlag phyDevCnt  sensorId, transition low, high, smoothZoom, alwaysOn  realtimeEngine            primarySensorID, hwMaster*/</span></span><br><span class="line">    &#123;<span class="number">0</span>,        LogicalCameraType_Default, TRUE,      <span class="number">1</span>,    &#123;&#123;<span class="number">0</span>,                    <span class="number">0.0</span>, <span class="number">0.0</span>,   FALSE,    TRUE,     RealtimeEngineType_IFE&#125;&#125;,  <span class="number">0</span>,              <span class="number">0</span>    &#125;, <span class="comment">///&lt; Wide camera</span></span><br><span class="line">    &#123;<span class="number">1</span>,        LogicalCameraType_Default, TRUE,      <span class="number">1</span>,    &#123;&#123;<span class="number">2</span>,                    <span class="number">0.0</span>, <span class="number">0.0</span>,   FALSE,    TRUE,     RealtimeEngineType_IFE&#125;&#125;,  <span class="number">2</span>,              <span class="number">2</span>    &#125;, <span class="comment">///&lt; Front camera</span></span><br><span class="line">    &#123;<span class="number">2</span>,        LogicalCameraType_Default, TRUE,      <span class="number">1</span>,    &#123;&#123;<span class="number">1</span>,                    <span class="number">0.0</span>, <span class="number">0.0</span>,   FALSE,    TRUE,     RealtimeEngineType_IFE&#125;&#125;,  <span class="number">1</span>,              <span class="number">1</span>    &#125;, <span class="comment">///&lt; Tele camera</span></span><br><span class="line">    &#123;<span class="number">3</span>,        LogicalCameraType_Default, TRUE,      <span class="number">1</span>,    &#123;&#123;<span class="number">3</span>,                    <span class="number">0.0</span>, <span class="number">0.0</span>,   FALSE,    TRUE,     RealtimeEngineType_IFE&#125;&#125;,  <span class="number">3</span>,              <span class="number">3</span>    &#125;,</span><br><span class="line">    &#123;<span class="number">4</span>,        LogicalCameraType_RTB,     TRUE,      <span class="number">2</span>,    &#123;&#123;<span class="number">0</span>,                    <span class="number">2.0</span>, <span class="number">8.0</span>,   FALSE,    TRUE,     RealtimeEngineType_IFE&#125;,</span><br><span class="line">                                                            &#123;<span class="number">2</span>,                    <span class="number">1.0</span>, <span class="number">2.0</span>,   FALSE,    TRUE,     RealtimeEngineType_IFE&#125;&#125;,  <span class="number">0</span>,              <span class="number">0</span>    &#125;, <span class="comment">///&lt; RTB</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在j19S项目中更改了一下参数 。（双摄预览出图是辐摄）</p><ul><li>第一个参数: 调节zoom值</li><li>第二个参数: 配置主摄的camera Id</li></ul><p><img src="/2020/01/01/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera%20Driver/%E9%AB%98%E9%80%9A%20Camx/%E9%AB%98%E9%80%9A%20Camx%20Bring%20up/image-20201112172851742.png" alt="双摄帧同步"></p><p>在j19S项目中还有存在一个平台bug （上面介绍的结构体双摄不能为最后一个成员）</p><p>高通给的patch</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//vendor/qcom/proprietary/chi-cdk / oem/qcom/feature2/chifeature2graphselector/chifeature2graphselector.cpp</span></span><br><span class="line"><span class="function">VOID <span class="title">ChiFeature2GraphSelector::BuildCameraIdSet</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//Add by junwei.zhou according Qcom case num 04763737</span></span><br><span class="line">    <span class="comment">//fix platform design</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __XIAOMI_CAMERA__</span></span><br><span class="line">    m_cameraIdMap.insert(&#123; &#123; cameraIdSetSingle &#125;,  SINGLE_CAMERA &#125;);</span><br><span class="line">    m_cameraIdMap.insert(&#123; &#123; cameraIdSetBokeh &#125;,   BOKEH_CAMERA &#125;);</span><br><span class="line">    m_cameraIdMap.insert(&#123; &#123; cameraIdSetMulti &#125;,   MULTI_CAMERA &#125;);</span><br><span class="line">    m_cameraIdMap.insert(&#123; &#123; cameraIdSetFusion &#125;,  FUSION_CAMERA &#125;);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    m_cameraIdMap.insert(&#123; &#123; cameraIdSetSingle &#125;,  SINGLE_CAMERA &#125;);</span><br><span class="line">    m_cameraIdMap.insert(&#123; &#123; cameraIdSetMulti &#125;,   MULTI_CAMERA &#125;);</span><br><span class="line">    m_cameraIdMap.insert(&#123; &#123; cameraIdSetBokeh &#125;,   BOKEH_CAMERA &#125;);</span><br><span class="line">    m_cameraIdMap.insert(&#123; &#123; cameraIdSetFusion &#125;,  FUSION_CAMERA &#125;);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>分别配置主摄和辅摄的setting</p><ul><li><p>主摄：masterSettings</p></li><li><p>辐摄：slaveSettings</p></li></ul></li></ol><h1 id="Dump-EEprom-Data"><a href="#Dump-EEprom-Data" class="headerlink" title="Dump EEprom Data"></a>Dump EEprom Data</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell <span class="string">&quot;echo dumpSensorEEPROMData=1 &gt;&gt; /vendor/etc/camera/camxoverridesettings.txt&quot;</span></span><br></pre></td></tr></table></figure><p>数据存放位置： <strong>/data/vendor/camera/xxx_kbuffer_OTP.txt</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Bring-Up-Sensor&quot;&gt;&lt;a href=&quot;#Bring-Up-Sensor&quot; class=&quot;headerlink&quot; title=&quot;Bring Up Sensor&quot;&gt;&lt;/a&gt;Bring Up Sensor&lt;/h1&gt;&lt;h2 id=&quot;HAL层的配置&quot;&gt;&lt;a h</summary>
      
    
    
    
    <category term="技术研发" scheme="https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/"/>
    
    <category term="Camera Driver" scheme="https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera-Driver/"/>
    
    <category term="高通 Camx" scheme="https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera-Driver/%E9%AB%98%E9%80%9A-Camx/"/>
    
    
    <category term="高通Camx" scheme="https://zh-wiki.github.io/tags/%E9%AB%98%E9%80%9ACamx/"/>
    
  </entry>
  
  <entry>
    <title>高通 Camx capture result 代码流程</title>
    <link href="https://zh-wiki.github.io/2020/01/01/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera%20Driver/%E9%AB%98%E9%80%9A%20Camx/%E9%AB%98%E9%80%9A%20Camx%20capture%20result%20%E4%BB%A3%E7%A0%81%E6%B5%81%E7%A8%8B/"/>
    <id>https://zh-wiki.github.io/2020/01/01/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera%20Driver/%E9%AB%98%E9%80%9A%20Camx/%E9%AB%98%E9%80%9A%20Camx%20capture%20result%20%E4%BB%A3%E7%A0%81%E6%B5%81%E7%A8%8B/</id>
    <published>2019-12-31T16:00:06.000Z</published>
    <updated>2020-11-16T09:26:43.332Z</updated>
    
    <content type="html"><![CDATA[<h3 id="预览和拍照的-result-代码流程"><a href="#预览和拍照的-result-代码流程" class="headerlink" title="预览和拍照的 result 代码流程"></a>预览和拍照的 result 代码流程</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;预览和拍照的-result-代码流程&quot;&gt;&lt;a href=&quot;#预览和拍照的-result-代码流程&quot; class=&quot;headerlink&quot; title=&quot;预览和拍照的 result 代码流程&quot;&gt;&lt;/a&gt;预览和拍照的 result 代码流程&lt;/h3&gt;</summary>
      
    
    
    
    <category term="技术研发" scheme="https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/"/>
    
    <category term="Camera Driver" scheme="https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera-Driver/"/>
    
    <category term="高通 Camx" scheme="https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera-Driver/%E9%AB%98%E9%80%9A-Camx/"/>
    
    
    <category term="高通Camx" scheme="https://zh-wiki.github.io/tags/%E9%AB%98%E9%80%9ACamx/"/>
    
  </entry>
  
  <entry>
    <title>高通 Camx capture request 代码流程</title>
    <link href="https://zh-wiki.github.io/2020/01/01/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera%20Driver/%E9%AB%98%E9%80%9A%20Camx/%E9%AB%98%E9%80%9A%20Camx%20capture%20request%20%E4%BB%A3%E7%A0%81%E6%B5%81%E7%A8%8B/"/>
    <id>https://zh-wiki.github.io/2020/01/01/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera%20Driver/%E9%AB%98%E9%80%9A%20Camx/%E9%AB%98%E9%80%9A%20Camx%20capture%20request%20%E4%BB%A3%E7%A0%81%E6%B5%81%E7%A8%8B/</id>
    <published>2019-12-31T16:00:05.000Z</published>
    <updated>2020-11-16T09:26:39.156Z</updated>
    
    <content type="html"><![CDATA[<h3 id="预览和拍照的-request-代码流程"><a href="#预览和拍照的-request-代码流程" class="headerlink" title="预览和拍照的 request 代码流程"></a>预览和拍照的 request 代码流程</h3><h4 id="主体框架图"><a href="#主体框架图" class="headerlink" title="主体框架图"></a>主体框架图</h4><p><img src="/2020/01/01/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera%20Driver/%E9%AB%98%E9%80%9A%20Camx/%E9%AB%98%E9%80%9A%20Camx%20capture%20request%20%E4%BB%A3%E7%A0%81%E6%B5%81%E7%A8%8B/image-20201012225025652.png" alt="process capture request"></p><h4 id="详细代码调用流程"><a href="#详细代码调用流程" class="headerlink" title="详细代码调用流程"></a>详细代码调用流程</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">chi_override_process_request() <span class="comment">//chxextensioninterface.cpp </span></span><br><span class="line">OverrideProcessRequest()   <span class="comment">//chxextensionmodule.cpp </span></span><br><span class="line">    ProcessCaptureRequest()<span class="comment">//chxusecase.cpp</span></span><br><span class="line">    ExecuteCaptureRequest() <span class="comment">//chxadvancedcamerausecase.cpp</span></span><br><span class="line">    result = pFeature-&gt;ExecuteProcessRequest(pRequest); <span class="comment">//会调到chifeature2wrapper.cpp:494 ExecuteProcessRequest()</span></span><br><span class="line">    ExecuteProcessRequest() <span class="comment">//chifeature2wrapper.cpp 开始进入算法的领域</span></span><br><span class="line">                    SubmitRequestToSession() <span class="comment">//经过一系类调用会走到 chifeature2base.cpp </span></span><br><span class="line">                     result = ExtensionModule::GetInstance()-&gt;ActivatePipeline() </span><br><span class="line">                     OnSubmitRequestToSession()</span><br><span class="line">                    ProcessFeatureMessage()</span><br><span class="line">                    ProcessMessageCb() <span class="comment">//通过回调又重新回到 chifeature2wrapper.cpp </span></span><br><span class="line">                    result = pFeature2Wrapper-&gt;m_pUsecaseBase-&gt;SubmitRequest(&amp;submitRequest); <span class="comment">//将 request 下到 camx session 中  </span></span><br></pre></td></tr></table></figure><p>CHI feature 通过 usecase 提交 request 到 session, 套路还是一样的（chxextensionmodule.cpp 通过这条链路转到Camx）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">result = pSession-&gt;ProcessCaptureRequest(pRequest); <span class="comment">//camxchicontext.cpp feature submit request 会调到这里从这里开始步入 session</span></span><br><span class="line"><span class="function">CamxResult <span class="title">Session::ProcessCaptureRequest</span><span class="params">()</span></span>; <span class="comment">//camxsession.cpp </span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;预览和拍照的-request-代码流程&quot;&gt;&lt;a href=&quot;#预览和拍照的-request-代码流程&quot; class=&quot;headerlink&quot; title=&quot;预览和拍照的 request 代码流程&quot;&gt;&lt;/a&gt;预览和拍照的 request 代码流程&lt;/h3&gt;&lt;h4 i</summary>
      
    
    
    
    <category term="技术研发" scheme="https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/"/>
    
    <category term="Camera Driver" scheme="https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera-Driver/"/>
    
    <category term="高通 Camx" scheme="https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera-Driver/%E9%AB%98%E9%80%9A-Camx/"/>
    
    
    <category term="高通Camx" scheme="https://zh-wiki.github.io/tags/%E9%AB%98%E9%80%9ACamx/"/>
    
  </entry>
  
  <entry>
    <title>高通 Camx config stream 代码流程</title>
    <link href="https://zh-wiki.github.io/2020/01/01/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera%20Driver/%E9%AB%98%E9%80%9A%20Camx/%E9%AB%98%E9%80%9A%20Camx%20config%20stream%20%E4%BB%A3%E7%A0%81%E6%B5%81%E7%A8%8B/"/>
    <id>https://zh-wiki.github.io/2020/01/01/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera%20Driver/%E9%AB%98%E9%80%9A%20Camx/%E9%AB%98%E9%80%9A%20Camx%20config%20stream%20%E4%BB%A3%E7%A0%81%E6%B5%81%E7%A8%8B/</id>
    <published>2019-12-31T16:00:04.000Z</published>
    <updated>2020-11-16T09:26:26.896Z</updated>
    
    
    
    
    <category term="技术研发" scheme="https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/"/>
    
    <category term="Camera Driver" scheme="https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera-Driver/"/>
    
    <category term="高通 Camx" scheme="https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera-Driver/%E9%AB%98%E9%80%9A-Camx/"/>
    
    
    <category term="高通Camx" scheme="https://zh-wiki.github.io/tags/%E9%AB%98%E9%80%9ACamx/"/>
    
  </entry>
  
  <entry>
    <title>Arch Linux 开发环境的搭建</title>
    <link href="https://zh-wiki.github.io/2020/01/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Arch%20Linux%20%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E7%9A%84%E6%90%AD%E5%BB%BA/"/>
    <id>https://zh-wiki.github.io/2020/01/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Arch%20Linux%20%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E7%9A%84%E6%90%AD%E5%BB%BA/</id>
    <published>2019-12-31T16:00:03.000Z</published>
    <updated>2020-12-07T02:12:42.069Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Arch-Linux-系统安装"><a href="#Arch-Linux-系统安装" class="headerlink" title="Arch Linux 系统安装"></a>Arch Linux 系统安装</h1><hr><p>主要进行分区，系统的安装，图形服务和必要驱动的安装</p><h2 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h2><ol><li><p>查看当前分区信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fdisk -l</span><br></pre></td></tr></table></figure></li><li><p>设置分区</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cfdisk /dev/sda</span><br></pre></td></tr></table></figure><p>1)首先选择分区类型</p><p>​    MBR 选择 dos    </p><p>​    GPT  选择 gpt </p><p> 2)MBR启动一般分为2个分区</p><p>​    主分区   （选择为boot标志）</p><p>​    交换分区（内存的2倍）</p></li><li><p>格式化分区</p><p>格式化主分区</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkfs.ext4 /dev/sda1</span><br></pre></td></tr></table></figure><p>格式化交换分区</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkswap /dev/sda2</span><br></pre></td></tr></table></figure><p>启动交换分区</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">swapon /dev/sda2</span><br></pre></td></tr></table></figure></li><li><p>挂载分区</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount /dev/sda1 /mnt</span><br></pre></td></tr></table></figure></li></ol><h2 id="编辑镜像源"><a href="#编辑镜像源" class="headerlink" title="编辑镜像源"></a>编辑镜像源</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/pacman.d/mirrorlist</span><br></pre></td></tr></table></figure><p>将中国的源放在文件的开头</p><h2 id="安装系统基本组件"><a href="#安装系统基本组件" class="headerlink" title="安装系统基本组件"></a>安装系统基本组件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacstrap /mnt base linux linux-firmware</span><br></pre></td></tr></table></figure><h2 id="安装基本开发工具包"><a href="#安装基本开发工具包" class="headerlink" title="安装基本开发工具包"></a>安装基本开发工具包</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arch-chroot /mnt</span><br><span class="line">pacman -S base-devel</span><br></pre></td></tr></table></figure><h2 id="安装-sudo"><a href="#安装-sudo" class="headerlink" title="安装 sudo"></a>安装 sudo</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arch-chroot /mnt</span><br><span class="line">pacman -S sudo vi vim</span><br><span class="line">visudo</span><br></pre></td></tr></table></figure><p>删除这一行注释 <strong>%wheel ALL = (ALL) ALL</strong></p><h2 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arch-chroot /mnt</span><br><span class="line">useradd -G wheel -m 用户名</span><br><span class="line">passwad 用户名</span><br></pre></td></tr></table></figure><h2 id="安装-Grub"><a href="#安装-Grub" class="headerlink" title="安装 Grub"></a>安装 Grub</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arch-chroot /mnt</span><br><span class="line">pacman -S grub</span><br><span class="line">grub-install --target=i386-pc /dev/sda</span><br><span class="line">grub-mkconfig -o /boot/grub/grub.cfg</span><br></pre></td></tr></table></figure><h2 id="生成-fstab"><a href="#生成-fstab" class="headerlink" title="生成 fstab"></a>生成 fstab</h2><p>该配置不需要 arch-chroot </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">genfstab /mnt &gt; /mnt/etc/fstab</span><br></pre></td></tr></table></figure><h2 id="安装-Xorg-图形管理"><a href="#安装-Xorg-图形管理" class="headerlink" title="安装 Xorg 图形管理"></a>安装 Xorg 图形管理</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacstrap /mnt xorg-server xorg-xinit xorg-apps</span><br></pre></td></tr></table></figure><h2 id="安装网络组件"><a href="#安装网络组件" class="headerlink" title="安装网络组件"></a>安装网络组件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pacstrap /mnt dhcpcd wpa_supplicant networkmanager</span><br><span class="line">arch-chroot /mnt</span><br><span class="line">systemctl <span class="built_in">enable</span> dhcpcd</span><br><span class="line">systemctl <span class="built_in">enable</span> wpa_supplicant</span><br><span class="line">systemctl <span class="built_in">enable</span> networkmanager</span><br></pre></td></tr></table></figure><h2 id="安装显卡驱动"><a href="#安装显卡驱动" class="headerlink" title="安装显卡驱动"></a>安装显卡驱动</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lspci | grep VGA//查看显卡是什么型号</span><br><span class="line">pacman -S xf86-video-intel  //intel 显卡驱动</span><br></pre></td></tr></table></figure><h2 id="安装音频组件"><a href="#安装音频组件" class="headerlink" title="安装音频组件"></a>安装音频组件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pacstrap /mnt alsa-utils pulseaudio</span><br><span class="line">pacstrap /mnt pulseaudio-alsa</span><br></pre></td></tr></table></figure><h2 id="Arch-Linux-桌面环境安装"><a href="#Arch-Linux-桌面环境安装" class="headerlink" title="Arch Linux 桌面环境安装"></a>Arch Linux 桌面环境安装</h2><hr><h2 id="窗口管理器-dwm"><a href="#窗口管理器-dwm" class="headerlink" title="窗口管理器 dwm"></a>窗口管理器 dwm</h2><ol><li><p>安装终端内置浏览器 <strong>w3m</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S w3m</span><br></pre></td></tr></table></figure></li><li><p>下载 <strong>dwm</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">w3m suckless.org</span><br></pre></td></tr></table></figure></li><li><p>安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo make clean install</span><br></pre></td></tr></table></figure></li><li><p>运行dwm</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.xinitrc</span><br><span class="line">startx</span><br></pre></td></tr></table></figure><p>在 <strong>.xinitrc</strong> 中 加入 <strong>exec dwm</strong> </p><h1 id="Arch-Linux-基础配置"><a href="#Arch-Linux-基础配置" class="headerlink" title="Arch Linux 基础配置"></a>Arch Linux 基础配置</h1></li></ol><hr><h2 id="安装中文字体"><a href="#安装中文字体" class="headerlink" title="安装中文字体"></a>安装中文字体</h2>   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S noto-fonts noto-fonts-cjk noto-fonts-emoji</span><br><span class="line">sudo vim /etc/locale.gen</span><br></pre></td></tr></table></figure><p>取消 <strong>/etc/locale.gen</strong> 中 以下 的注释</p><ul><li><p>en_US.UTF-8 UTF-8</p></li><li><p>zh_CN.UTF-8 UTF-8</p></li><li><p>zh_TW.UTF-8 UTF-8</p></li></ul><p>生成 locale</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo locale-gen</span><br></pre></td></tr></table></figure><h2 id="设置-archlinuxcn"><a href="#设置-archlinuxcn" class="headerlink" title="设置 archlinuxcn"></a>设置 archlinuxcn</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/pacman.conf</span><br><span class="line">sudo pacman -Sy</span><br><span class="line">sudo pacman -S archlinuxcn-keyring</span><br></pre></td></tr></table></figure><p>在文件的末尾插入</p><p>[archlinuxcn]</p><p>Server = <a href="https://mirrors.ustc.edu.cn/archlinuxcn/$arch">https://mirrors.ustc.edu.cn/archlinuxcn/$arch</a></p><h2 id="安装-Chrome"><a href="#安装-Chrome" class="headerlink" title="安装 Chrome"></a>安装 Chrome</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S google-chrome</span><br></pre></td></tr></table></figure><h2 id="安装中文输入法"><a href="#安装中文输入法" class="headerlink" title="安装中文输入法"></a>安装中文输入法</h2><ol><li><p>安装输入法以及配置工具</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S fcitx fcitx-im kcm-fcitx fcitx-qt5 fcitx-gtk2 fcitx-gtk3 fcitx-configtool</span><br></pre></td></tr></table></figure></li><li><p>配置输入法</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.xprofile</span><br></pre></td></tr></table></figure><p>输入以下内容</p><p>export GTK_IM_MODULE=fcitx<br>export QT_IM_MODULE=fcitx<br>export XMODIFIERS=”@im=fcitx”</p></li></ol><h2 id="SSH-的安装与配置"><a href="#SSH-的安装与配置" class="headerlink" title="SSH 的安装与配置"></a>SSH 的安装与配置</h2><ol><li><p>安装ssh</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacman -Sy openssh</span><br></pre></td></tr></table></figure></li><li><p>生成密钥</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;xxxxx@xxxxx.com&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>通过 SSH 远程连接问题</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/ssh/sshd_config</span><br></pre></td></tr></table></figure><p>在文件的末尾加以下配置</p><p>LoginGraceTime 120<br>PermitRootLogin yes<br>StrictModes yes</p></li></ol><h2 id="vscode-zsh-乱码"><a href="#vscode-zsh-乱码" class="headerlink" title="vscode zsh 乱码"></a>vscode zsh 乱码</h2><ol><li><p>设置vscode终端字体</p><p><img src="/2020/01/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Arch%20Linux%20%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E7%9A%84%E6%90%AD%E5%BB%BA/image-20201206134507082.png" alt="设置终端字体"></p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Arch-Linux-系统安装&quot;&gt;&lt;a href=&quot;#Arch-Linux-系统安装&quot; class=&quot;headerlink&quot; title=&quot;Arch Linux 系统安装&quot;&gt;&lt;/a&gt;Arch Linux 系统安装&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;主要进行分区，系统的安装，</summary>
      
    
    
    
    <category term="计算机基础知识" scheme="https://zh-wiki.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="Arch Linux" scheme="https://zh-wiki.github.io/tags/Arch-Linux/"/>
    
  </entry>
  
  <entry>
    <title>高通 Camx Camx open camera</title>
    <link href="https://zh-wiki.github.io/2020/01/01/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera%20Driver/%E9%AB%98%E9%80%9A%20Camx/%E9%AB%98%E9%80%9A%20Camx%20open%20camera/"/>
    <id>https://zh-wiki.github.io/2020/01/01/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera%20Driver/%E9%AB%98%E9%80%9A%20Camx/%E9%AB%98%E9%80%9A%20Camx%20open%20camera/</id>
    <published>2019-12-31T16:00:03.000Z</published>
    <updated>2020-11-16T09:26:21.068Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Open-Camera-的流程简介"><a href="#Open-Camera-的流程简介" class="headerlink" title="Open Camera 的流程简介"></a>Open Camera 的流程简介</h1><p>当用户打开了相机设备之后，便会发生如下过程：</p><ol><li>APP调用CameraManager的openCamera方法，层层调用之后最终调用到Camera Service层中的CameraService::connectDevice方法</li><li>然后通过ICameraDevice::open()这一个HIDL接口通知Camera Provider层</li><li>在Camera Provider层内部又通过调用之前获取的camera_module_t中methods的open方法来获取一个Camera 设备，对应于HAL中的camera3_device_t结构体</li><li>在Camera Provider层调用获取到的camera3_device_t的initialize方法进行初始化动作</li></ol><p>代码大概流程走向</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//APP 端 open Camera</span></span><br><span class="line">CameraManager::openCamera() </span><br><span class="line">    <span class="comment">//Camera Server</span></span><br><span class="line">    CameraService::connectDevice()</span><br><span class="line">    <span class="comment">//通过HIDL接口</span></span><br><span class="line">    ICameraDevice::open()</span><br><span class="line">    <span class="comment">//camera provider</span></span><br><span class="line">    <span class="keyword">camera_module_t</span>::methods::open()</span><br><span class="line">    <span class="comment">//接下来就是进行一些初始化操作</span></span><br><span class="line">     <span class="keyword">camera3_device_t</span>::initialize()</span><br></pre></td></tr></table></figure><h1 id="APP-Open-Camera-流程"><a href="#APP-Open-Camera-流程" class="headerlink" title="APP Open Camera 流程"></a>APP Open Camera 流程</h1><p>App端主要做了以下几点工作</p><ol><li><p>获取 CameraManager 服务</p></li><li><p>打开指定的 Camera</p><ul><li>获取 Camera Server</li><li>调用 cameraService.connectDevice() 去连接打开设备，并且将上层传下来的回调传入Camera Server</li><li>返回Device给App端</li></ul></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//apk端获取CameraManager 服务</span></span><br><span class="line">mCamManager = (CameraManager)getSystemService(Context.CAMERA_SERVICE);  </span><br><span class="line"><span class="comment">//打开指定camera</span></span><br><span class="line">--&gt; mCamManager.openCamera(mCameraId, mStateCallback, null);    </span><br><span class="line"><span class="comment">//frameworks/base/core/java/android/hardware/camera2/CameraManager.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">openCamera</span><span class="params">(@NonNull String cameraId, @NonNull @CallbackExecutor Executor executor, @NonNull <span class="keyword">final</span> CameraDevice.StateCallback callback)</span></span></span><br><span class="line">   |--&gt; openCameraForUid(cameraId, callback, executor, USE_CALLING_UID)</span><br><span class="line">   |   |--&gt; openCameraDeviceUserAsync(cameraId, callback, executor, clientUid);</span><br><span class="line">   |   |   |--&gt; CameraDevice device = null; <span class="comment">//初始化CameraDevice</span></span><br><span class="line">   |   |   | <span class="comment">//实例化　new android.hardware.camera2.impl.CameraDeviceImpl</span></span><br><span class="line">   |   |   |--&gt; android.hardware.camera2.impl.CameraDeviceImpl deviceImpl = <span class="keyword">new</span> android.hardware.camera2.impl.CameraDeviceImpl(...) </span><br><span class="line">   |   |   |--&gt; ICameraDeviceCallbacks callbacks = deviceImpl.getCallbacks();   <span class="comment">//获取回调</span></span><br><span class="line">   |   |   |--&gt; ICameraService cameraService = CameraManagerGlobal.get().getCameraService();    <span class="comment">//获取CameraService 服务</span></span><br><span class="line">   |   |   |--&gt; cameraUser = cameraService.connectDevice(callbacks, cameraId, mContext.getOpPackageName(), uid);    <span class="comment">//连接打开camera</span></span><br><span class="line">   |   |   |--&gt; <span class="keyword">goto</span> CONNECTDEVICE:    <span class="comment">//跳转到下面CONNECTDEVICE处进行分析</span></span><br><span class="line">   |   |   |--&gt; deviceImpl.setRemoteDevice(cameraUser);</span><br><span class="line">   |   |   |   |--&gt; mRemoteDevice = <span class="keyword">new</span> ICameraDeviceUserWrapper(remoteDevice);</span><br><span class="line">   |   |   |   |--&gt; mDeviceExecutor.execute(mCallOnOpened); <span class="comment">//这里是一个线程池</span></span><br><span class="line">   |   |   |   |   |--&gt; sessionCallback = mSessionStateCallback;    <span class="comment">//获取session cb</span></span><br><span class="line">   |   |   |   |   |--&gt; sessionCallback.onOpened(CameraDeviceImpl.<span class="keyword">this</span>);    <span class="comment">//通过session cb 返回device</span></span><br><span class="line">   |   |   |   |   |--&gt; mDeviceCallback.onOpened(CameraDeviceImpl.<span class="keyword">this</span>);    <span class="comment">//通过device cb 返回device,这里就是返回给apk端的CameraDevice了</span></span><br></pre></td></tr></table></figure><h1 id="Camera-Server-Open-流程"><a href="#Camera-Server-Open-流程" class="headerlink" title="Camera Server Open 流程"></a>Camera Server Open 流程</h1><p>对于打开相机设备动作,主要由connectDevice来实现，当CameraFramework通过调用ICameraService的connectDevice接口的时候,主要做了两件事情：</p><ul><li>创建CameraDeviceClient。</li><li>对CameraDeviceClient进行初始化,并将其返回给Framework。</li></ul><h2 id="创建-CameraDevcieClient"><a href="#创建-CameraDevcieClient" class="headerlink" title="创建 CameraDevcieClient"></a>创建 CameraDevcieClient</h2><p>CameraDeviceClient 该类在打开设备的时候被实例化，一次打开设备的操作对应一个该类对象，它实现了ICameraDeviceUser接口，以AIDL方式暴露接口给Camera Framework进行调用，于此同时,该类在打开设备的过程中，获取了来自Camera Framework对于ICameraDeviceCallback接口的实现代理，通过该代理可以将结果上传至Camera Framewor中。我个人的理解其实这个类就是 framework 与 Camera 的通信入口。</p><p>代码流程如下：</p><ul><li>首先实例化一个CameraDeviceClient</li><li>将来自Framework针对ICameraDeviceCallback的实现存入CameraDeviceClient中，一旦有结果产生便可以将结果通过这个回调回传给Framework</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/av/services/camera/libcameraservice/CameraService.cpp</span></span><br><span class="line"><span class="function">Status <span class="title">CameraService::connectDevice</span><span class="params">(<span class="keyword">const</span> sp&lt;hardware::camera2::ICameraDeviceCallbacks&gt;&amp; cameraCb, <span class="keyword">const</span> String16&amp; cameraId, <span class="keyword">const</span> String16&amp; clientPackageName, <span class="keyword">int</span> clientUid, sp&lt;hardware::camera2::ICameraDeviceUser&gt;* device)</span> <span class="comment">//最后一个参数是返回值</span></span></span><br><span class="line">   |--&gt; connectHelper&lt;hardware::camera2::ICameraDeviceCallbacks,CameraDeviceClient&gt;(...) //模板，CALLBACK 为hardware::camera2::ICameraDeviceCallbacks， CLIENT： CameraDeviceClient</span><br><span class="line">   |   |--&gt; validateConnectLocked(...) <span class="comment">//关于一些权限的判断，如果没有权限或者非法访问这里会直接退出</span></span><br><span class="line">   |   |--&gt; <span class="keyword">int</span> deviceVersion = getDeviceVersion(cameraId, <span class="comment">/*out*/</span>&amp;facing) <span class="comment">//获取device version, 为之后的实例化哪一个client 做准备</span></span><br><span class="line">   |   |--&gt; makeClient(..., deviceVersion, effectiveApiLevel, ...) <span class="comment">//这里主要是这两个参数决定了实例化哪一个client，</span></span><br><span class="line">   |   |--&gt; *client = <span class="keyword">new</span> CameraDeviceClient(cameraService, tmp, packageName, cameraId,facing, clientPid, clientUid, servicePid) <span class="comment">//这里是实例化了CameraDeviceClient</span></span><br><span class="line">   |   |--&gt; client = <span class="keyword">static_cast</span>&lt;CLIENT*&gt;(tmp.get()); <span class="comment">//取得makeClient中实例化好的client</span></span><br><span class="line">   |   |--&gt; client-&gt;initialize(mCameraProviderManager, mMonitorTags); <span class="comment">//开始初始化</span></span><br></pre></td></tr></table></figure><h2 id="初始化-CameraDevcieClient"><a href="#初始化-CameraDevcieClient" class="headerlink" title="初始化 CameraDevcieClient"></a>初始化 CameraDevcieClient</h2><p>CameraDeviceClient的初始化工作流程：</p><ul><li>调用父类Camera2ClientBase的initialize方法进行初始化</li><li>实例化FrameProcessorBase对象并且将内部的Camera3Device对象传入其中,这样就建立了和Camera3Device的联系,之后将内部线程运行起来,等待来自Camera3Device的结果</li><li>将CameraDeviceClient注册到内部,这样就建立了与CameraDeviceClient的联系</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file : frameworks/av/services/camera/libcameraservice/api2/CameraDeviceClient.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">CameraDeviceClient::initialize</span><span class="params">(sp&lt;CameraProviderManager&gt; manager, <span class="keyword">const</span> String8&amp; monitorTags)</span></span></span><br><span class="line">   |--&gt; initializeImpl(manager, monitorTags)</span><br><span class="line">   |--&gt; mFrameProcessor = <span class="keyword">new</span> FrameProcessorBase(mDevice); <span class="comment">//实例化FrameProcessorBase对象</span></span><br><span class="line">   |   |--&gt; Camera2ClientBase::initialize(providerPtr, monitorTags)</span><br><span class="line">   <span class="comment">//file:  frameworks/av/services/camera/libcameraservice/common/Camera2ClientBase.cpp</span></span><br><span class="line">   |   |--&gt; <span class="keyword">status_t</span> Camera2ClientBase&lt;TClientBase&gt;::initialize(sp&lt;CameraProviderManager&gt; manager, <span class="keyword">const</span> String8&amp; monitorTags)</span><br><span class="line">   |   |   |--&gt; initializeImpl(manager, monitorTags)</span><br><span class="line">   |   |   |   |--&gt; mDevice-&gt;initialize(providerPtr, monitorTags)   <span class="comment">//这里的mDevice 是在 Camera2ClientBase初始化的时候传入的  mDevice(new Camera3Device(cameraId))</span></span><br></pre></td></tr></table></figure><h3 id="Camera3Device-结构介绍"><a href="#Camera3Device-结构介绍" class="headerlink" title="Camera3Device 结构介绍"></a>Camera3Device 结构介绍</h3><ul><li>主要实现了对Camera Provider 的ICameraDeviceCallbacks会调接口的实现，通过该接口接收来自Provider的结果上传进而传给CameraDeviceClient</li><li>Camera3Device会将事件通过notify方法给到CameraDeviceClient</li><li>Camera3Device中RequestThread主要用于处理Request的接收与下发工作</li></ul><p>Camera3Device 初始化</p><ul><li>通过调用CameraProviderManager的openSession方法打开并获取一个Provider中的ICameraDeviceSession代理</li><li>实例化一个HalInterface对象,将之前获取的ICameraDeviceSession代理存入其中,最后将RequestThread线程运行起来,等待request的下发</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file: device3/Camera3Device.cpp</span></span><br><span class="line"> <span class="function"><span class="keyword">status_t</span> <span class="title">Camera3Device::initialize</span><span class="params">(sp&lt;CameraProviderManager&gt; manager, <span class="keyword">const</span> String8&amp; monitorTags)</span></span></span><br><span class="line"> |--&gt; status_t res = manager-&gt;openSession(mId.string(), this, /*out*/ &amp;session)   //CameraProviderManager openSession</span><br><span class="line"> <span class="comment">//file: common/CameraProviderManager.cpp</span></span><br><span class="line">   |   |--&gt; <span class="function"><span class="keyword">status_t</span> <span class="title">CameraProviderManager::openSession</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;id, <span class="keyword">const</span> sp&lt;device::V3_2::ICameraDeviceCallback&gt;&amp; callback, sp&lt;device::V3_2::ICameraDeviceSession&gt; *session)</span></span></span><br><span class="line">   |   |   |--&gt; auto interface = deviceInfo3-&gt;startDeviceInterface&lt;CameraProviderManager::ProviderInfo::DeviceInfo3::InterfaceT&gt;()</span><br><span class="line">   |   |   |   |--&gt; <span class="keyword">const</span> sp&lt;provider::V2_4::ICameraProvider&gt; interface = startProviderInterface()  <span class="comment">//获取provider</span></span><br><span class="line">   |   |   |   |--&gt; interface-&gt;getCameraDeviceInterface_V3_x(name, [&amp;status, &amp;cameraInterface](hidl_cb) <span class="comment">//这里的hidl_cb 指的是回调接口，provider 会将device 指针返回回来，当然这个指针是跨进程能够调用的，具体怎么实现的暂时不清楚，暂且不管</span></span><br><span class="line">   |   |   |--&gt; interface-&gt;open(callback, [&amp;status, &amp;session](Status s, <span class="keyword">const</span> sp&lt;device::V3_2::ICameraDeviceSession&gt;&amp; cameraSession)    <span class="comment">//这里就调用的provider部分的Device的open接口</span></span><br></pre></td></tr></table></figure><h3 id="FrameProcessBase-结构介绍"><a href="#FrameProcessBase-结构介绍" class="headerlink" title="FrameProcessBase 结构介绍"></a>FrameProcessBase 结构介绍</h3><ul><li>meta data以及image data 会给到 FrameProcessBase</li><li>FrameProcessBase主要用于metadata以及image data的中转处理</li></ul><h1 id="Provider-Open-流程"><a href="#Provider-Open-流程" class="headerlink" title="Provider Open 流程"></a>Provider Open 流程</h1><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file: device/3.2/default/CameraDevice.cpp</span></span><br><span class="line"><span class="function">Return&lt;<span class="keyword">void</span>&gt; <span class="title">CameraDevice::open</span><span class="params">(<span class="keyword">const</span> sp&lt;ICameraDeviceCallback&gt;&amp; callback, ICameraDevice::open_cb _hidl_cb)</span></span></span><br><span class="line"><span class="function"> <span class="comment">//这里的mModule 是CameraModule实例，在provider调用etCameraDeviceInterface_V3_x 方法时通过实例化device deviceImpl = new </span></span></span><br><span class="line"><span class="function"> <span class="comment">//android::hardware::camera::device::V3_4::implementation::CameraDevice(mModule, cameraId, mCameraDeviceNames) 传入，</span></span></span><br><span class="line"><span class="function"> <span class="comment">//而mModule 是在provider初始化的时候创建，里面获取了camera hw module实例,关于proviser的初始化参见provider_initialize</span></span></span><br><span class="line"> |--&gt; mModule-&gt;open(mCameraId.c_str(), reinterpret_cast&lt;hw_device_t**&gt;(&amp;device)) </span><br><span class="line"> <span class="comment">//file: common/1.0/default/CameraModule.cpp</span></span><br><span class="line"> |--&gt; <span class="function"><span class="keyword">int</span> <span class="title">CameraModule::open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* id, struct <span class="keyword">hw_device_t</span>** device)</span></span></span><br><span class="line"> |   |--&gt; filterOpenErrorCode(mModule-&gt;common.methods-&gt;open(&amp;mModule-&gt;common, id, device))</span><br></pre></td></tr></table></figure><h1 id="Camx-Open-流程"><a href="#Camx-Open-流程" class="headerlink" title="Camx Open 流程"></a>Camx Open 流程</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Open-Camera-的流程简介&quot;&gt;&lt;a href=&quot;#Open-Camera-的流程简介&quot; class=&quot;headerlink&quot; title=&quot;Open Camera 的流程简介&quot;&gt;&lt;/a&gt;Open Camera 的流程简介&lt;/h1&gt;&lt;p&gt;当用户打开了相机设备</summary>
      
    
    
    
    <category term="技术研发" scheme="https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/"/>
    
    <category term="Camera Driver" scheme="https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera-Driver/"/>
    
    <category term="高通 Camx" scheme="https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera-Driver/%E9%AB%98%E9%80%9A-Camx/"/>
    
    
    <category term="高通Camx" scheme="https://zh-wiki.github.io/tags/%E9%AB%98%E9%80%9ACamx/"/>
    
  </entry>
  
  <entry>
    <title>Centos 开发环境的搭建</title>
    <link href="https://zh-wiki.github.io/2020/01/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Centos%20%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E7%9A%84%E6%90%AD%E5%BB%BA/"/>
    <id>https://zh-wiki.github.io/2020/01/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Centos%20%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E7%9A%84%E6%90%AD%E5%BB%BA/</id>
    <published>2019-12-31T16:00:02.000Z</published>
    <updated>2020-10-23T06:20:13.476Z</updated>
    
    <content type="html"><![CDATA[<h2 id="同一网段外部浏览器不能访问Tomcat"><a href="#同一网段外部浏览器不能访问Tomcat" class="headerlink" title="同一网段外部浏览器不能访问Tomcat"></a>同一网段外部浏览器不能访问Tomcat</h2><ol><li><p>问题产生背景和原因</p><p>背景：服务器已经安装好tomcat, 服务器主机通过 <strong>ip+8080</strong> 的方式可以进行访问, 但是其他在同一网段下的客户端机器通过同样方式不能访问.</p><p>原因：服务器未将 8080 端口进行开放</p></li><li><p>解决方法</p><p>1)查看防火墙状态</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --state</span><br></pre></td></tr></table></figure><p>2)添加需要开放的端口</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --permanent --zone=public --add-port=8080/tcp</span><br></pre></td></tr></table></figure><p>3)加载配置使其生效</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure><p>4)查看配置是否生效</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --permanent --zone=public --list-ports</span><br></pre></td></tr></table></figure><p>5)重新访问 Tomcat <strong>(IP+8080)</strong> </p></li></ol><h2 id="防火墙的相关操作"><a href="#防火墙的相关操作" class="headerlink" title="防火墙的相关操作"></a>防火墙的相关操作</h2><ol><li><p>开启防火墙的命令  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start firewalld.service</span><br></pre></td></tr></table></figure></li><li><p>关闭防火墙的命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop firewalld.service</span><br></pre></td></tr></table></figure></li><li><p>开机自动启动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> firewalld.service</span><br></pre></td></tr></table></figure></li><li><p>关闭开机自动启动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="built_in">disable</span> firewalld.service</span><br></pre></td></tr></table></figure></li><li><p>查看防火墙状态</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl status firewalld</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;同一网段外部浏览器不能访问Tomcat&quot;&gt;&lt;a href=&quot;#同一网段外部浏览器不能访问Tomcat&quot; class=&quot;headerlink&quot; title=&quot;同一网段外部浏览器不能访问Tomcat&quot;&gt;&lt;/a&gt;同一网段外部浏览器不能访问Tomcat&lt;/h2&gt;&lt;ol&gt;
</summary>
      
    
    
    
    <category term="计算机基础知识" scheme="https://zh-wiki.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="Centos" scheme="https://zh-wiki.github.io/tags/Centos/"/>
    
  </entry>
  
  <entry>
    <title>Repo 常用命令</title>
    <link href="https://zh-wiki.github.io/2020/01/01/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Linux%20%E5%91%BD%E4%BB%A4/Repo%20%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/"/>
    <id>https://zh-wiki.github.io/2020/01/01/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Linux%20%E5%91%BD%E4%BB%A4/Repo%20%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/</id>
    <published>2019-12-31T16:00:02.000Z</published>
    <updated>2020-11-30T16:04:07.509Z</updated>
    
    <content type="html"><![CDATA[<h3 id="repo-拉下来的代码如何新建分支"><a href="#repo-拉下来的代码如何新建分支" class="headerlink" title="repo 拉下来的代码如何新建分支"></a>repo 拉下来的代码如何新建分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">repo start xxx(分支名) --all</span><br></pre></td></tr></table></figure><h3 id="repo-sync-的时候如果有本地未提交的修改"><a href="#repo-sync-的时候如果有本地未提交的修改" class="headerlink" title="repo sync 的时候如果有本地未提交的修改"></a>repo sync 的时候如果有本地未提交的修改</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">repo forall -cv <span class="string">&quot;git reset HEAD --hard; git clean -df &quot;</span> -j32</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;repo-拉下来的代码如何新建分支&quot;&gt;&lt;a href=&quot;#repo-拉下来的代码如何新建分支&quot; class=&quot;headerlink&quot; title=&quot;repo 拉下来的代码如何新建分支&quot;&gt;&lt;/a&gt;repo 拉下来的代码如何新建分支&lt;/h3&gt;&lt;figure class</summary>
      
    
    
    
    <category term="技术研发" scheme="https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/"/>
    
    <category term="Linux 命令" scheme="https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Linux-%E5%91%BD%E4%BB%A4/"/>
    
    
  </entry>
  
  <entry>
    <title>高通 Camx camera provider</title>
    <link href="https://zh-wiki.github.io/2020/01/01/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera%20Driver/%E9%AB%98%E9%80%9A%20Camx/%E9%AB%98%E9%80%9A%20Camx%20camera%20provider/"/>
    <id>https://zh-wiki.github.io/2020/01/01/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera%20Driver/%E9%AB%98%E9%80%9A%20Camx/%E9%AB%98%E9%80%9A%20Camx%20camera%20provider/</id>
    <published>2019-12-31T16:00:02.000Z</published>
    <updated>2020-11-16T09:25:44.575Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h1><img src="/2020/01/01/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera%20Driver/%E9%AB%98%E9%80%9A%20Camx/%E9%AB%98%E9%80%9A%20Camx%20camera%20provider/image-20201021102734471.png" alt="camera provider" style="zoom:80%;"><p>通过图片可以看出Camera Provider 分为两部分</p><ul><li>通过 <strong>HIDL</strong> 与Camera Service 跨进程通信</li><li>通过 <strong>dlopen</strong> 方式加载一系列动态库 （Camera HAL3结构的so），在高通Camera 是指 camx-chi 架构</li></ul><h1 id="camera-provider-和-camera-hal3-的联系"><a href="#camera-provider-和-camera-hal3-的联系" class="headerlink" title="camera provider 和 camera hal3 的联系"></a>camera provider 和 camera hal3 的联系</h1><p>HAL硬件抽象层(Hardware Abstraction Layer),是谷歌开发的用于屏蔽底层硬件抽象出来的一个软件层，该层定义了自己的一套通用标准接口,平台厂商务必按照以下规则定义自己的Module</p><ul><li>每一个硬件都通过hw_module_t来描述,具有固定的名字HMI</li><li>每一个硬件都必须实现hw_module_t里面的open方法,用于打开硬件设备,并返回对应的操作接口集合</li><li>硬件的操作接口集合使用hw_device_t 来描述,并可以通过自定义一个更大的包含hw_device_t的结构体来拓展硬件操作集合</li></ul><h2 id="HAL3-结构体介绍"><a href="#HAL3-结构体介绍" class="headerlink" title="HAL3 结构体介绍"></a>HAL3 结构体介绍</h2><details><summary>hw_module_t</summary><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">hw_module_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> tag;</span><br><span class="line">    <span class="keyword">uint16_t</span> module_api_version;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> version_major module_api_version</span></span><br><span class="line">    <span class="keyword">uint16_t</span> hal_api_version;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> version_minor hal_api_version</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *id;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *author;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hw_module_methods_t</span>* <span class="title">methods</span>;</span></span><br><span class="line">    <span class="keyword">void</span>* dso;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __LP64__</span></span><br><span class="line">    <span class="keyword">uint64_t</span> reserved[<span class="number">32</span><span class="number">-7</span>];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="keyword">uint32_t</span> reserved[<span class="number">32</span><span class="number">-7</span>];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125; <span class="keyword">hw_module_t</span>;</span><br></pre></td></tr></table></figure></details><details><summary>hw_module_methods_t</summary><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">hw_module_methods_t</span> &#123;</span></span><br><span class="line">    <span class="comment">/** Open a specific device */</span></span><br><span class="line">    <span class="keyword">int</span> (*open)(<span class="keyword">const</span> struct <span class="keyword">hw_module_t</span>* <span class="keyword">module</span>, <span class="keyword">const</span> <span class="keyword">char</span>* id,</span><br><span class="line">            struct <span class="keyword">hw_device_t</span>** device);</span><br><span class="line">&#125; <span class="keyword">hw_module_methods_t</span>;</span><br></pre></td></tr></table></figure></details><details><summary>hw_device_t</summary><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">hw_device_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> tag;</span><br><span class="line">    <span class="keyword">uint32_t</span> version;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hw_module_t</span>* <span class="title">module</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __LP64__</span></span><br><span class="line">    <span class="keyword">uint64_t</span> reserved[<span class="number">12</span>];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="keyword">uint32_t</span> reserved[<span class="number">12</span>];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> (*close)(struct <span class="keyword">hw_device_t</span>* device);</span><br><span class="line">    </span><br><span class="line">&#125; <span class="keyword">hw_device_t</span>;</span><br></pre></td></tr></table></figure></details><p>从上面的定义可以看出</p><ul><li><p>hw_module_t 代表了模块，通过其open方法用来打开一个设备</p></li><li><p>设备是用hw_device_t来表示，其中除了用来关闭设备的close方法外,并无其它方法</p></li><li><p>由此可见谷歌定义的HAL接口,并不能满足绝大部分HAL模块的需要,所以谷歌想出了一个比较好的解决方式,那便是将这两个基本结构嵌入到更大的结构体内部,同时在更大的结构内部定义了各自模块特有的方法,用于实现模块的功能,这样,一来对上保持了HAL的统一规范,二来也扩展了模块的功能</p></li></ul><h2 id="高通-camx-HAL3-结构体"><a href="#高通-camx-HAL3-结构体" class="headerlink" title="高通 camx HAL3 结构体"></a>高通 camx HAL3 结构体</h2><details><summary>camera_module_t</summary><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">camera_module</span> &#123;</span></span><br><span class="line">    <span class="keyword">hw_module_t</span> common;</span><br><span class="line">    <span class="keyword">int</span> (*get_number_of_cameras)(<span class="keyword">void</span>);</span><br><span class="line">    <span class="keyword">int</span> (*get_camera_info)(<span class="keyword">int</span> camera_id, struct camera_info *info);</span><br><span class="line">    <span class="keyword">int</span> (*set_callbacks)(<span class="keyword">const</span> <span class="keyword">camera_module_callbacks_t</span> *callbacks);</span><br><span class="line">    <span class="keyword">void</span> (*get_vendor_tag_ops)(<span class="keyword">vendor_tag_ops_t</span>* ops);</span><br><span class="line">    <span class="keyword">int</span> (*open_legacy)(<span class="keyword">const</span> struct <span class="keyword">hw_module_t</span>* <span class="keyword">module</span>, <span class="keyword">const</span> <span class="keyword">char</span>* id, <span class="keyword">uint32_t</span> halVersion, struct <span class="keyword">hw_device_t</span>** device);</span><br><span class="line">    <span class="keyword">int</span> (*set_torch_mode)(<span class="keyword">const</span> <span class="keyword">char</span>* camera_id, <span class="keyword">bool</span> enabled);</span><br><span class="line">    <span class="keyword">int</span> (*init)();</span><br><span class="line">    <span class="keyword">int</span> (*get_physical_camera_info)(<span class="keyword">int</span> physical_camera_id,  <span class="keyword">camera_metadata_t</span> **static_metadata);</span><br><span class="line">    <span class="keyword">int</span> (*is_stream_combination_supported)(<span class="keyword">int</span> camera_id, <span class="keyword">const</span> <span class="keyword">camera_stream_combination_t</span> *streams);</span><br><span class="line">    <span class="keyword">void</span> (*notify_device_state_change)(<span class="keyword">uint64_t</span> deviceState);</span><br><span class="line">    <span class="keyword">int</span> (*get_camera_device_version)(<span class="keyword">int</span> camera_id, <span class="keyword">uint32_t</span> *version);</span><br><span class="line">    <span class="keyword">void</span>* reserved[<span class="number">1</span>];</span><br><span class="line">&#125; <span class="keyword">camera_module_t</span>;</span><br></pre></td></tr></table></figure></details><details><summary>camera3_device_t</summary><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">camera3_device</span> &#123;</span></span><br><span class="line">    <span class="keyword">hw_device_t</span> common;</span><br><span class="line">    <span class="keyword">camera3_device_ops_t</span> *ops;</span><br><span class="line">    <span class="keyword">void</span> *priv;</span><br><span class="line">&#125; <span class="keyword">camera3_device_t</span>;</span><br></pre></td></tr></table></figure></details><ul><li>camera_module_t包含了hw_module_t，主要用于表示Camera模块，其中定义了诸如get_number_of_cameras以及set_callbacks等扩展方法</li><li>camera3_device_t包含了hw_device_t,主要用来表示Camera设备,其中定义了camera3_device_ops操作方法集合,用来实现正常获取图像数据以及控制Camera的功能</li></ul><h2 id="Camera-HAL3-的实现"><a href="#Camera-HAL3-的实现" class="headerlink" title="Camera HAL3 的实现"></a>Camera HAL3 的实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">CAMX_VISIBILITY_PUBLIC <span class="keyword">camera_module_t</span> HAL_MODULE_INFO_SYM =</span><br><span class="line">&#123;</span><br><span class="line">    .common =</span><br><span class="line">    &#123;</span><br><span class="line">        .tag                = HARDWARE_MODULE_TAG,</span><br><span class="line">        .module_api_version = CAMERA_MODULE_API_VERSION_CURRENT,</span><br><span class="line">        .hal_api_version    = HARDWARE_HAL_API_VERSION,</span><br><span class="line">        .id                 = CAMERA_HARDWARE_MODULE_ID,</span><br><span class="line">        .name               = <span class="string">&quot;QTI Camera HAL&quot;</span>,</span><br><span class="line">        .author             = <span class="string">&quot;Qualcomm Technologies, Inc.&quot;</span>,</span><br><span class="line">        .methods            = &amp;CamX::g_hwModuleMethods</span><br><span class="line">    &#125;,</span><br><span class="line">    .get_number_of_cameras  = CamX::get_number_of_cameras,</span><br><span class="line">    .get_camera_info        = CamX::get_camera_info,</span><br><span class="line">    .set_callbacks          = CamX::set_callbacks,</span><br><span class="line">    .get_vendor_tag_ops     = CamX::get_vendor_tag_ops,</span><br><span class="line">    .open_legacy            = <span class="literal">NULL</span>,</span><br><span class="line">    .set_torch_mode         = CamX::set_torch_mode,</span><br><span class="line">    .init                   = CamX::init</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>没错高通 camx hal3 的入口就是这个，在遵循HAL3规范的前提下，实例化各个接口。Provider 将会调用 hw_get_module() 来获取该入口。</p><p>各个接口映射到 camxhal3.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> Dispatch <span class="title">g_dispatchHAL3</span><span class="params">(&amp;g_jumpTableHAL3)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">JumpTableHAL3 g_jumpTableHAL3 =</span><br><span class="line">&#123;</span><br><span class="line">    open,</span><br><span class="line">    get_number_of_cameras,</span><br><span class="line">    get_camera_info,</span><br><span class="line">    set_callbacks,</span><br><span class="line">    get_vendor_tag_ops,</span><br><span class="line">    open_legacy,</span><br><span class="line">    set_torch_mode,</span><br><span class="line">    init,</span><br><span class="line">    get_tag_count,</span><br><span class="line">    get_all_tags,</span><br><span class="line">    get_section_name,</span><br><span class="line">    get_tag_name,</span><br><span class="line">    get_tag_type,</span><br><span class="line">    close,</span><br><span class="line">    initialize,</span><br><span class="line">    configure_streams,</span><br><span class="line">    construct_default_request_settings,</span><br><span class="line">    process_capture_request,</span><br><span class="line">    dump,</span><br><span class="line">    flush,</span><br><span class="line">    camera_device_status_change,</span><br><span class="line">    torch_mode_status_change,</span><br><span class="line">    process_capture_result,</span><br><span class="line">    notify</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="Provider-init-代码流程"><a href="#Provider-init-代码流程" class="headerlink" title="Provider init 代码流程"></a>Provider init 代码流程</h1><p><img src="/2020/01/01/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera%20Driver/%E9%AB%98%E9%80%9A%20Camx/%E9%AB%98%E9%80%9A%20Camx%20camera%20provider/image-20201021143242020.png" alt="init 代码流程"></p><p>在系统初始化的时候，系统会去运行”<a href="mailto:&#x61;&#110;&#100;&#114;&#111;&#x69;&#x64;&#x2e;&#x68;&#97;&#x72;&#100;&#119;&#x61;&#114;&#101;&#46;&#99;&#97;&#x6d;&#x65;&#114;&#x61;&#x2e;&#112;&#114;&#x6f;&#118;&#x69;&#100;&#101;&#114;&#x40;&#x32;&#x2e;&#52;&#45;&#x73;&#x65;&#114;&#118;&#x69;&#x63;&#101;&#95;&#54;&#52;">&#x61;&#110;&#100;&#114;&#111;&#x69;&#x64;&#x2e;&#x68;&#97;&#x72;&#100;&#119;&#x61;&#114;&#101;&#46;&#99;&#97;&#x6d;&#x65;&#114;&#x61;&#x2e;&#112;&#114;&#x6f;&#118;&#x69;&#100;&#101;&#114;&#x40;&#x32;&#x2e;&#52;&#45;&#x73;&#x65;&#114;&#118;&#x69;&#x63;&#101;&#95;&#54;&#52;</a>“程序启动Provider进程，并加入HW Service Manager中接受统一管理。在改过程中实例化一个 LegacyCameraProviderImpl_2_4 对象，通过 hw_get_module 标准方法 获取HAL 模块。这边指的是 <strong>camera.qcom.so</strong> 。</p><h2 id="Camera-Provider-Init-函数总括"><a href="#Camera-Provider-Init-函数总括" class="headerlink" title="Camera Provider Init 函数总括"></a>Camera Provider Init 函数总括</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hardware/interfaces/camera/provider/2.4/default/LegacyCameraProviderImpl_2_4.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">LegacyCameraProviderImpl_2_4::initialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">camera_module_t</span> *rawModule;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取 camera.qcom.so 可以理解为和 camxhal3entry.cpp 建立联系</span></span><br><span class="line">    <span class="keyword">int</span> err = hw_get_module(CAMERA_HARDWARE_MODULE_ID, (<span class="keyword">const</span> <span class="keyword">hw_module_t</span> **)&amp;rawModule); </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将 camera.qcom.so 获取的句柄保存在 mModule 对象中 ，该函数定义在 CameraModule.cpp </span></span><br><span class="line">    mModule = <span class="keyword">new</span> CameraModule(rawModule);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//我们可以跟进去看看 init() 非常明显 实际就是进行 camx 的初始化，camxhal3entry.cpp  &#123; CAMX:: init()&#125; </span></span><br><span class="line">    <span class="comment">//int CameraModule::init() 这个函数将会调用 getNumberOfCameras() </span></span><br><span class="line">    <span class="comment">//就此 camx-chi 的一系列初始化操作 拉开序幕</span></span><br><span class="line">    err = mModule-&gt;init(); </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置回调函数，用于接受camx-chi的数据和事件</span></span><br><span class="line">    err = mModule-&gt;setCallbacks(<span class="keyword">this</span>);</span><br><span class="line">    </span><br><span class="line">    mNumberOfLegacyCameras = mModule-&gt;getNumberOfCameras();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// mInitFailed</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>init 函数结束之后，Camera Provider进程便一直便存在于系统中,监听着来自Camera Service的调用。</p><h2 id="Camera-Provider-Init-分解"><a href="#Camera-Provider-Init-分解" class="headerlink" title="Camera Provider Init 分解"></a>Camera Provider Init 分解</h2><p>通过上面的总括可以理解为 <strong>Provider</strong> 最终目的获取 <strong>Camx-Chi</strong> 的 <strong>setting</strong> 以及 <strong>HW</strong> 资源。然后保存起来返回给上层，供后面使用。</p><p>二话不说先上一张大图</p><p><img src="/2020/01/01/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera%20Driver/%E9%AB%98%E9%80%9A%20Camx/%E9%AB%98%E9%80%9A%20Camx%20camera%20provider/image-20201026113612765.png"></p><h3 id="get-number-of-cameras-函数介绍"><a href="#get-number-of-cameras-函数介绍" class="headerlink" title="get_number_of_cameras 函数介绍"></a>get_number_of_cameras 函数介绍</h3><p>这个函数是一切美好的开始，她的最先调用就是上面介绍的provide init 函数的 <strong>CameraModule::init()</strong> </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//hardware/interfaces/camera/common/1.0/default/CameraModule.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CameraModule::init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    <span class="keyword">int</span> res = OK;</span><br><span class="line">    <span class="keyword">if</span> (getModuleApiVersion() &gt;= CAMERA_MODULE_API_VERSION_2_4 &amp;&amp;</span><br><span class="line">            mModule-&gt;init != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ATRACE_BEGIN(<span class="string">&quot;camera_module-&gt;init&quot;</span>);</span><br><span class="line">        res = mModule-&gt;init();</span><br><span class="line">        ATRACE_END();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将会走到 vendor/proprietary/camx/src/coer/hal/camxhal3.cpp中</span></span><br><span class="line">    mNumberOfCameras = getNumberOfCameras();</span><br><span class="line">    mCameraInfoMap.setCapacity(mNumberOfCameras);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>CameraModule::init()</strong> ，这个函数调用 <strong>getNumberOfCameras()</strong> 。最终调用到 <strong>get_number_of_cameras()</strong> 这个函数已经是干到camx了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//vendor/proprietary/camx/src/coer/hal/camxhal3.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">get_number_of_cameras</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    INT numCameras;</span><br><span class="line">    <span class="comment">//将会走到 vendor/proprietary/camx/src/coer/hal/camxhal3module.cpp中</span></span><br><span class="line">    <span class="comment">//会调用到 HAL3Module的构造函数</span></span><br><span class="line">    numCameras = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(HAL3Module::GetInstance()-&gt;GetNumCameras());</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> numCameras;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数主要有两个作用：</p><ul><li>是通过 <strong>HAL3Module</strong> 类的构造函数会获取 CAMX-CHI 的信息</li><li>加载 <strong>com.qti.chi.override.so</strong>  模块，映射 CAMX-CHI 之间的接口</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//vendor/proprietary/camx/src/coer/hal/camxhal3module.cpp</span></span><br><span class="line">HAL3Module::HAL3Module()</span><br><span class="line">&#123;</span><br><span class="line">    CamxResult result = CamxResultSuccess;</span><br><span class="line">    CSLCameraPlatform CSLPlatform = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    CAMX_LOG_CONFIG(CamxLogGroupHAL, <span class="string">&quot;***************************************************&quot;</span>);</span><br><span class="line">    CAMX_LOG_CONFIG(CamxLogGroupHAL, <span class="string">&quot;SHA1:     %s&quot;</span>, CAMX_SHA1);</span><br><span class="line">    CAMX_LOG_CONFIG(CamxLogGroupHAL, <span class="string">&quot;COMMITID: %s&quot;</span>, CAMX_COMMITID);</span><br><span class="line">    CAMX_LOG_CONFIG(CamxLogGroupHAL, <span class="string">&quot;BUILD TS: %s&quot;</span>, CAMX_BUILD_TS);</span><br><span class="line">    CAMX_LOG_CONFIG(CamxLogGroupHAL, <span class="string">&quot;***************************************************&quot;</span>);</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">//到了这个位置已经是很亲切了，干到camx了</span></span><br><span class="line">    m_pStaticSettings = HwEnvironment::GetInstance()-&gt;GetStaticSettings();</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="HwEnvironment-Initialize-函数介绍"><a href="#HwEnvironment-Initialize-函数介绍" class="headerlink" title="HwEnvironment::Initialize() 函数介绍"></a>HwEnvironment::Initialize() 函数介绍</h3><p>通过 <strong>HAL3Module</strong> 构造函数会调用 <strong>HwEnvironment</strong> 类的构造，主体功能在 <strong>HwEnvironment::Initialize()</strong> 中实现</p><details><summary>HwEnvironment::Initialize()</summary><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//vendor/proprietary/camx/src/coer/camxhwenvironment.cpp</span></span><br><span class="line"><span class="function">CamxResult <span class="title">HwEnvironment::Initialize</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CamxResult              result                  = CamxResultSuccess;</span><br><span class="line">    CSLInitializeParams     params                  = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    SettingsManager*        pStaticSettingsManager  = SettingsManager::Create(<span class="literal">NULL</span>);</span><br><span class="line">    ExternalComponentInfo*  pExternalComponent      = GetExternalComponent();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> != pStaticSettingsManager)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">const</span> StaticSettings* pStaticSettings = pStaticSettingsManager-&gt;GetStaticSettings();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> != pStaticSettings)</span><br><span class="line">        &#123;</span><br><span class="line">            params.mode                                           = pStaticSettings-&gt;CSLMode;</span><br><span class="line">            params.emulatedSensorParams.enableSensorSimulation    = pStaticSettings-&gt;enableSensorEmulation;</span><br><span class="line">            params.emulatedSensorParams.dumpSensorEmulationOutput = pStaticSettings-&gt;dumpSensorEmulationOutput;</span><br><span class="line"></span><br><span class="line">            OsUtils::StrLCpy(params.emulatedSensorParams.sensorEmulatorPath,</span><br><span class="line">                             pStaticSettings-&gt;sensorEmulatorPath,</span><br><span class="line">                             <span class="keyword">sizeof</span>(pStaticSettings-&gt;sensorEmulatorPath));</span><br><span class="line"></span><br><span class="line">            OsUtils::StrLCpy(params.emulatedSensorParams.sensorEmulator,</span><br><span class="line">                             pStaticSettings-&gt;sensorEmulator,</span><br><span class="line">                             <span class="keyword">sizeof</span>(pStaticSettings-&gt;sensorEmulator));</span><br><span class="line"></span><br><span class="line">            result = CSLInitialize(&amp;params);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (CamxResultSuccess == result)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// Query the camera platform</span></span><br><span class="line">                result = QueryHwContextStaticEntryMethods();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (CamxResultSuccess == result)</span><br><span class="line">            &#123;</span><br><span class="line">                m_pHwFactory = m_staticEntryMethods.CreateHwFactory();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">NULL</span> == m_pHwFactory)</span><br><span class="line">                &#123;</span><br><span class="line">                    CAMX_ASSERT_ALWAYS_MESSAGE(<span class="string">&quot;Failed to create the HW factory&quot;</span>);</span><br><span class="line">                    result = CamxResultEFailed;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (CamxResultSuccess == result)</span><br><span class="line">            &#123;</span><br><span class="line">                m_pSettingsManager = m_pHwFactory-&gt;CreateSettingsManager();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">NULL</span> == m_pSettingsManager)</span><br><span class="line">                &#123;</span><br><span class="line">                    CAMX_ASSERT_ALWAYS_MESSAGE(<span class="string">&quot;Failed to create the HW settings manager&quot;</span>);</span><br><span class="line">                    result = CamxResultEFailed;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (CamxResultSuccess == result)</span><br><span class="line">            &#123;</span><br><span class="line">                m_staticEntryMethods.GetHWBugWorkarounds(&amp;m_workarounds);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pStaticSettingsManager-&gt;Destroy();</span><br><span class="line">        pStaticSettingsManager = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    CAMX_ASSERT(<span class="literal">NULL</span> != pExternalComponent);</span><br><span class="line">    <span class="keyword">if</span> ((CamxResultSuccess == result) &amp;&amp; (<span class="literal">NULL</span> != pExternalComponent))</span><br><span class="line">    &#123;</span><br><span class="line">        result = ProbeChiComponents(pExternalComponent, &amp;m_numExternalComponent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (CamxResultSuccess == result)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Load the OEM sensor capacity customization functions</span></span><br><span class="line">        CAMXCustomizeCAMXInterface camxInterface;</span><br><span class="line">        camxInterface.pGetHWEnvironment = HwEnvironment::GetInstance;</span><br><span class="line">        CAMXCustomizeEntry(&amp;m_pOEMInterface, &amp;camxInterface);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (CamxResultSuccess != result)</span><br><span class="line">    &#123;</span><br><span class="line">        CAMX_LOG_ERROR(CamxLogGroupCore, <span class="string">&quot;FATAL ERROR: Raise SigAbort. HwEnvironment initialization failed&quot;</span>);</span><br><span class="line">        m_numberSensors = <span class="number">0</span>;</span><br><span class="line">        OsUtils::RaiseSignalAbort();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        m_initCapsStatus = InitCapsInitialize;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p>通过上面的代码可以看出 <strong>HwEnvironment::Initialize()</strong> 做的事情还是挺多的。下面我们开始分析</p><ol><li><p>获取camx的相关配置</p><p>SettingsManager*        pStaticSettingsManager  = SettingsManager::Create(NULL);</p><p>经过一系列调用最终会调到以下代码，加载配置参数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//vendor/proprietary/camx/src/coer/camxsettingsmanager.cpp</span></span><br><span class="line"><span class="function">CamxResult <span class="title">SettingsManager::Initialize</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    StaticSettings* pStaticSettings)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ......    </span><br><span class="line">        <span class="comment">// Populate the default settings</span></span><br><span class="line">        InitializeDefaultSettings();</span><br><span class="line">        InitializeDefaultDebugSettings();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Load the override settings from our override settings stores</span></span><br><span class="line">        result = LoadOverrideSettings(m_pOverrideSettingsStore);</span><br><span class="line">        result = LoadOverrideProperties(m_pOverrideSettingsStore, TRUE);</span><br><span class="line">        result = ValidateSettings();</span><br><span class="line"></span><br><span class="line">        DumpSettings();</span><br><span class="line">        m_pOverrideSettingsStore-&gt;DumpOverriddenSettings();</span><br><span class="line">    ......</span><br><span class="line">    UpdateLogSettings();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>利用加载好的配置参数去初始化相关模块</p><p>result = CSLInitialize(&amp;params);</p><p>经过一个跳转表格进入以下代码</p><details><summary>CamxResult CSLInitializeHW()</summary><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//vendor/proprietary/camx/src/csl/hw/camxcslhw.cpp</span></span><br><span class="line"><span class="function">CamxResult <span class="title">CSLInitializeHW</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CamxResult result                          = CamxResultEFailed;</span><br><span class="line">    CHAR       syncDeviceName[CSLHwMaxDevName] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (FALSE == CSLHwIsHwInstanceValid())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (TRUE == CSLHwEnumerateAndAddCSLHwDevice(CSLInternalHwVideodevice, CAM_VNODE_DEVICE_TYPE))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (TRUE == CSLHwEnumerateAndAddCSLHwDevice(CSLInternalHwVideoSubdevice, CAM_CPAS_DEVICE_TYPE))</span><br><span class="line">            &#123;</span><br><span class="line">                CAMX_LOG_VERBOSE(CamxLogGroupCSL, <span class="string">&quot;Platform family=%d, version=%d.%d.%d, cpas version=%d.%d.%d&quot;</span>,</span><br><span class="line">                    g_CSLHwInstance.pCameraPlatform.family,</span><br><span class="line">                    g_CSLHwInstance.pCameraPlatform.platformVersion.majorVersion,</span><br><span class="line">                    g_CSLHwInstance.pCameraPlatform.platformVersion.minorVersion,</span><br><span class="line">                    g_CSLHwInstance.pCameraPlatform.platformVersion.revVersion,</span><br><span class="line">                    g_CSLHwInstance.pCameraPlatform.CPASVersion.majorVersion,</span><br><span class="line">                    g_CSLHwInstance.pCameraPlatform.CPASVersion.minorVersion,</span><br><span class="line">                    g_CSLHwInstance.pCameraPlatform.CPASVersion.revVersion);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (FALSE == CSLHwEnumerateAndAddCSLHwDevice(CSLInternalHwVideoSubdeviceAll, <span class="number">0</span>))</span><br><span class="line">                &#123;</span><br><span class="line">                    CAMX_LOG_ERROR(CamxLogGroupCSL, <span class="string">&quot;No KMD devices found&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    CAMX_LOG_VERBOSE(CamxLogGroupCSL, <span class="string">&quot;Total KMD subdevices found =%d&quot;</span>, g_CSLHwInstance.kmdDeviceCount);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// Init the memory manager data structures here</span></span><br><span class="line">                CamX::Utils::Memset(g_CSLHwInstance.memManager.bufferInfo, <span class="number">0</span>, <span class="keyword">sizeof</span>(g_CSLHwInstance.memManager.bufferInfo));</span><br><span class="line">                <span class="comment">// Init the sync manager here</span></span><br><span class="line">                g_CSLHwInstance.lock-&gt;Lock();</span><br><span class="line">                g_CSLHwInstance.pSyncFW = CamX::SyncManager::GetInstance();</span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">NULL</span> != g_CSLHwInstance.pSyncFW)</span><br><span class="line">                &#123;</span><br><span class="line">                    CSLHwGetSyncHwDevice(syncDeviceName, CSLHwMaxDevName);</span><br><span class="line">                    CAMX_LOG_VERBOSE(CamxLogGroupCSL, <span class="string">&quot;Sync device found = %s&quot;</span>, syncDeviceName);</span><br><span class="line">                    result = g_CSLHwInstance.pSyncFW-&gt;Initialize(syncDeviceName);</span><br><span class="line">                    <span class="keyword">if</span> (CamxResultSuccess != result)</span><br><span class="line">                    &#123;</span><br><span class="line">                        CAMX_LOG_ERROR(CamxLogGroupCSL, <span class="string">&quot;CSL failed to initialize SyncFW&quot;</span>);</span><br><span class="line">                        result = g_CSLHwInstance.pSyncFW-&gt;Destroy();</span><br><span class="line">                        g_CSLHwInstance.pSyncFW = <span class="literal">NULL</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                g_CSLHwInstance.lock-&gt;Unlock();</span><br><span class="line">                CSLHwInstanceSetState(CSLHwValidState);</span><br><span class="line">                result = CamxResultSuccess;</span><br><span class="line">                CAMX_LOG_VERBOSE(CamxLogGroupCSL, <span class="string">&quot;Successfully acquired requestManager&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                CAMX_LOG_ERROR(CamxLogGroupCSL, <span class="string">&quot;Failed to acquire CPAS&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            CAMX_LOG_ERROR(CamxLogGroupCSL, <span class="string">&quot;Failed to acquire requestManager invalid&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        CAMX_LOG_ERROR(CamxLogGroupCSL, <span class="string">&quot;CSL in Invalid State&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p>这一部分我个人理解为，遍历所有kernel端的设备。获取相关接口以及需要的事件。与HAL层建立联系。具体分析以后可以单独写一篇文章分析</p></li><li><p>根据平台获取对应的入口方法</p><p>这个暂时不知道是个什么鬼，先这样理解</p><p>result = QueryHwContextStaticEntryMethods();</p><p>经过一系列的调用最终是跑到了这里</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//vendor/proprietary/camx/src/csl/hwl/titan17x/camxtitan17xhwl.cpp</span></span><br><span class="line"><span class="function">CamxResult <span class="title">Titan17xGetStaticEntryMethods</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    HwContextStaticEntry* pStaticEntry)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CamxResult result = CamxResultSuccess;</span><br><span class="line"></span><br><span class="line">    pStaticEntry-&gt;Create                               = &amp;Titan17xContext::Create;</span><br><span class="line">    pStaticEntry-&gt;GetStaticMetadataKeysInfo            = &amp;Titan17xContext::GetStaticMetadataKeysInfo;</span><br><span class="line">    pStaticEntry-&gt;GetStaticCaps                        = &amp;Titan17xContext::GetStaticCaps;</span><br><span class="line">    pStaticEntry-&gt;CreateHwFactory                      = &amp;Titan17xFactory::Create;</span><br><span class="line">    pStaticEntry-&gt;QueryVendorTagsInfo                  = &amp;Titan17xContext::QueryVendorTagsInfo;</span><br><span class="line">    pStaticEntry-&gt;GetHWBugWorkarounds                  = &amp;Titan17xContext::GetHWBugWorkarounds;</span><br><span class="line">    pStaticEntry-&gt;QueryExternalComponentVendorTagsInfo = &amp;Titan17xContext::QueryExternalComponentVendorTagsInfo;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>获取CHI各个节点的接口</p><p>result = ProbeChiComponents(pExternalComponent, &amp;m_numExternalComponent);</p><p>遍历所有chi相关的.so库，将各个接口保存起来。这一块的代码撸的比较少，先记录这么多</p></li></ol><p>到此处 HwEnvironment::Initialize() 这个函数就介绍的差不多了。日后慢慢完善</p><h3 id="HwEnvironment-InitCaps-函数介绍"><a href="#HwEnvironment-InitCaps-函数介绍" class="headerlink" title="HwEnvironment::InitCaps()  函数介绍"></a>HwEnvironment::InitCaps()  函数介绍</h3><details><summary>HwEnvironment::InitCaps()</summary><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//vendor/proprietary/camx/src/coer/camxhwenvironment.cpp</span></span><br><span class="line"><span class="function">VOID <span class="title">HwEnvironment::InitCaps</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CamxResult    result = CamxResultSuccess;</span><br><span class="line"></span><br><span class="line">    m_pHWEnvLock-&gt;Lock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (InitCapsRunning == m_initCapsStatus ||</span><br><span class="line">        InitCapsDone == m_initCapsStatus)</span><br><span class="line">    &#123;</span><br><span class="line">        m_pHWEnvLock-&gt;Unlock();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    m_initCapsStatus = InitCapsRunning;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (CamxResultSuccess == result)</span><br><span class="line">    &#123;</span><br><span class="line">        EnumerateDevices();</span><br><span class="line">        ProbeImageSensorModules();</span><br><span class="line">        EnumerateSensorDevices();</span><br><span class="line">        InitializeSensorSubModules();</span><br><span class="line">        InitializeSensorStaticCaps();</span><br><span class="line"></span><br><span class="line">        result = m_staticEntryMethods.GetStaticCaps(&amp;m_platformCaps[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">// copy the static capacity to remaining sensor&#x27;s</span></span><br><span class="line">        <span class="keyword">for</span> (UINT index = <span class="number">1</span>; index &lt; m_numberSensors; index++)</span><br><span class="line">        &#123;</span><br><span class="line">            Utils::Memcpy(&amp;m_platformCaps[index], &amp;m_platformCaps[<span class="number">0</span>], <span class="keyword">sizeof</span>(m_platformCaps[<span class="number">0</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> != m_pOEMInterface-&gt;pInitializeExtendedPlatformStaticCaps)</span><br><span class="line">        &#123;</span><br><span class="line">            m_pOEMInterface-&gt;pInitializeExtendedPlatformStaticCaps(&amp;m_platformCaps[<span class="number">0</span>], m_numberSensors);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    CAMX_ASSERT(CamxResultSuccess == result);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (CamxResultSuccess == result)</span><br><span class="line">    &#123;</span><br><span class="line">        InitializeHwEnvironmentStaticCaps();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    m_initCapsStatus = InitCapsDone;</span><br><span class="line"></span><br><span class="line">    m_pHWEnvLock-&gt;Unlock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><p>这一波操作应该就是枚举各个Camera模组，检测硬件是否可以通信成功。</p><ol><li><p>Probe Sensor </p><p>经过上述函数中 ProbeImageSensorModules() 会走到  ImageSensorModuleData::Probe()</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//vendor/proprietary/camx/src/core/camximagesensormoduledata.cpp</span></span><br><span class="line"><span class="function">CamxResult <span class="title">ImageSensorModuleData::Probe</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">                                                         BOOL*   pDetected,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                         INT32*  pDeviceIndex)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">//获取上下电时序</span></span><br><span class="line">    UINT powerUpCmdSize     = GetSensorDataObject()-&gt;GetPowerSequenceCmdSize(TRUE);</span><br><span class="line">    UINT powerDownCmdSize   = GetSensorDataObject()-&gt;GetPowerSequenceCmdSize(FALSE);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建命令包管理</span></span><br><span class="line">    result = CmdBufferManager::Create(<span class="string">&quot;ImageSensorPacketManager&quot;</span>, &amp;packetResourceParams, &amp;pPacketManager);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//向CSL下发probe命令</span></span><br><span class="line">    result = CSLImageSensorProbe(pProbePacket-&gt;GetMemHandle(), pProbePacket-&gt;GetOffset(), &amp;probeResult);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数的主要作用就是创建probe sensor 的命令包，然后下发到CSL</p><p>将命令包提交到 CSL 通过ioctl下发到 Kernel</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//vendor/qcom/proprietary/camx/src/csl/hw/camxcslhwinternalsensor.cpp</span></span><br><span class="line"><span class="function">CamxResult <span class="title">CSLHwInternalProbeSensorHW</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">                                          CSLMemHandle hPacket,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          SIZE_T       offset,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          INT32*       pDeviceIndex)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    ioctlCmd.op_code     = CAM_SENSOR_PROBE_CMD;</span><br><span class="line">    ioctlCmd.size        = <span class="keyword">sizeof</span>(ioctlCmd.handle);</span><br><span class="line">    ioctlCmd.handle_type = CAM_HANDLE_MEM_HANDLE;</span><br><span class="line">    ioctlCmd.reserved    = <span class="number">0</span>;</span><br><span class="line">    ioctlCmd.handle      = hPacket;</span><br><span class="line">    result = pLoophw-&gt;deviceOp.Ioctl(pLoophw, VIDIOC_CAM_CONTROL, &amp;ioctlCmd);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;概览&quot;&gt;&lt;a href=&quot;#概览&quot; class=&quot;headerlink&quot; title=&quot;概览&quot;&gt;&lt;/a&gt;概览&lt;/h1&gt;&lt;img src=&quot;/2020/01/01/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera%20Drive</summary>
      
    
    
    
    <category term="技术研发" scheme="https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/"/>
    
    <category term="Camera Driver" scheme="https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera-Driver/"/>
    
    <category term="高通 Camx" scheme="https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera-Driver/%E9%AB%98%E9%80%9A-Camx/"/>
    
    
    <category term="高通Camx" scheme="https://zh-wiki.github.io/tags/%E9%AB%98%E9%80%9ACamx/"/>
    
  </entry>
  
  <entry>
    <title>Hexo 博客搭建</title>
    <link href="https://zh-wiki.github.io/2020/01/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Hexo%20%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    <id>https://zh-wiki.github.io/2020/01/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Hexo%20%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</id>
    <published>2019-12-31T16:00:01.000Z</published>
    <updated>2020-10-23T06:20:18.636Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo npm install --unsafe-perm --verbose -g hexo</span><br></pre></td></tr></table></figure><h2 id="同步本地图片与网络图片"><a href="#同步本地图片与网络图片" class="headerlink" title="同步本地图片与网络图片"></a>同步本地图片与网络图片</h2><ol><li><p>安装插件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install https://github.com/CodeFalling/hexo-asset-image --save</span><br></pre></td></tr></table></figure></li><li><p>配置Typora</p><p><img src="/2020/01/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Hexo%20%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/image-20201005210350281.png" alt="image-20201005210350281"></p></li><li><p>编译</p><p>有以下log说明配置成功</p><img src="/2020/01/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Hexo%20%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/image-20201005165756877.png"></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;安装-Hexo&quot;&gt;&lt;a href=&quot;#安装-Hexo&quot; class=&quot;headerlink&quot; title=&quot;安装 Hexo&quot;&gt;&lt;/a&gt;安装 Hexo&lt;/h2&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;</summary>
      
    
    
    
    <category term="计算机基础知识" scheme="https://zh-wiki.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="Hexo" scheme="https://zh-wiki.github.io/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>自动对焦专讲</title>
    <link href="https://zh-wiki.github.io/2020/01/01/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera%20%E4%B8%93%E4%B8%9A%E7%9F%A5%E8%AF%86/%E8%87%AA%E5%8A%A8%E5%AF%B9%E7%84%A6/"/>
    <id>https://zh-wiki.github.io/2020/01/01/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera%20%E4%B8%93%E4%B8%9A%E7%9F%A5%E8%AF%86/%E8%87%AA%E5%8A%A8%E5%AF%B9%E7%84%A6/</id>
    <published>2019-12-31T16:00:01.000Z</published>
    <updated>2020-12-10T05:52:58.071Z</updated>
    
    <content type="html"><![CDATA[<h1 id="自动对焦的工作原理"><a href="#自动对焦的工作原理" class="headerlink" title="自动对焦的工作原理"></a>自动对焦的工作原理</h1><hr><ul><li>AF的对焦原理是通过电磁感应使镜头移动，改变焦距完成自动对焦。</li></ul><p><img src="/2020/01/01/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera%20%E4%B8%93%E4%B8%9A%E7%9F%A5%E8%AF%86/%E8%87%AA%E5%8A%A8%E5%AF%B9%E7%84%A6/image-20201210112852132-1607571037074.png" alt="自动对焦"></p><ul><li><p>VCM 实现对焦原理</p><p>进入自动对焦（AF）模式后，Driver IC输出电流从0到最大值，使得镜头从原始位置移动到最大位置，此时ISP通过sensor成像，计算每一副图片的MTF（Modulation transfer function）值，从而在这条MTF曲线中找到最大值（<strong>即图像最清晰的点</strong>），并通过算法，得到这个点对应的电流大小，再一次指示Driver IC提供给音圈这个电流，而使镜头稳定在这个成像面，达到自动变焦效果。</p><p>AF的目的是确定实现对焦的最佳镜头位置，并触发VCM将镜头移动到该位置。一般来说，AF过程如下：</p><ol><li>AF算法同时检测硬件和软件统计数据，以确定是否存在场景变化。</li><li>如果算法检测到场景变化，则算法触发搜索。</li><li>算法的粗搜索确定下一个镜头位置。</li><li>VCM逐渐将镜头移动到下一个位置。</li><li>精搜索找到最终的镜头位置。</li><li>VCM将镜头移动到最终位置。</li></ol><p>AF对焦方式分为：对比度/反差对焦(CAF)、相位对焦(PDAF)、激光对焦(TOFAF)，每种算法都实现了检测和搜索功能。</p></li></ul><h1 id="反差对焦-CAF"><a href="#反差对焦-CAF" class="headerlink" title="反差对焦  CAF"></a>反差对焦  CAF</h1><hr><p>对比度对焦，也叫反差对焦。反差对焦是目前普及率最高，使用最广泛，成本相对较低的自动对焦技术。对焦的过程就是通过移动镜片来使对焦区域的图像达到最清晰的过程，所以对焦成功以后，直观的感受就是焦点的清晰度最高，而焦点以外的区域则表现为相对模糊状态。因为<strong>反差对焦的工作方式是进行对比度检测</strong>，因此相机镜片必须要前后移动完整记录所有的图像信息，然后计算出对比度最高的位置，才能最终完成对焦，所以反差对焦的一个主要缺点就是耗费的时间较长。</p><p><img src="/2020/01/01/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera%20%E4%B8%93%E4%B8%9A%E7%9F%A5%E8%AF%86/%E8%87%AA%E5%8A%A8%E5%AF%B9%E7%84%A6/20200802010227222.png" alt="反差对焦"></p><h1 id="相位差对焦-PDAF"><a href="#相位差对焦-PDAF" class="headerlink" title="相位差对焦 PDAF"></a>相位差对焦 PDAF</h1><hr><p>相位对焦，是在像素传感器上拿出左右相对的成对像素点，分别对场景中的物体进行进光量等信息的检测，通过比对左右两侧的相关值情况，便会迅速找出准确的对焦点，之后镜间马达便会一次性将镜片推动到相应位置完成对焦。相位对焦也并不是十分完美，它对光线的要求就比较高，在弱光拍摄环境下，相位对焦就无能为力了。</p><p><img src="/2020/01/01/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera%20%E4%B8%93%E4%B8%9A%E7%9F%A5%E8%AF%86/%E8%87%AA%E5%8A%A8%E5%AF%B9%E7%84%A6/image-20201210114809533.png" alt="相位差对焦"></p><p>物体的某一个点会从各个方向发出光线通过镜片成像到snesor上面去，只有当不同方向的光线成像落到sensor的同一个位置的时候才是像差最小的时候：</p><p>上图中，紫色是物体的一个点，黄色是sensor即成像面，1号蓝色镜片离sensor太远，上下两条光线所成的像没有重合；2号蓝色镜片和snesor的距离合适，上下两条光线所成的像重合了没有相差，所以对焦成功；3、4号蓝色镜片离sensor的距离太近了，上下两条光线所成的像没有重合，但是和1号不同的是相差的方向是不一样的。</p><p>通过<strong>计算相位差并将其转换为defocus(离焦)值</strong>，以指示实现聚焦所需的镜头移动的大小和方向。正defocus值意味着运动由近到远，负defocus值意味着运动从远到近。当defocus值接近零时，表示目标处于焦点。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;自动对焦的工作原理&quot;&gt;&lt;a href=&quot;#自动对焦的工作原理&quot; class=&quot;headerlink&quot; title=&quot;自动对焦的工作原理&quot;&gt;&lt;/a&gt;自动对焦的工作原理&lt;/h1&gt;&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;AF的对焦原理是通过电磁感应使镜头移动，改变焦距完成自动对焦。</summary>
      
    
    
    
    <category term="技术研发" scheme="https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/"/>
    
    <category term="Camera 专业知识" scheme="https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera-%E4%B8%93%E4%B8%9A%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="Camera" scheme="https://zh-wiki.github.io/tags/Camera/"/>
    
  </entry>
  
  <entry>
    <title>Git 常用命令</title>
    <link href="https://zh-wiki.github.io/2020/01/01/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Linux%20%E5%91%BD%E4%BB%A4/Git%20%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>https://zh-wiki.github.io/2020/01/01/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Linux%20%E5%91%BD%E4%BB%A4/Git%20%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</id>
    <published>2019-12-31T16:00:01.000Z</published>
    <updated>2020-11-19T08:59:52.084Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h1><ol><li><p>所有的命令输出在同一页显示</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global core.pager <span class="string">&#x27;&#x27;</span></span><br></pre></td></tr></table></figure></li></ol><h1 id="撤销指令"><a href="#撤销指令" class="headerlink" title="撤销指令"></a>撤销指令</h1><ol><li>撤销工作区的修改<br> <strong>git checkout</strong> 文件名<br> <strong>git checkout</strong> 目录 -f</li><li>从暂存区撤销到工作区（可以理解为<strong>git add</strong>的反向动作）<br> <strong>git reset HEAD</strong></li><li>从版本库撤销到暂存区<br> <strong>git reset –soft HEAD^</strong></li><li>从版本库撤销到工作区<br> <strong>git reset –mixed HEAD^</strong></li><li>撤销到上一次提交（本地修改丢失）<br> <strong>git reset –hard HEAD^</strong></li></ol><h1 id="保存恢复指令"><a href="#保存恢复指令" class="headerlink" title="保存恢复指令"></a>保存恢复指令</h1><ol><li>保存本地未追踪的修改<br>  <strong>git stash save</strong> 路径</li><li>将保存的内容导出<br> <strong>git stash pop stash@{index}</strong></li><li>获取保存列表<br>  <strong>git stash list</strong></li></ol><h1 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h1><p>这里我分为两种情况：</p><ol><li><p>代码提到服务器上。<br> a. 首先把自己的提交reset掉。<br> b.更新代码<br> c.将自己的代码从服务器上拉下来。<br> d.冲突用code工具解决掉。然后add 修改文件，重新commit</p></li><li><p>代码在本地提交<br> a.将本地提交撤回到工作区。<br> b.保存本地修改<br> c.更新代码<br> d.将保存的代码还原。<br> e.冲突用code工具解决掉。然后add 修改文件，重新commit</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;基本配置&quot;&gt;&lt;a href=&quot;#基本配置&quot; class=&quot;headerlink&quot; title=&quot;基本配置&quot;&gt;&lt;/a&gt;基本配置&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;所有的命令输出在同一页显示&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;tab</summary>
      
    
    
    
    <category term="技术研发" scheme="https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/"/>
    
    <category term="Linux 命令" scheme="https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Linux-%E5%91%BD%E4%BB%A4/"/>
    
    
    <category term="Linux 命令" scheme="https://zh-wiki.github.io/tags/Linux-%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>三星o1o2o3项目随笔</title>
    <link href="https://zh-wiki.github.io/2020/01/01/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/%E9%A1%B9%E7%9B%AE%E9%9A%8F%E7%AC%94/%E4%B8%89%E6%98%9Fo1o2o3%E9%A1%B9%E7%9B%AE%E9%9A%8F%E7%AC%94/"/>
    <id>https://zh-wiki.github.io/2020/01/01/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/%E9%A1%B9%E7%9B%AE%E9%9A%8F%E7%AC%94/%E4%B8%89%E6%98%9Fo1o2o3%E9%A1%B9%E7%9B%AE%E9%9A%8F%E7%AC%94/</id>
    <published>2019-12-31T16:00:01.000Z</published>
    <updated>2020-11-29T11:19:30.586Z</updated>
    
    <content type="html"><![CDATA[<h1 id="项目相关"><a href="#项目相关" class="headerlink" title="项目相关"></a>项目相关</h1><ol><li><p>平台</p><p>高通 sdm439 mm-camera 架构</p></li><li><p>PLM 账号密码 </p><p>登录网址（IE浏览器）：<a href="http://myproject.samsungmobile.com/">http://myproject.samsungmobile.com</a></p><p>账号：junwei2</p><p>密码：ZJWzhq1314</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;项目相关&quot;&gt;&lt;a href=&quot;#项目相关&quot; class=&quot;headerlink&quot; title=&quot;项目相关&quot;&gt;&lt;/a&gt;项目相关&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;平台&lt;/p&gt;
&lt;p&gt;高通 sdm439 mm-camera 架构&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;PLM</summary>
      
    
    
    
    <category term="技术研发" scheme="https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/"/>
    
    <category term="项目随笔" scheme="https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/%E9%A1%B9%E7%9B%AE%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="项目随笔" scheme="https://zh-wiki.github.io/tags/%E9%A1%B9%E7%9B%AE%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>高通 Camx camera server</title>
    <link href="https://zh-wiki.github.io/2020/01/01/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera%20Driver/%E9%AB%98%E9%80%9A%20Camx/%E9%AB%98%E9%80%9A%20Camx%20camera%20server/"/>
    <id>https://zh-wiki.github.io/2020/01/01/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera%20Driver/%E9%AB%98%E9%80%9A%20Camx/%E9%AB%98%E9%80%9A%20Camx%20camera%20server/</id>
    <published>2019-12-31T16:00:01.000Z</published>
    <updated>2020-11-16T09:25:36.027Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Camera-Server"><a href="#Camera-Server" class="headerlink" title="Camera Server"></a>Camera Server</h3><p>Camera Server 是一个独立的进程，对上通过AIDL来完成 Camera Framework 的一些请求；对下通过HIDL 将上层发下来的请求提交给 Camera Provider。</p><p>Camera Server 对 Camera Framework 而言属于 服务端</p><p>Camera Server 对 Camera Provider 而言属于 客户端</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Camera-Server&quot;&gt;&lt;a href=&quot;#Camera-Server&quot; class=&quot;headerlink&quot; title=&quot;Camera Server&quot;&gt;&lt;/a&gt;Camera Server&lt;/h3&gt;&lt;p&gt;Camera Server 是一个独立的进程，对上通</summary>
      
    
    
    
    <category term="技术研发" scheme="https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/"/>
    
    <category term="Camera Driver" scheme="https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera-Driver/"/>
    
    <category term="高通 Camx" scheme="https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera-Driver/%E9%AB%98%E9%80%9A-Camx/"/>
    
    
    <category term="高通Camx" scheme="https://zh-wiki.github.io/tags/%E9%AB%98%E9%80%9ACamx/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu 开发环境的搭建</title>
    <link href="https://zh-wiki.github.io/2020/01/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Ubuntu%20%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E7%9A%84%E6%90%AD%E5%BB%BA/"/>
    <id>https://zh-wiki.github.io/2020/01/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Ubuntu%20%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E7%9A%84%E6%90%AD%E5%BB%BA/</id>
    <published>2019-12-31T16:00:00.000Z</published>
    <updated>2020-12-04T06:06:28.219Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Samba-服务共享目录"><a href="#Samba-服务共享目录" class="headerlink" title="Samba 服务共享目录"></a>Samba 服务共享目录</h1><p>添加以下配置 /etc/samba/smb.conf</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[文件夹名]</span><br><span class="line">path = <span class="comment">#目录路径</span></span><br><span class="line">browseable = ye   <span class="comment">#可查看共享文件</span></span><br><span class="line">guest ok = yes        <span class="comment">#所有人均可访问共享目录</span></span><br><span class="line">writable = yes        <span class="comment">#允许写入</span></span><br><span class="line">public = yes            <span class="comment">#允许匿名用户访问</span></span><br></pre></td></tr></table></figure><p>配置结束重启服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo service smbd restart</span><br></pre></td></tr></table></figure><h1 id="ubuntu18-04-virtualBox-windows-支持usb"><a href="#ubuntu18-04-virtualBox-windows-支持usb" class="headerlink" title="ubuntu18.04 virtualBox windows 支持usb"></a>ubuntu18.04 virtualBox windows 支持usb</h1><ol><li><p>执行命令<br>sudo usermod -aG vboxusers 用户名（让virtualbox 能识别到主机的usb）</p></li><li><p>cat /etc/group | grep vboxusers （查看是否已经添加成功）</p></li><li><p>下载插件 <a href="https://download.java.net/virtualbox/">下载链接</a>.</p></li><li><p>下载插件比较慢，已经提前下载好的。适用于（virtualbox 5.2.34) </p></li><li><p>安装插件</p><p><img src="/2020/01/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Ubuntu%20%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E7%9A%84%E6%90%AD%E5%BB%BA/image-20201111105153041.png" alt="操作示意图"></p></li><li><p>设置 USB 协议的支持</p><p><img src="/2020/01/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Ubuntu%20%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E7%9A%84%E6%90%AD%E5%BB%BA/image-20201111105232574.png" alt="操作示意图"></p></li><li><p>reboot （重启ubuntu）</p></li><li><p>如果重启电脑之后，虚拟机可以扫描到USB设备，但是Ｗin7中提示驱动未能安装成功。<br>解决方法：<br>下载驱动精灵。安装USB驱动。</p></li></ol><h1 id="VirtualBox-修复’modprobe-vboxdrv’-报错"><a href="#VirtualBox-修复’modprobe-vboxdrv’-报错" class="headerlink" title="VirtualBox 修复’modprobe vboxdrv’ 报错"></a>VirtualBox 修复’modprobe vboxdrv’ 报错</h1><ol><li><p>问题发生背景 </p><p>Linux 内核版本升级之后，virtualbox 的驱动没有更新成功。</p></li><li><p>解决方法</p><p>a.更新整个系统</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt upgrade</span><br></pre></td></tr></table></figure><p>b.重新安装对应内核版本的头文件,和virtualbox的驱动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install --reinstall linux-headers-$(uname -r) virtualbox-dkms dkms</span><br></pre></td></tr></table></figure><p>c.加载驱动重启</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo modprobe vboxdrv</span><br><span class="line">reboot</span><br></pre></td></tr></table></figure></li></ol><ol start="3"><li><p>注意事项</p><p>更新驱动的时候，会重新编译驱动，所以要选择对应的gcc编译器，太老的估计会凉。</p></li></ol><h1 id="支持多版本的gcc"><a href="#支持多版本的gcc" class="headerlink" title="支持多版本的gcc"></a>支持多版本的gcc</h1><ol><li><p>系统安装ok后默认gcc 版本是 v-7.x。我们先搞一个低版本的gcc</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install gcc-4.8</span><br><span class="line">sudo apt-get install g++-4.8</span><br><span class="line">sudo ln -sf /usr/bin/g++-4.8 /usr/bin/g++</span><br><span class="line">sudo ln -sf /usr/bin/gcc-4.8 /usr/bin/gcc</span><br></pre></td></tr></table></figure></li><li><p>管理多个版本的gcc</p><p>a.查看存在几个版本的gcc</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -l /usr/bin/gcc</span><br></pre></td></tr></table></figure><p>b.分别为gcc和g++添加管理组</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-4.8 40</span><br><span class="line">sudo update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++-4.8 40</span><br></pre></td></tr></table></figure><p>c.能添加就能删除,从管理组中删除</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo update-alternatives --remove gcc /usr/bin/gcc-4.8</span><br></pre></td></tr></table></figure></li><li><p>设置ok使用以下指令选择gcc的版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo update-alternatives --config gcc</span><br><span class="line">sudo update-alternatives --config g++</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Samba-服务共享目录&quot;&gt;&lt;a href=&quot;#Samba-服务共享目录&quot; class=&quot;headerlink&quot; title=&quot;Samba 服务共享目录&quot;&gt;&lt;/a&gt;Samba 服务共享目录&lt;/h1&gt;&lt;p&gt;添加以下配置 /etc/samba/smb.conf&lt;/p&gt;</summary>
      
    
    
    
    <category term="计算机基础知识" scheme="https://zh-wiki.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="Ubuntu" scheme="https://zh-wiki.github.io/tags/Ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>Android 研发总结</title>
    <link href="https://zh-wiki.github.io/2020/01/01/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Android%20%E7%A0%94%E5%8F%91%E6%80%BB%E7%BB%93/%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/"/>
    <id>https://zh-wiki.github.io/2020/01/01/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Android%20%E7%A0%94%E5%8F%91%E6%80%BB%E7%BB%93/%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/</id>
    <published>2019-12-31T16:00:00.000Z</published>
    <updated>2020-12-09T03:22:02.301Z</updated>
    
    <content type="html"><![CDATA[<h1 id="在makefile中添加条件判断"><a href="#在makefile中添加条件判断" class="headerlink" title="在makefile中添加条件判断"></a>在makefile中添加条件判断</h1><p>如果 <strong>TARGET_PRODUCT</strong> 等于 <strong>lime</strong> 或者 <strong>citrus</strong> 就走<strong>if</strong> 否则走 <strong>else</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(TARGET_PRODUCT)</span>, <span class="variable">$(<span class="built_in">filter</span> <span class="variable">$(TARGET_PRODUCT)</span>, lime citrus)</span>)</span><br><span class="line">COMPOSER_TARGET_INPUT  := <span class="variable">$(CAMX_PATH)</span>/src/settings/<span class="variable">$(TARGET_PRODUCT)</span>/camxsettings.xml</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">COMPOSER_TARGET_INPUT  := <span class="variable">$(CAMX_PATH)</span>/src/settings/<span class="variable">$(TARGET_BOARD_PLATFORM)</span>/camxsettings.xml</span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure><h1 id="在makefile添加打印log"><a href="#在makefile添加打印log" class="headerlink" title="在makefile添加打印log"></a>在makefile添加打印log</h1><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#打印字符串</span></span><br><span class="line"><span class="variable">$(<span class="built_in">warning</span> &quot;wocao&quot;)</span></span><br><span class="line"><span class="comment">#打印变量</span></span><br><span class="line"><span class="variable">$(<span class="built_in">warning</span> $(变量名)</span>)</span><br></pre></td></tr></table></figure><h1 id="如何编译-selinux"><a href="#如何编译-selinux" class="headerlink" title="如何编译 selinux"></a>如何编译 selinux</h1><ol><li>编译命令</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make selinux_policy</span><br></pre></td></tr></table></figure><ol start="2"><li><p>生成的文件</p><p>path : out/target/product/lime/vendor/etc/selinux</p></li></ol><h1 id="如何将最近指定时间-45min-内生成的文件-push-到-指定-的路径"><a href="#如何将最近指定时间-45min-内生成的文件-push-到-指定-的路径" class="headerlink" title="如何将最近指定时间(45min)内生成的文件 push 到 指定 的路径"></a>如何将最近指定时间(45min)内生成的文件 push 到 指定 的路径</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -mmin -45 -<span class="built_in">type</span> f|grep -v SHARED_LIBRARIES|grep -v STATIC_LIBRARIES|grep -Ei <span class="string">&quot;so|bin&quot;</span>|grep -v symbols|xargs -t -I <span class="string">&#x27;&#123;&#125;&#x27;</span> adb push &#123;&#125; /vendor/lib64/&#123;&#125;</span><br></pre></td></tr></table></figure><h1 id="如何在安卓中自定义-log"><a href="#如何在安卓中自定义-log" class="headerlink" title="如何在安卓中自定义 log"></a>如何在安卓中自定义 log</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;android/log.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GC02M1B_DBG(fmt, args...) __android_log_print(ANDROID_LOG_ERROR, <span class="meta-string">&quot;GC02M1B&quot;</span>,fmt, ##args)</span></span><br></pre></td></tr></table></figure><h1 id="Trace-的使用"><a href="#Trace-的使用" class="headerlink" title="Trace 的使用"></a>Trace 的使用</h1><ol><li><p>systrace.py 的路径</p><p>path：项目代码/native/external/chromium-trace</p></li><li><p>如何打开 trace 的 html</p><p>在谷歌浏览器输入 chrome://tracing/</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;在makefile中添加条件判断&quot;&gt;&lt;a href=&quot;#在makefile中添加条件判断&quot; class=&quot;headerlink&quot; title=&quot;在makefile中添加条件判断&quot;&gt;&lt;/a&gt;在makefile中添加条件判断&lt;/h1&gt;&lt;p&gt;如果 &lt;strong&gt;TAR</summary>
      
    
    
    
    <category term="技术研发" scheme="https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/"/>
    
    <category term="Android 研发总结" scheme="https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Android-%E7%A0%94%E5%8F%91%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="Android" scheme="https://zh-wiki.github.io/tags/Android/"/>
    
  </entry>
  
</feed>
