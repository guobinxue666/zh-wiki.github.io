<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Zhou&#39;s Wiki</title>
  
  
  <link href="https://zh-wiki.github.io/atom.xml" rel="self"/>
  
  <link href="https://zh-wiki.github.io/"/>
  <updated>2020-10-29T09:34:37.547Z</updated>
  <id>https://zh-wiki.github.io/</id>
  
  <author>
    <name>Zhoujunwei</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Welcome Zhou jun wei&#39;s Wiki Site</title>
    <link href="https://zh-wiki.github.io/2020/10/05/index/"/>
    <id>https://zh-wiki.github.io/2020/10/05/index/</id>
    <published>2020-10-05T08:27:35.037Z</published>
    <updated>2020-10-29T09:34:37.547Z</updated>
    
    <content type="html"><![CDATA[<img src="/2020/10/05/index/index.jpg" alt="维基百科" style="zoom:200%;">]]></content>
    
    
      
      
    <summary type="html">&lt;img src=&quot;/2020/10/05/index/index.jpg&quot; alt=&quot;维基百科&quot; style=&quot;zoom:200%;&quot;&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>生活学习</title>
    <link href="https://zh-wiki.github.io/2020/10/04/%E7%94%9F%E6%B4%BB%E5%AD%A6%E4%B9%A0/%E7%94%9F%E6%B4%BB%E5%AD%A6%E4%B9%A0/"/>
    <id>https://zh-wiki.github.io/2020/10/04/%E7%94%9F%E6%B4%BB%E5%AD%A6%E4%B9%A0/%E7%94%9F%E6%B4%BB%E5%AD%A6%E4%B9%A0/</id>
    <published>2020-10-04T08:22:36.000Z</published>
    <updated>2020-10-05T08:27:35.037Z</updated>
    
    
    
    
    <category term="生活学习" scheme="https://zh-wiki.github.io/categories/%E7%94%9F%E6%B4%BB%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>艺术</title>
    <link href="https://zh-wiki.github.io/2020/10/04/%E8%89%BA%E6%9C%AF/%E8%89%BA%E6%9C%AF/"/>
    <id>https://zh-wiki.github.io/2020/10/04/%E8%89%BA%E6%9C%AF/%E8%89%BA%E6%9C%AF/</id>
    <published>2020-10-04T08:22:36.000Z</published>
    <updated>2020-10-05T08:27:35.037Z</updated>
    
    
    
    
    <category term="艺术" scheme="https://zh-wiki.github.io/categories/%E8%89%BA%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>c++</title>
    <link href="https://zh-wiki.github.io/2020/09/29/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/C++/c++/"/>
    <id>https://zh-wiki.github.io/2020/09/29/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/C++/c++/</id>
    <published>2020-09-29T15:23:24.000Z</published>
    <updated>2020-10-23T06:20:33.092Z</updated>
    
    
    
    
    <category term="程序语言" scheme="https://zh-wiki.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"/>
    
    <category term="C++" scheme="https://zh-wiki.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/C/"/>
    
    
    <category term="c++" scheme="https://zh-wiki.github.io/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>UML</title>
    <link href="https://zh-wiki.github.io/2020/09/29/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/UML/UML/"/>
    <id>https://zh-wiki.github.io/2020/09/29/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/UML/UML/</id>
    <published>2020-09-29T15:23:24.000Z</published>
    <updated>2020-10-23T06:20:45.260Z</updated>
    
    
    
    
    <category term="程序语言" scheme="https://zh-wiki.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"/>
    
    <category term="UML" scheme="https://zh-wiki.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/UML/"/>
    
    
    <category term="UML" scheme="https://zh-wiki.github.io/tags/UML/"/>
    
  </entry>
  
  <entry>
    <title>高通 Camx 问题总结</title>
    <link href="https://zh-wiki.github.io/2020/01/01/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera%20Driver/%E9%AB%98%E9%80%9A%20Camx/%E9%AB%98%E9%80%9A%20Camx%20%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <id>https://zh-wiki.github.io/2020/01/01/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera%20Driver/%E9%AB%98%E9%80%9A%20Camx/%E9%AB%98%E9%80%9A%20Camx%20%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</id>
    <published>2019-12-31T16:01:00.000Z</published>
    <updated>2020-10-29T09:13:55.575Z</updated>
    
    <content type="html"><![CDATA[<h1 id="帧率问题"><a href="#帧率问题" class="headerlink" title="帧率问题"></a>帧率问题</h1><h2 id="人像模式在暗环境，帧率过低，预览卡顿"><a href="#人像模式在暗环境，帧率过低，预览卡顿" class="headerlink" title="人像模式在暗环境，帧率过低，预览卡顿"></a>人像模式在暗环境，帧率过低，预览卡顿</h2><ol><li>首先确认一下信息<ul><li>测试环境有多暗 lux（是否有量变的过程）</li><li>camera 镜头距离拍摄物多远</li></ul></li></ol><ol start="2"><li><p>查看sensor 出帧是否正常</p><p>开启内核双摄帧同步的log</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">adb shell <span class="string">&quot;echo 0x1000018 &gt; ./sys/module/cam_debug_util/parameters/debug_mdl&quot;</span></span><br><span class="line">adb logcat -b kernel &gt; kmd.log</span><br></pre></td></tr></table></figure><p>正常环境log</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Line <span class="number">3662</span>: <span class="number">01</span>-<span class="number">02</span> <span class="number">02</span>:<span class="number">37</span>:<span class="number">40</span><span class="variable">.256</span>     <span class="number">0</span>     <span class="number">0</span> I CAM_DBG : CAM-ISP: <span class="number">__</span>cam_isp_ctx_send_sof_timestamp: <span class="number">666</span>: request id:<span class="number">64</span> frame number:<span class="number">66</span> SOF <span class="keyword">time</span> stamp:<span class="number">0</span>x4ceb8d14a14</span><br><span class="line">Line <span class="number">3679</span>: <span class="number">01</span>-<span class="number">02</span> <span class="number">02</span>:<span class="number">37</span>:<span class="number">40</span><span class="variable">.256</span>     <span class="number">0</span>     <span class="number">0</span> I CAM_DBG : CAM-ISP: <span class="number">__</span>cam_isp_ctx_send_sof_timestamp: <span class="number">666</span>: request id:<span class="number">64</span> frame number:<span class="number">66</span> SOF <span class="keyword">time</span> stamp:<span class="number">0</span>x4ceb8d5cc41</span><br><span class="line">Line <span class="number">4564</span>: <span class="number">01</span>-<span class="number">02</span> <span class="number">02</span>:<span class="number">37</span>:<span class="number">40</span><span class="variable">.289</span>     <span class="number">0</span>     <span class="number">0</span> I CAM_DBG : CAM-ISP: <span class="number">__</span>cam_isp_ctx_send_sof_timestamp: <span class="number">666</span>: request id:<span class="number">65</span> frame number:<span class="number">67</span> SOF <span class="keyword">time</span> stamp:<span class="number">0</span>x4cebacd4843</span><br><span class="line">Line <span class="number">4618</span>: <span class="number">01</span>-<span class="number">02</span> <span class="number">02</span>:<span class="number">37</span>:<span class="number">40</span><span class="variable">.290</span>     <span class="number">0</span>     <span class="number">0</span> I CAM_DBG : CAM-ISP: <span class="number">__</span>cam_isp_ctx_send_sof_timestamp: <span class="number">666</span>: request id:<span class="number">65</span> frame number:<span class="number">67</span> SOF <span class="keyword">time</span> stamp:<span class="number">0</span>x4cebad1caa4</span><br></pre></td></tr></table></figure><p>通过上述log，发现 request id 和  frame number 都是成双成对的。分别对应主摄和辅摄的出帧。</p><p>For Example ：request id:65 frame number:67</p><p>Line 4564: 01-02 02:37:40.289 </p><p>Line 4618: 01-02 02:37:40.290 </p><p>通过分析log ，可以看出主摄和辅摄只差1ms，同步OK.</p><p>暗环境下的log</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Line <span class="number">124973</span>: <span class="number">01</span>-<span class="number">02</span> <span class="number">03</span>:<span class="number">00</span>:<span class="number">15</span><span class="variable">.035</span>     <span class="number">0</span>     <span class="number">0</span> I CAM_DBG : CAM-ISP: <span class="number">__</span>cam_isp_ctx_send_sof_timestamp: <span class="number">666</span>: request id:<span class="number">0</span> frame number:<span class="number">193</span> SOF <span class="keyword">time</span> stamp:<span class="number">0</span>x60a27f1067b</span><br><span class="line">Line <span class="number">124990</span>: <span class="number">01</span>-<span class="number">02</span> <span class="number">03</span>:<span class="number">00</span>:<span class="number">15</span><span class="variable">.035</span>     <span class="number">0</span>     <span class="number">0</span> I CAM_DBG : CAM-ISP: <span class="number">__</span>cam_isp_ctx_send_sof_timestamp: <span class="number">666</span>: request id:<span class="number">0</span> frame number:<span class="number">110</span> SOF <span class="keyword">time</span> stamp:<span class="number">0</span>x60a27f5890f</span><br><span class="line"></span><br><span class="line">Line <span class="number">131018</span>: <span class="number">01</span>-<span class="number">02</span> <span class="number">03</span>:<span class="number">00</span>:<span class="number">16</span><span class="variable">.055</span>     <span class="number">0</span>     <span class="number">0</span> I CAM_DBG : CAM-ISP: <span class="number">__</span>cam_isp_ctx_send_sof_timestamp: <span class="number">666</span>: request id:<span class="number">0</span> frame number:<span class="number">213</span> SOF <span class="keyword">time</span> stamp:<span class="number">0</span>x60a64afe776</span><br><span class="line">Line <span class="number">131041</span>: <span class="number">01</span>-<span class="number">02</span> <span class="number">03</span>:<span class="number">00</span>:<span class="number">16</span><span class="variable">.055</span>     <span class="number">0</span>     <span class="number">0</span> I CAM_DBG : CAM-ISP: <span class="number">__</span>cam_isp_ctx_send_sof_timestamp: <span class="number">666</span>: request id:<span class="number">74</span> frame number:<span class="number">121</span> SOF <span class="keyword">time</span> stamp:<span class="number">0</span>x60a64b469d7</span><br></pre></td></tr></table></figure><p>很明显没有同步，分别算一下帧率</p><p>16.055 - 15.035 = 1.5s</p><p>主摄 (213-193)/1.5 = 13fps</p><p>辐射 (121-110)/1.5 = 7.3fps</p></li><li><p>解决方法</p><ul><li><p>方案一</p><p>找Tuning的同事固定帧率，调试曝光表</p></li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;帧率问题&quot;&gt;&lt;a href=&quot;#帧率问题&quot; class=&quot;headerlink&quot; title=&quot;帧率问题&quot;&gt;&lt;/a&gt;帧率问题&lt;/h1&gt;&lt;h2 id=&quot;人像模式在暗环境，帧率过低，预览卡顿&quot;&gt;&lt;a href=&quot;#人像模式在暗环境，帧率过低，预览卡顿&quot; class=&quot;</summary>
      
    
    
    
    <category term="技术研发" scheme="https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/"/>
    
    <category term="Camera Driver" scheme="https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera-Driver/"/>
    
    <category term="高通 Camx" scheme="https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera-Driver/%E9%AB%98%E9%80%9A-Camx/"/>
    
    
  </entry>
  
  <entry>
    <title>高通 Camx Bring up</title>
    <link href="https://zh-wiki.github.io/2020/01/01/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera%20Driver/%E9%AB%98%E9%80%9A%20Camx/%E9%AB%98%E9%80%9A%20Camx%20Bring%20up/"/>
    <id>https://zh-wiki.github.io/2020/01/01/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera%20Driver/%E9%AB%98%E9%80%9A%20Camx/%E9%AB%98%E9%80%9A%20Camx%20Bring%20up/</id>
    <published>2019-12-31T16:00:30.000Z</published>
    <updated>2020-10-23T08:57:27.432Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Dump-EEprom-Data"><a href="#Dump-EEprom-Data" class="headerlink" title="Dump EEprom Data"></a>Dump EEprom Data</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell <span class="string">&quot;echo dumpSensorEEPROMData=1 &gt;&gt; /vendor/etc/camera/camxoverridesettings.txt&quot;</span></span><br></pre></td></tr></table></figure><p>数据存放位置： <strong>/data/vendor/camera/xxx_kbuffer_OTP.txt</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Dump-EEprom-Data&quot;&gt;&lt;a href=&quot;#Dump-EEprom-Data&quot; class=&quot;headerlink&quot; title=&quot;Dump EEprom Data&quot;&gt;&lt;/a&gt;Dump EEprom Data&lt;/h3&gt;&lt;figure class=&quot;hi</summary>
      
    
    
    
    <category term="技术研发" scheme="https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/"/>
    
    <category term="Camera Driver" scheme="https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera-Driver/"/>
    
    <category term="高通 Camx" scheme="https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera-Driver/%E9%AB%98%E9%80%9A-Camx/"/>
    
    
  </entry>
  
  <entry>
    <title>高通 Camx capture result 代码流程</title>
    <link href="https://zh-wiki.github.io/2020/01/01/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera%20Driver/%E9%AB%98%E9%80%9A%20Camx/%E9%AB%98%E9%80%9A%20Camx%20capture%20result%20%E4%BB%A3%E7%A0%81%E6%B5%81%E7%A8%8B/"/>
    <id>https://zh-wiki.github.io/2020/01/01/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera%20Driver/%E9%AB%98%E9%80%9A%20Camx/%E9%AB%98%E9%80%9A%20Camx%20capture%20result%20%E4%BB%A3%E7%A0%81%E6%B5%81%E7%A8%8B/</id>
    <published>2019-12-31T16:00:06.000Z</published>
    <updated>2020-10-23T08:57:45.308Z</updated>
    
    <content type="html"><![CDATA[<h3 id="预览和拍照的-result-代码流程"><a href="#预览和拍照的-result-代码流程" class="headerlink" title="预览和拍照的 result 代码流程"></a>预览和拍照的 result 代码流程</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;预览和拍照的-result-代码流程&quot;&gt;&lt;a href=&quot;#预览和拍照的-result-代码流程&quot; class=&quot;headerlink&quot; title=&quot;预览和拍照的 result 代码流程&quot;&gt;&lt;/a&gt;预览和拍照的 result 代码流程&lt;/h3&gt;</summary>
      
    
    
    
    <category term="技术研发" scheme="https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/"/>
    
    <category term="Camera Driver" scheme="https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera-Driver/"/>
    
    <category term="高通 Camx" scheme="https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera-Driver/%E9%AB%98%E9%80%9A-Camx/"/>
    
    
  </entry>
  
  <entry>
    <title>高通 Camx capture request 代码流程</title>
    <link href="https://zh-wiki.github.io/2020/01/01/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera%20Driver/%E9%AB%98%E9%80%9A%20Camx/%E9%AB%98%E9%80%9A%20Camx%20capture%20request%20%E4%BB%A3%E7%A0%81%E6%B5%81%E7%A8%8B/"/>
    <id>https://zh-wiki.github.io/2020/01/01/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera%20Driver/%E9%AB%98%E9%80%9A%20Camx/%E9%AB%98%E9%80%9A%20Camx%20capture%20request%20%E4%BB%A3%E7%A0%81%E6%B5%81%E7%A8%8B/</id>
    <published>2019-12-31T16:00:05.000Z</published>
    <updated>2020-10-23T08:57:40.616Z</updated>
    
    <content type="html"><![CDATA[<h3 id="预览和拍照的-request-代码流程"><a href="#预览和拍照的-request-代码流程" class="headerlink" title="预览和拍照的 request 代码流程"></a>预览和拍照的 request 代码流程</h3><h4 id="主体框架图"><a href="#主体框架图" class="headerlink" title="主体框架图"></a>主体框架图</h4><p><img src="/2020/01/01/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera%20Driver/%E9%AB%98%E9%80%9A%20Camx/%E9%AB%98%E9%80%9A%20Camx%20capture%20request%20%E4%BB%A3%E7%A0%81%E6%B5%81%E7%A8%8B/image-20201012225025652.png" alt="process capture request"></p><h4 id="详细代码调用流程"><a href="#详细代码调用流程" class="headerlink" title="详细代码调用流程"></a>详细代码调用流程</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">chi_override_process_request() <span class="comment">//chxextensioninterface.cpp </span></span><br><span class="line">OverrideProcessRequest()   <span class="comment">//chxextensionmodule.cpp </span></span><br><span class="line">    ProcessCaptureRequest()<span class="comment">//chxusecase.cpp</span></span><br><span class="line">    ExecuteCaptureRequest() <span class="comment">//chxadvancedcamerausecase.cpp</span></span><br><span class="line">    result = pFeature-&gt;ExecuteProcessRequest(pRequest); <span class="comment">//会调到chifeature2wrapper.cpp:494 ExecuteProcessRequest()</span></span><br><span class="line">    ExecuteProcessRequest() <span class="comment">//chifeature2wrapper.cpp 开始进入算法的领域</span></span><br><span class="line">                    SubmitRequestToSession() <span class="comment">//经过一系类调用会走到 chifeature2base.cpp </span></span><br><span class="line">                     result = ExtensionModule::GetInstance()-&gt;ActivatePipeline() </span><br><span class="line">                     OnSubmitRequestToSession()</span><br><span class="line">                    ProcessFeatureMessage()</span><br><span class="line">                    ProcessMessageCb() <span class="comment">//通过回调又重新回到 chifeature2wrapper.cpp </span></span><br><span class="line">                    result = pFeature2Wrapper-&gt;m_pUsecaseBase-&gt;SubmitRequest(&amp;submitRequest); <span class="comment">//将 request 下到 camx session 中  </span></span><br></pre></td></tr></table></figure><p>CHI feature 通过 usecase 提交 request 到 session, 套路还是一样的（chxextensionmodule.cpp 通过这条链路转到Camx）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">result = pSession-&gt;ProcessCaptureRequest(pRequest); <span class="comment">//camxchicontext.cpp feature submit request 会调到这里从这里开始步入 session</span></span><br><span class="line"><span class="function">CamxResult <span class="title">Session::ProcessCaptureRequest</span><span class="params">()</span></span>; <span class="comment">//camxsession.cpp </span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;预览和拍照的-request-代码流程&quot;&gt;&lt;a href=&quot;#预览和拍照的-request-代码流程&quot; class=&quot;headerlink&quot; title=&quot;预览和拍照的 request 代码流程&quot;&gt;&lt;/a&gt;预览和拍照的 request 代码流程&lt;/h3&gt;&lt;h4 i</summary>
      
    
    
    
    <category term="技术研发" scheme="https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/"/>
    
    <category term="Camera Driver" scheme="https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera-Driver/"/>
    
    <category term="高通 Camx" scheme="https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera-Driver/%E9%AB%98%E9%80%9A-Camx/"/>
    
    
  </entry>
  
  <entry>
    <title>高通 Camx config stream 代码流程</title>
    <link href="https://zh-wiki.github.io/2020/01/01/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera%20Driver/%E9%AB%98%E9%80%9A%20Camx/%E9%AB%98%E9%80%9A%20Camx%20config%20stream%20%E4%BB%A3%E7%A0%81%E6%B5%81%E7%A8%8B/"/>
    <id>https://zh-wiki.github.io/2020/01/01/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera%20Driver/%E9%AB%98%E9%80%9A%20Camx/%E9%AB%98%E9%80%9A%20Camx%20config%20stream%20%E4%BB%A3%E7%A0%81%E6%B5%81%E7%A8%8B/</id>
    <published>2019-12-31T16:00:04.000Z</published>
    <updated>2020-10-23T08:57:49.796Z</updated>
    
    
    
    
    <category term="技术研发" scheme="https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/"/>
    
    <category term="Camera Driver" scheme="https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera-Driver/"/>
    
    <category term="高通 Camx" scheme="https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera-Driver/%E9%AB%98%E9%80%9A-Camx/"/>
    
    
  </entry>
  
  <entry>
    <title>Arch Linux 开发环境的搭建</title>
    <link href="https://zh-wiki.github.io/2020/01/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Arch%20Linux%20%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E7%9A%84%E6%90%AD%E5%BB%BA/"/>
    <id>https://zh-wiki.github.io/2020/01/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Arch%20Linux%20%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E7%9A%84%E6%90%AD%E5%BB%BA/</id>
    <published>2019-12-31T16:00:03.000Z</published>
    <updated>2020-10-29T01:54:00.907Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Arch-Linux-系统安装"><a href="#Arch-Linux-系统安装" class="headerlink" title="Arch Linux 系统安装"></a>Arch Linux 系统安装</h2><p>主要进行分区，系统的安装，图形服务和必要驱动的安装</p><h3 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h3><ol><li><p>查看当前分区信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fdisk -l</span><br></pre></td></tr></table></figure></li><li><p>设置分区</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cfdisk /dev/sda</span><br></pre></td></tr></table></figure><p>1)首先选择分区类型</p><p>​    MBR 选择 dos    </p><p>​    GPT  选择 gpt </p><p> 2)MBR启动一般分为2个分区</p><p>​    主分区   （选择为boot标志）</p><p>​    交换分区（内存的2倍）</p></li><li><p>格式化分区</p><p>格式化主分区</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkfs.ext4 /dev/sda1</span><br></pre></td></tr></table></figure><p>格式化交换分区</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkswap /dev/sda2</span><br></pre></td></tr></table></figure><p>启动交换分区</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">swapon /dev/sda2</span><br></pre></td></tr></table></figure></li><li><p>挂载分区</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount /dev/sda1 /mnt</span><br></pre></td></tr></table></figure></li></ol><h3 id="编辑镜像源"><a href="#编辑镜像源" class="headerlink" title="编辑镜像源"></a>编辑镜像源</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/pacman.d/mirrorlist</span><br></pre></td></tr></table></figure><p>将中国的源放在文件的开头</p><h3 id="安装系统基本组件"><a href="#安装系统基本组件" class="headerlink" title="安装系统基本组件"></a>安装系统基本组件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacstrap /mnt base linux linux-firmware</span><br></pre></td></tr></table></figure><h3 id="安装基本开发工具包"><a href="#安装基本开发工具包" class="headerlink" title="安装基本开发工具包"></a>安装基本开发工具包</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arch-chroot /mnt</span><br><span class="line">pacman -S base-devel</span><br></pre></td></tr></table></figure><h3 id="安装-sudo"><a href="#安装-sudo" class="headerlink" title="安装 sudo"></a>安装 sudo</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arch-chroot /mnt</span><br><span class="line">pacman -S sudo vi vim</span><br><span class="line">visudo</span><br></pre></td></tr></table></figure><p>删除这一行注释 <strong>%wheel ALL = (ALL) ALL</strong></p><h3 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arch-chroot /mnt</span><br><span class="line">useradd -G wheel -m 用户名</span><br><span class="line">passwad 用户名</span><br></pre></td></tr></table></figure><h3 id="安装-Grub"><a href="#安装-Grub" class="headerlink" title="安装 Grub"></a>安装 Grub</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arch-chroot /mnt</span><br><span class="line">pacman -S grub</span><br><span class="line">grub-install --target=i386-pc /dev/sda</span><br><span class="line">grub-mkconfig -o /boot/grub/grub.cfg</span><br></pre></td></tr></table></figure><h3 id="生成-fstab"><a href="#生成-fstab" class="headerlink" title="生成 fstab"></a>生成 fstab</h3><p>该配置不需要 arch-chroot </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">genfstab /mnt &gt; /mnt/etc/fstab</span><br></pre></td></tr></table></figure><h3 id="安装-Xorg-图形管理"><a href="#安装-Xorg-图形管理" class="headerlink" title="安装 Xorg 图形管理"></a>安装 Xorg 图形管理</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacstrap /mnt xorg-server xorg-xinit xorg-apps</span><br></pre></td></tr></table></figure><h3 id="安装网络组件"><a href="#安装网络组件" class="headerlink" title="安装网络组件"></a>安装网络组件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pacstrap /mnt dhcpcd wpa_supplicant networkmanager</span><br><span class="line">arch-chroot /mnt</span><br><span class="line">systemctl <span class="built_in">enable</span> dhcpcd</span><br><span class="line">systemctl <span class="built_in">enable</span> wpa_supplicant</span><br><span class="line">systemctl <span class="built_in">enable</span> networkmanager</span><br></pre></td></tr></table></figure><h3 id="安装显卡驱动"><a href="#安装显卡驱动" class="headerlink" title="安装显卡驱动"></a>安装显卡驱动</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lspci | grep VGA//查看显卡是什么型号</span><br><span class="line">pacman -S xf86-video-intel  //intel 显卡驱动</span><br></pre></td></tr></table></figure><h3 id="安装音频组件"><a href="#安装音频组件" class="headerlink" title="安装音频组件"></a>安装音频组件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pacstrap /mnt alsa-utils pulseaudio</span><br><span class="line">pacstrap /mnt pulseaudio-alsa</span><br></pre></td></tr></table></figure><hr><h2 id="Arch-Linux-桌面环境安装"><a href="#Arch-Linux-桌面环境安装" class="headerlink" title="Arch Linux 桌面环境安装"></a>Arch Linux 桌面环境安装</h2><h3 id="窗口管理器-dwm"><a href="#窗口管理器-dwm" class="headerlink" title="窗口管理器 dwm"></a>窗口管理器 dwm</h3><ol><li><p>安装终端内置浏览器 <strong>w3m</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S w3m</span><br></pre></td></tr></table></figure></li><li><p>下载 <strong>dwm</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">w3m suckless.org</span><br></pre></td></tr></table></figure></li><li><p>安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo make clean install</span><br></pre></td></tr></table></figure></li><li><p>运行dwm</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.xinitrc</span><br><span class="line">startx</span><br></pre></td></tr></table></figure><p>在 <strong>.xinitrc</strong> 中 加入 <strong>exec dwm</strong> </p><h3 id="窗口管理器-i3"><a href="#窗口管理器-i3" class="headerlink" title="窗口管理器 i3"></a>窗口管理器 i3</h3></li></ol><h2 id="Arch-Linux-基础配置"><a href="#Arch-Linux-基础配置" class="headerlink" title="Arch Linux 基础配置"></a>Arch Linux 基础配置</h2><h3 id="安装中文字体"><a href="#安装中文字体" class="headerlink" title="安装中文字体"></a>安装中文字体</h3>   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S noto-fonts noto-fonts-cjk noto-fonts-emoji</span><br><span class="line">sudo vim /etc/locale.gen</span><br></pre></td></tr></table></figure><p>取消 <strong>/etc/locale.gen</strong> 中 以下 的注释</p><ul><li><p>en_US.UTF-8 UTF-8</p></li><li><p>zh_CN.UTF-8 UTF-8</p></li><li><p>zh_TW.UTF-8 UTF-8</p></li></ul><p>生成 locale</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo locale-gen</span><br></pre></td></tr></table></figure><h3 id="设置-archlinuxcn"><a href="#设置-archlinuxcn" class="headerlink" title="设置 archlinuxcn"></a>设置 archlinuxcn</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/pacman.conf</span><br><span class="line">sudo pacman -Sy</span><br><span class="line">sudo pacman -S archlinuxcn-keyring</span><br></pre></td></tr></table></figure><p>在文件的末尾插入</p><p>[archlinuxcn]</p><p>Server = <a href="https://mirrors.ustc.edu.cn/archlinuxcn/$arch">https://mirrors.ustc.edu.cn/archlinuxcn/$arch</a></p><h3 id="安装-Chrome"><a href="#安装-Chrome" class="headerlink" title="安装 Chrome"></a>安装 Chrome</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S google-chrome</span><br></pre></td></tr></table></figure><h3 id="安装中文输入法"><a href="#安装中文输入法" class="headerlink" title="安装中文输入法"></a>安装中文输入法</h3><ol><li><p>安装输入法以及配置工具</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S fcitx fcitx-im kcm-fcitx fcitx-qt5 fcitx-gtk2 fcitx-gtk3 fcitx-configtool</span><br></pre></td></tr></table></figure></li><li><p>配置输入法</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.xprofile</span><br></pre></td></tr></table></figure><p>输入以下内容</p><p>export GTK_IM_MODULE=fcitx<br>export QT_IM_MODULE=fcitx<br>export XMODIFIERS=”@im=fcitx”</p></li></ol><h3 id="SSH-的安装与配置"><a href="#SSH-的安装与配置" class="headerlink" title="SSH 的安装与配置"></a>SSH 的安装与配置</h3><ol><li><p>安装ssh</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacman -Sy openssh</span><br></pre></td></tr></table></figure></li><li><p>生成密钥</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;xxxxx@xxxxx.com&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>通过 SSH 远程连接问题</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/ssh/sshd_config</span><br></pre></td></tr></table></figure><p>在文件的末尾加以下配置</p><p>LoginGraceTime 120<br>PermitRootLogin yes<br>StrictModes yes</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Arch-Linux-系统安装&quot;&gt;&lt;a href=&quot;#Arch-Linux-系统安装&quot; class=&quot;headerlink&quot; title=&quot;Arch Linux 系统安装&quot;&gt;&lt;/a&gt;Arch Linux 系统安装&lt;/h2&gt;&lt;p&gt;主要进行分区，系统的安装，图形服务和</summary>
      
    
    
    
    <category term="计算机基础知识" scheme="https://zh-wiki.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="Arch Linux" scheme="https://zh-wiki.github.io/tags/Arch-Linux/"/>
    
  </entry>
  
  <entry>
    <title>高通 Camx Camx open camera</title>
    <link href="https://zh-wiki.github.io/2020/01/01/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera%20Driver/%E9%AB%98%E9%80%9A%20Camx/%E9%AB%98%E9%80%9A%20Camx%20open%20camera/"/>
    <id>https://zh-wiki.github.io/2020/01/01/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera%20Driver/%E9%AB%98%E9%80%9A%20Camx/%E9%AB%98%E9%80%9A%20Camx%20open%20camera/</id>
    <published>2019-12-31T16:00:03.000Z</published>
    <updated>2020-11-05T03:55:08.972Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Open-Camera-的流程简介"><a href="#Open-Camera-的流程简介" class="headerlink" title="Open Camera 的流程简介"></a>Open Camera 的流程简介</h1><p>当用户打开了相机设备之后，便会发生如下过程：</p><ol><li>APP调用CameraManager的openCamera方法，层层调用之后最终调用到Camera Service层中的CameraService::connectDevice方法</li><li>然后通过ICameraDevice::open()这一个HIDL接口通知Camera Provider层</li><li>在Camera Provider层内部又通过调用之前获取的camera_module_t中methods的open方法来获取一个Camera 设备，对应于HAL中的camera3_device_t结构体</li><li>在Camera Provider层调用获取到的camera3_device_t的initialize方法进行初始化动作</li></ol><p>代码大概流程走向</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//APP 端 open Camera</span></span><br><span class="line">CameraManager::openCamera() </span><br><span class="line">    <span class="comment">//Camera Server</span></span><br><span class="line">    CameraService::connectDevice()</span><br><span class="line">    <span class="comment">//通过HIDL接口</span></span><br><span class="line">    ICameraDevice::open()</span><br><span class="line">    <span class="comment">//camera provider</span></span><br><span class="line">    <span class="keyword">camera_module_t</span>::methods::open()</span><br><span class="line">    <span class="comment">//接下来就是进行一些初始化操作</span></span><br><span class="line">     <span class="keyword">camera3_device_t</span>::initialize()</span><br></pre></td></tr></table></figure><h1 id="APP-Open-Camera-流程"><a href="#APP-Open-Camera-流程" class="headerlink" title="APP Open Camera 流程"></a>APP Open Camera 流程</h1><p>App端主要做了以下几点工作</p><ol><li><p>获取 CameraManager 服务</p></li><li><p>打开指定的 Camera</p><ul><li>获取 Camera Server</li><li>调用 cameraService.connectDevice() 去连接打开设备，并且将上层传下来的回调传入Camera Server</li><li>返回Device给App端</li></ul></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//apk端获取CameraManager 服务</span></span><br><span class="line">mCamManager = (CameraManager)getSystemService(Context.CAMERA_SERVICE);  </span><br><span class="line"><span class="comment">//打开指定camera</span></span><br><span class="line">--&gt; mCamManager.openCamera(mCameraId, mStateCallback, null);    </span><br><span class="line"><span class="comment">//frameworks/base/core/java/android/hardware/camera2/CameraManager.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">openCamera</span><span class="params">(@NonNull String cameraId, @NonNull @CallbackExecutor Executor executor, @NonNull <span class="keyword">final</span> CameraDevice.StateCallback callback)</span></span></span><br><span class="line">   |--&gt; openCameraForUid(cameraId, callback, executor, USE_CALLING_UID)</span><br><span class="line">   |   |--&gt; openCameraDeviceUserAsync(cameraId, callback, executor, clientUid);</span><br><span class="line">   |   |   |--&gt; CameraDevice device = null; <span class="comment">//初始化CameraDevice</span></span><br><span class="line">   |   |   | <span class="comment">//实例化　new android.hardware.camera2.impl.CameraDeviceImpl</span></span><br><span class="line">   |   |   |--&gt; android.hardware.camera2.impl.CameraDeviceImpl deviceImpl = <span class="keyword">new</span> android.hardware.camera2.impl.CameraDeviceImpl(...) </span><br><span class="line">   |   |   |--&gt; ICameraDeviceCallbacks callbacks = deviceImpl.getCallbacks();   <span class="comment">//获取回调</span></span><br><span class="line">   |   |   |--&gt; ICameraService cameraService = CameraManagerGlobal.get().getCameraService();    <span class="comment">//获取CameraService 服务</span></span><br><span class="line">   |   |   |--&gt; cameraUser = cameraService.connectDevice(callbacks, cameraId, mContext.getOpPackageName(), uid);    <span class="comment">//连接打开camera</span></span><br><span class="line">   |   |   |--&gt; <span class="keyword">goto</span> CONNECTDEVICE:    <span class="comment">//跳转到下面CONNECTDEVICE处进行分析</span></span><br><span class="line">   |   |   |--&gt; deviceImpl.setRemoteDevice(cameraUser);</span><br><span class="line">   |   |   |   |--&gt; mRemoteDevice = <span class="keyword">new</span> ICameraDeviceUserWrapper(remoteDevice);</span><br><span class="line">   |   |   |   |--&gt; mDeviceExecutor.execute(mCallOnOpened); <span class="comment">//这里是一个线程池</span></span><br><span class="line">   |   |   |   |   |--&gt; sessionCallback = mSessionStateCallback;    <span class="comment">//获取session cb</span></span><br><span class="line">   |   |   |   |   |--&gt; sessionCallback.onOpened(CameraDeviceImpl.<span class="keyword">this</span>);    <span class="comment">//通过session cb 返回device</span></span><br><span class="line">   |   |   |   |   |--&gt; mDeviceCallback.onOpened(CameraDeviceImpl.<span class="keyword">this</span>);    <span class="comment">//通过device cb 返回device,这里就是返回给apk端的CameraDevice了</span></span><br></pre></td></tr></table></figure><h1 id="Camera-Server-Open-流程"><a href="#Camera-Server-Open-流程" class="headerlink" title="Camera Server Open 流程"></a>Camera Server Open 流程</h1><p>对于打开相机设备动作,主要由connectDevice来实现，当CameraFramework通过调用ICameraService的connectDevice接口的时候,主要做了两件事情：</p><ul><li>创建CameraDeviceClient。</li><li>对CameraDeviceClient进行初始化,并将其返回给Framework。</li></ul><h2 id="创建-CameraDevcieClient"><a href="#创建-CameraDevcieClient" class="headerlink" title="创建 CameraDevcieClient"></a>创建 CameraDevcieClient</h2><p>CameraDeviceClient 该类在打开设备的时候被实例化，一次打开设备的操作对应一个该类对象，它实现了ICameraDeviceUser接口，以AIDL方式暴露接口给Camera Framework进行调用，于此同时,该类在打开设备的过程中，获取了来自Camera Framework对于ICameraDeviceCallback接口的实现代理，通过该代理可以将结果上传至Camera Framewor中。我个人的理解其实这个类就是 framework 与 Camera 的通信入口。</p><p>代码流程如下：</p><ul><li>首先实例化一个CameraDeviceClient</li><li>将来自Framework针对ICameraDeviceCallback的实现存入CameraDeviceClient中，一旦有结果产生便可以将结果通过这个回调回传给Framework</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/av/services/camera/libcameraservice/CameraService.cpp</span></span><br><span class="line"><span class="function">Status <span class="title">CameraService::connectDevice</span><span class="params">(<span class="keyword">const</span> sp&lt;hardware::camera2::ICameraDeviceCallbacks&gt;&amp; cameraCb, <span class="keyword">const</span> String16&amp; cameraId, <span class="keyword">const</span> String16&amp; clientPackageName, <span class="keyword">int</span> clientUid, sp&lt;hardware::camera2::ICameraDeviceUser&gt;* device)</span> <span class="comment">//最后一个参数是返回值</span></span></span><br><span class="line">   |--&gt; connectHelper&lt;hardware::camera2::ICameraDeviceCallbacks,CameraDeviceClient&gt;(...) //模板，CALLBACK 为hardware::camera2::ICameraDeviceCallbacks， CLIENT： CameraDeviceClient</span><br><span class="line">   |   |--&gt; validateConnectLocked(...) <span class="comment">//关于一些权限的判断，如果没有权限或者非法访问这里会直接退出</span></span><br><span class="line">   |   |--&gt; <span class="keyword">int</span> deviceVersion = getDeviceVersion(cameraId, <span class="comment">/*out*/</span>&amp;facing) <span class="comment">//获取device version, 为之后的实例化哪一个client 做准备</span></span><br><span class="line">   |   |--&gt; makeClient(..., deviceVersion, effectiveApiLevel, ...) <span class="comment">//这里主要是这两个参数决定了实例化哪一个client，</span></span><br><span class="line">   |   |--&gt; *client = <span class="keyword">new</span> CameraDeviceClient(cameraService, tmp, packageName, cameraId,facing, clientPid, clientUid, servicePid) <span class="comment">//这里是实例化了CameraDeviceClient</span></span><br><span class="line">   |   |--&gt; client = <span class="keyword">static_cast</span>&lt;CLIENT*&gt;(tmp.get()); <span class="comment">//取得makeClient中实例化好的client</span></span><br><span class="line">   |   |--&gt; client-&gt;initialize(mCameraProviderManager, mMonitorTags); <span class="comment">//开始初始化</span></span><br></pre></td></tr></table></figure><h2 id="初始化-CameraDevcieClient"><a href="#初始化-CameraDevcieClient" class="headerlink" title="初始化 CameraDevcieClient"></a>初始化 CameraDevcieClient</h2><p>CameraDeviceClient的初始化工作流程：</p><ul><li>调用父类Camera2ClientBase的initialize方法进行初始化</li><li>实例化FrameProcessorBase对象并且将内部的Camera3Device对象传入其中,这样就建立了和Camera3Device的联系,之后将内部线程运行起来,等待来自Camera3Device的结果</li><li>将CameraDeviceClient注册到内部,这样就建立了与CameraDeviceClient的联系</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file : frameworks/av/services/camera/libcameraservice/api2/CameraDeviceClient.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">CameraDeviceClient::initialize</span><span class="params">(sp&lt;CameraProviderManager&gt; manager, <span class="keyword">const</span> String8&amp; monitorTags)</span></span></span><br><span class="line">   |--&gt; initializeImpl(manager, monitorTags)</span><br><span class="line">   |--&gt; mFrameProcessor = <span class="keyword">new</span> FrameProcessorBase(mDevice); <span class="comment">//实例化FrameProcessorBase对象</span></span><br><span class="line">   |   |--&gt; Camera2ClientBase::initialize(providerPtr, monitorTags)</span><br><span class="line">   <span class="comment">//file:  frameworks/av/services/camera/libcameraservice/common/Camera2ClientBase.cpp</span></span><br><span class="line">   |   |--&gt; <span class="keyword">status_t</span> Camera2ClientBase&lt;TClientBase&gt;::initialize(sp&lt;CameraProviderManager&gt; manager, <span class="keyword">const</span> String8&amp; monitorTags)</span><br><span class="line">   |   |   |--&gt; initializeImpl(manager, monitorTags)</span><br><span class="line">   |   |   |   |--&gt; mDevice-&gt;initialize(providerPtr, monitorTags)   <span class="comment">//这里的mDevice 是在 Camera2ClientBase初始化的时候传入的  mDevice(new Camera3Device(cameraId))</span></span><br></pre></td></tr></table></figure><h3 id="Camera3Device-结构介绍"><a href="#Camera3Device-结构介绍" class="headerlink" title="Camera3Device 结构介绍"></a>Camera3Device 结构介绍</h3><ul><li>主要实现了对Camera Provider 的ICameraDeviceCallbacks会调接口的实现，通过该接口接收来自Provider的结果上传进而传给CameraDeviceClient</li><li>Camera3Device会将事件通过notify方法给到CameraDeviceClient</li><li>Camera3Device中RequestThread主要用于处理Request的接收与下发工作</li></ul><p>Camera3Device 初始化</p><ul><li>通过调用CameraProviderManager的openSession方法打开并获取一个Provider中的ICameraDeviceSession代理</li><li>实例化一个HalInterface对象,将之前获取的ICameraDeviceSession代理存入其中,最后将RequestThread线程运行起来,等待request的下发</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file: device3/Camera3Device.cpp</span></span><br><span class="line"> <span class="function"><span class="keyword">status_t</span> <span class="title">Camera3Device::initialize</span><span class="params">(sp&lt;CameraProviderManager&gt; manager, <span class="keyword">const</span> String8&amp; monitorTags)</span></span></span><br><span class="line"> |--&gt; status_t res = manager-&gt;openSession(mId.string(), this, /*out*/ &amp;session)   //CameraProviderManager openSession</span><br><span class="line"> <span class="comment">//file: common/CameraProviderManager.cpp</span></span><br><span class="line">   |   |--&gt; <span class="function"><span class="keyword">status_t</span> <span class="title">CameraProviderManager::openSession</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;id, <span class="keyword">const</span> sp&lt;device::V3_2::ICameraDeviceCallback&gt;&amp; callback, sp&lt;device::V3_2::ICameraDeviceSession&gt; *session)</span></span></span><br><span class="line">   |   |   |--&gt; auto interface = deviceInfo3-&gt;startDeviceInterface&lt;CameraProviderManager::ProviderInfo::DeviceInfo3::InterfaceT&gt;()</span><br><span class="line">   |   |   |   |--&gt; <span class="keyword">const</span> sp&lt;provider::V2_4::ICameraProvider&gt; interface = startProviderInterface()  <span class="comment">//获取provider</span></span><br><span class="line">   |   |   |   |--&gt; interface-&gt;getCameraDeviceInterface_V3_x(name, [&amp;status, &amp;cameraInterface](hidl_cb) <span class="comment">//这里的hidl_cb 指的是回调接口，provider 会将device 指针返回回来，当然这个指针是跨进程能够调用的，具体怎么实现的暂时不清楚，暂且不管</span></span><br><span class="line">   |   |   |--&gt; interface-&gt;open(callback, [&amp;status, &amp;session](Status s, <span class="keyword">const</span> sp&lt;device::V3_2::ICameraDeviceSession&gt;&amp; cameraSession)    <span class="comment">//这里就调用的provider部分的Device的open接口</span></span><br></pre></td></tr></table></figure><h3 id="FrameProcessBase-结构介绍"><a href="#FrameProcessBase-结构介绍" class="headerlink" title="FrameProcessBase 结构介绍"></a>FrameProcessBase 结构介绍</h3><ul><li>meta data以及image data 会给到 FrameProcessBase</li><li>FrameProcessBase主要用于metadata以及image data的中转处理</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Open-Camera-的流程简介&quot;&gt;&lt;a href=&quot;#Open-Camera-的流程简介&quot; class=&quot;headerlink&quot; title=&quot;Open Camera 的流程简介&quot;&gt;&lt;/a&gt;Open Camera 的流程简介&lt;/h1&gt;&lt;p&gt;当用户打开了相机设备</summary>
      
    
    
    
    <category term="技术研发" scheme="https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/"/>
    
    <category term="Camera Driver" scheme="https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera-Driver/"/>
    
    <category term="高通 Camx" scheme="https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera-Driver/%E9%AB%98%E9%80%9A-Camx/"/>
    
    
  </entry>
  
  <entry>
    <title>Centos 开发环境的搭建</title>
    <link href="https://zh-wiki.github.io/2020/01/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Centos%20%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E7%9A%84%E6%90%AD%E5%BB%BA/"/>
    <id>https://zh-wiki.github.io/2020/01/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Centos%20%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E7%9A%84%E6%90%AD%E5%BB%BA/</id>
    <published>2019-12-31T16:00:02.000Z</published>
    <updated>2020-10-23T06:20:13.476Z</updated>
    
    <content type="html"><![CDATA[<h2 id="同一网段外部浏览器不能访问Tomcat"><a href="#同一网段外部浏览器不能访问Tomcat" class="headerlink" title="同一网段外部浏览器不能访问Tomcat"></a>同一网段外部浏览器不能访问Tomcat</h2><ol><li><p>问题产生背景和原因</p><p>背景：服务器已经安装好tomcat, 服务器主机通过 <strong>ip+8080</strong> 的方式可以进行访问, 但是其他在同一网段下的客户端机器通过同样方式不能访问.</p><p>原因：服务器未将 8080 端口进行开放</p></li><li><p>解决方法</p><p>1)查看防火墙状态</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --state</span><br></pre></td></tr></table></figure><p>2)添加需要开放的端口</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --permanent --zone=public --add-port=8080/tcp</span><br></pre></td></tr></table></figure><p>3)加载配置使其生效</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure><p>4)查看配置是否生效</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --permanent --zone=public --list-ports</span><br></pre></td></tr></table></figure><p>5)重新访问 Tomcat <strong>(IP+8080)</strong> </p></li></ol><h2 id="防火墙的相关操作"><a href="#防火墙的相关操作" class="headerlink" title="防火墙的相关操作"></a>防火墙的相关操作</h2><ol><li><p>开启防火墙的命令  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start firewalld.service</span><br></pre></td></tr></table></figure></li><li><p>关闭防火墙的命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop firewalld.service</span><br></pre></td></tr></table></figure></li><li><p>开机自动启动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> firewalld.service</span><br></pre></td></tr></table></figure></li><li><p>关闭开机自动启动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="built_in">disable</span> firewalld.service</span><br></pre></td></tr></table></figure></li><li><p>查看防火墙状态</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl status firewalld</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;同一网段外部浏览器不能访问Tomcat&quot;&gt;&lt;a href=&quot;#同一网段外部浏览器不能访问Tomcat&quot; class=&quot;headerlink&quot; title=&quot;同一网段外部浏览器不能访问Tomcat&quot;&gt;&lt;/a&gt;同一网段外部浏览器不能访问Tomcat&lt;/h2&gt;&lt;ol&gt;
</summary>
      
    
    
    
    <category term="计算机基础知识" scheme="https://zh-wiki.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="Centos" scheme="https://zh-wiki.github.io/tags/Centos/"/>
    
  </entry>
  
  <entry>
    <title>Repo 常用命令</title>
    <link href="https://zh-wiki.github.io/2020/01/01/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Linux%20%E5%91%BD%E4%BB%A4/Repo%20%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/"/>
    <id>https://zh-wiki.github.io/2020/01/01/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Linux%20%E5%91%BD%E4%BB%A4/Repo%20%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/</id>
    <published>2019-12-31T16:00:02.000Z</published>
    <updated>2020-10-23T08:58:18.653Z</updated>
    
    <content type="html"><![CDATA[<h3 id="repo-拉下来的代码如何新建分支"><a href="#repo-拉下来的代码如何新建分支" class="headerlink" title="repo 拉下来的代码如何新建分支"></a>repo 拉下来的代码如何新建分支</h3><ol><li>repo start xxx(分支名) –all</li></ol><h3 id="repo-sync-的时候如果有本地未提交的修改"><a href="#repo-sync-的时候如果有本地未提交的修改" class="headerlink" title="repo sync 的时候如果有本地未提交的修改"></a>repo sync 的时候如果有本地未提交的修改</h3><ol><li>repo forall -cv “git reset HEAD –hard; git clean -df “ -j32</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;repo-拉下来的代码如何新建分支&quot;&gt;&lt;a href=&quot;#repo-拉下来的代码如何新建分支&quot; class=&quot;headerlink&quot; title=&quot;repo 拉下来的代码如何新建分支&quot;&gt;&lt;/a&gt;repo 拉下来的代码如何新建分支&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;repo</summary>
      
    
    
    
    <category term="技术研发" scheme="https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/"/>
    
    <category term="Linux 命令" scheme="https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Linux-%E5%91%BD%E4%BB%A4/"/>
    
    
  </entry>
  
  <entry>
    <title>高通 Camx init 流程</title>
    <link href="https://zh-wiki.github.io/2020/01/01/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera%20Driver/%E9%AB%98%E9%80%9A%20Camx/%E9%AB%98%E9%80%9A%20Camx%20init%20%E6%B5%81%E7%A8%8B/"/>
    <id>https://zh-wiki.github.io/2020/01/01/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera%20Driver/%E9%AB%98%E9%80%9A%20Camx/%E9%AB%98%E9%80%9A%20Camx%20init%20%E6%B5%81%E7%A8%8B/</id>
    <published>2019-12-31T16:00:02.000Z</published>
    <updated>2020-10-26T05:03:01.033Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h3><h4 id="Camx-CHI-整体框架如下"><a href="#Camx-CHI-整体框架如下" class="headerlink" title="Camx-CHI 整体框架如下"></a>Camx-CHI 整体框架如下</h4><img src="/2020/01/01/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera%20Driver/%E9%AB%98%E9%80%9A%20Camx/%E9%AB%98%E9%80%9A%20Camx%20init%20%E6%B5%81%E7%A8%8B/image-20201026114544241.png" alt="CAMX-CHI" style="zoom: 67%;"><p>其中 camx 代表了通用功能性接口的代码实现集合，chi-cdk代表了可定制化需求的代码实现集合，从图中不难看出camx部分对上作为HAL3接口的实现,对下通过v4l2框架与Kernel保持通讯,中间通过互相dlopen so库并获取对方操作接口的方式保持着与CHI的交互。</p><p>camx/中有如下几个主要目录:</p><ul><li>core/ : 用于存放camx的核心实现模块,其中还包含了主要用于实现hal3接口的hal/目录,以及负责与CHI进行交互的chi/目录</li><li>csl/: 用于存放主要负责camx与camera driver的通讯模块,为camx提供了统一的Camera driver控制接口</li><li>hwl/: 用于存放自身具有独立运算能力的硬件node,该部分node受csl管理</li><li>swl/: 用于存放自身并不具有独立运算能力,必须依靠CPU才能实现的node</li></ul><p>chi-cdk/中有如下几个主要目录:</p><ul><li>chioverride/: 用于存放CHI实现的核心模块,负责与camx进行交互并且实现了CHI的总体框架以及具体的业务处理。</li><li>bin/: 用于存放平台相关的配置项</li><li>topology/: 用于存放用户自定的Usecase xml配置文件</li><li>node/: 用于存放用户自定义功能的node</li><li>module/: 用于存放不同sensor的配置文件,该部分在初始化sensor的时候需要用到</li><li>tuning/: 用于存放不同场景下的效果参数的配置文件</li><li>sensor/: 用于存放不同sensor的自有信息以及寄存器配置参数</li><li>actuator/: 用于存放不同对焦模块的配置信息</li><li>ois/: 用于存放防抖模块的配置信息</li><li>flash/: 存放着闪光灯模块的配置信息</li><li>eeprom/: 存放着eeprom外部存储模块的配置信息</li><li>fd/: 存放了人脸识别模块的配置信息</li></ul><h3 id="Camx-Init-总体概览"><a href="#Camx-Init-总体概览" class="headerlink" title="Camx Init 总体概览"></a>Camx Init 总体概览</h3><p>通过分析 Camera Provider ，已经知道了上层是如何调到底层的Camera Init 流程，大概框架如下</p><p><img src="/2020/01/01/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera%20Driver/%E9%AB%98%E9%80%9A%20Camx/%E9%AB%98%E9%80%9A%20Camx%20init%20%E6%B5%81%E7%A8%8B/image-20201026113612765.png" alt="Provider INIT"></p><p>接下来我们将按照模块化分析camx的内部初始化流程</p><p><img src="/2020/01/01/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera%20Driver/%E9%AB%98%E9%80%9A%20Camx/%E9%AB%98%E9%80%9A%20Camx%20init%20%E6%B5%81%E7%A8%8B/image-20201026130250068.png" alt="CAMX INIT"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;概览&quot;&gt;&lt;a href=&quot;#概览&quot; class=&quot;headerlink&quot; title=&quot;概览&quot;&gt;&lt;/a&gt;概览&lt;/h3&gt;&lt;h4 id=&quot;Camx-CHI-整体框架如下&quot;&gt;&lt;a href=&quot;#Camx-CHI-整体框架如下&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    <category term="技术研发" scheme="https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/"/>
    
    <category term="Camera Driver" scheme="https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera-Driver/"/>
    
    <category term="高通 Camx" scheme="https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera-Driver/%E9%AB%98%E9%80%9A-Camx/"/>
    
    
  </entry>
  
  <entry>
    <title>Hexo 博客搭建</title>
    <link href="https://zh-wiki.github.io/2020/01/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Hexo%20%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    <id>https://zh-wiki.github.io/2020/01/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Hexo%20%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</id>
    <published>2019-12-31T16:00:01.000Z</published>
    <updated>2020-10-23T06:20:18.636Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo npm install --unsafe-perm --verbose -g hexo</span><br></pre></td></tr></table></figure><h2 id="同步本地图片与网络图片"><a href="#同步本地图片与网络图片" class="headerlink" title="同步本地图片与网络图片"></a>同步本地图片与网络图片</h2><ol><li><p>安装插件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install https://github.com/CodeFalling/hexo-asset-image --save</span><br></pre></td></tr></table></figure></li><li><p>配置Typora</p><p><img src="/2020/01/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Hexo%20%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/image-20201005210350281.png" alt="image-20201005210350281"></p></li><li><p>编译</p><p>有以下log说明配置成功</p><img src="/2020/01/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Hexo%20%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/image-20201005165756877.png"></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;安装-Hexo&quot;&gt;&lt;a href=&quot;#安装-Hexo&quot; class=&quot;headerlink&quot; title=&quot;安装 Hexo&quot;&gt;&lt;/a&gt;安装 Hexo&lt;/h2&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;</summary>
      
    
    
    
    <category term="计算机基础知识" scheme="https://zh-wiki.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="Hexo" scheme="https://zh-wiki.github.io/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Git 常用命令</title>
    <link href="https://zh-wiki.github.io/2020/01/01/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Linux%20%E5%91%BD%E4%BB%A4/Git%20%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>https://zh-wiki.github.io/2020/01/01/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Linux%20%E5%91%BD%E4%BB%A4/Git%20%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</id>
    <published>2019-12-31T16:00:01.000Z</published>
    <updated>2020-10-23T08:58:13.881Z</updated>
    
    <content type="html"><![CDATA[<h3 id="撤销指令"><a href="#撤销指令" class="headerlink" title="撤销指令"></a>撤销指令</h3><ol><li>撤销工作区的修改<br> <strong>git checkout</strong> 文件名<br> <strong>git checkout</strong> 目录 -f</li><li>从暂存区撤销到工作区（可以理解为<strong>git add</strong>的反向动作）<br> <strong>git reset HEAD</strong></li><li>从版本库撤销到暂存区<br> <strong>git reset –soft HEAD^</strong></li><li>从版本库撤销到工作区<br> <strong>git reset –mixed HEAD^</strong></li><li>撤销到上一次提交（本地修改丢失）<br> <strong>git reset –hard HEAD^</strong></li></ol><h3 id="保存恢复指令"><a href="#保存恢复指令" class="headerlink" title="保存恢复指令"></a>保存恢复指令</h3><ol><li>保存本地未追踪的修改<br>  <strong>git stash save</strong> 路径</li><li>将保存的内容导出<br> <strong>git stash pop stash@{index}</strong></li><li>获取保存列表<br>  <strong>git stash list</strong></li></ol><h3 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h3><p>这里我分为两种情况：</p><ol><li><p>代码提到服务器上。<br> a. 首先把自己的提交reset掉。<br> b.更新代码<br> c.将自己的代码从服务器上拉下来。<br> d.冲突用code工具解决掉。然后add 修改文件，重新commit</p></li><li><p>代码在本地提交<br> a.将本地提交撤回到工作区。<br> b.保存本地修改<br> c.更新代码<br> d.将保存的代码还原。<br> e.冲突用code工具解决掉。然后add 修改文件，重新commit</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;撤销指令&quot;&gt;&lt;a href=&quot;#撤销指令&quot; class=&quot;headerlink&quot; title=&quot;撤销指令&quot;&gt;&lt;/a&gt;撤销指令&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;撤销工作区的修改&lt;br&gt; &lt;strong&gt;git checkout&lt;/strong&gt; 文件名&lt;br&gt; &lt;stro</summary>
      
    
    
    
    <category term="技术研发" scheme="https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/"/>
    
    <category term="Linux 命令" scheme="https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Linux-%E5%91%BD%E4%BB%A4/"/>
    
    
  </entry>
  
  <entry>
    <title>高通 Camx camera provider</title>
    <link href="https://zh-wiki.github.io/2020/01/01/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera%20Driver/%E9%AB%98%E9%80%9A%20Camx/%E9%AB%98%E9%80%9A%20Camx%20camera%20provider/"/>
    <id>https://zh-wiki.github.io/2020/01/01/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera%20Driver/%E9%AB%98%E9%80%9A%20Camx/%E9%AB%98%E9%80%9A%20Camx%20camera%20provider/</id>
    <published>2019-12-31T16:00:01.000Z</published>
    <updated>2020-10-29T03:05:04.565Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h1><img src="/2020/01/01/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera%20Driver/%E9%AB%98%E9%80%9A%20Camx/%E9%AB%98%E9%80%9A%20Camx%20camera%20provider/image-20201021102734471.png" alt="camera provider" style="zoom:80%;"><p>通过图片可以看出Camera Provider 分为两部分</p><ul><li>通过 <strong>HIDL</strong> 与Camera Service 跨进程通信</li><li>通过 <strong>dlopen</strong> 方式加载一系列动态库 （Camera HAL3结构的so），在高通Camera 是指 camx-chi 架构</li></ul><h1 id="camera-provider-和-camera-hal3-的联系"><a href="#camera-provider-和-camera-hal3-的联系" class="headerlink" title="camera provider 和 camera hal3 的联系"></a>camera provider 和 camera hal3 的联系</h1><p>HAL硬件抽象层(Hardware Abstraction Layer),是谷歌开发的用于屏蔽底层硬件抽象出来的一个软件层，该层定义了自己的一套通用标准接口,平台厂商务必按照以下规则定义自己的Module</p><ul><li>每一个硬件都通过hw_module_t来描述,具有固定的名字HMI</li><li>每一个硬件都必须实现hw_module_t里面的open方法,用于打开硬件设备,并返回对应的操作接口集合</li><li>硬件的操作接口集合使用hw_device_t 来描述,并可以通过自定义一个更大的包含hw_device_t的结构体来拓展硬件操作集合</li></ul><h2 id="HAL3-结构体介绍"><a href="#HAL3-结构体介绍" class="headerlink" title="HAL3 结构体介绍"></a>HAL3 结构体介绍</h2><details><summary>hw_module_t</summary><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">hw_module_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> tag;</span><br><span class="line">    <span class="keyword">uint16_t</span> module_api_version;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> version_major module_api_version</span></span><br><span class="line">    <span class="keyword">uint16_t</span> hal_api_version;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> version_minor hal_api_version</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *id;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *author;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hw_module_methods_t</span>* <span class="title">methods</span>;</span></span><br><span class="line">    <span class="keyword">void</span>* dso;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __LP64__</span></span><br><span class="line">    <span class="keyword">uint64_t</span> reserved[<span class="number">32</span><span class="number">-7</span>];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="keyword">uint32_t</span> reserved[<span class="number">32</span><span class="number">-7</span>];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125; <span class="keyword">hw_module_t</span>;</span><br></pre></td></tr></table></figure></details><details><summary>hw_module_methods_t</summary><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">hw_module_methods_t</span> &#123;</span></span><br><span class="line">    <span class="comment">/** Open a specific device */</span></span><br><span class="line">    <span class="keyword">int</span> (*open)(<span class="keyword">const</span> struct <span class="keyword">hw_module_t</span>* <span class="keyword">module</span>, <span class="keyword">const</span> <span class="keyword">char</span>* id,</span><br><span class="line">            struct <span class="keyword">hw_device_t</span>** device);</span><br><span class="line">&#125; <span class="keyword">hw_module_methods_t</span>;</span><br></pre></td></tr></table></figure></details><details><summary>hw_device_t</summary><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">hw_device_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> tag;</span><br><span class="line">    <span class="keyword">uint32_t</span> version;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hw_module_t</span>* <span class="title">module</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __LP64__</span></span><br><span class="line">    <span class="keyword">uint64_t</span> reserved[<span class="number">12</span>];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="keyword">uint32_t</span> reserved[<span class="number">12</span>];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> (*close)(struct <span class="keyword">hw_device_t</span>* device);</span><br><span class="line">    </span><br><span class="line">&#125; <span class="keyword">hw_device_t</span>;</span><br></pre></td></tr></table></figure></details><p>从上面的定义可以看出</p><ul><li><p>hw_module_t 代表了模块，通过其open方法用来打开一个设备</p></li><li><p>设备是用hw_device_t来表示，其中除了用来关闭设备的close方法外,并无其它方法</p></li><li><p>由此可见谷歌定义的HAL接口,并不能满足绝大部分HAL模块的需要,所以谷歌想出了一个比较好的解决方式,那便是将这两个基本结构嵌入到更大的结构体内部,同时在更大的结构内部定义了各自模块特有的方法,用于实现模块的功能,这样,一来对上保持了HAL的统一规范,二来也扩展了模块的功能</p></li></ul><h2 id="高通-camx-HAL3-结构体"><a href="#高通-camx-HAL3-结构体" class="headerlink" title="高通 camx HAL3 结构体"></a>高通 camx HAL3 结构体</h2><details><summary>camera_module_t</summary><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">camera_module</span> &#123;</span></span><br><span class="line">    <span class="keyword">hw_module_t</span> common;</span><br><span class="line">    <span class="keyword">int</span> (*get_number_of_cameras)(<span class="keyword">void</span>);</span><br><span class="line">    <span class="keyword">int</span> (*get_camera_info)(<span class="keyword">int</span> camera_id, struct camera_info *info);</span><br><span class="line">    <span class="keyword">int</span> (*set_callbacks)(<span class="keyword">const</span> <span class="keyword">camera_module_callbacks_t</span> *callbacks);</span><br><span class="line">    <span class="keyword">void</span> (*get_vendor_tag_ops)(<span class="keyword">vendor_tag_ops_t</span>* ops);</span><br><span class="line">    <span class="keyword">int</span> (*open_legacy)(<span class="keyword">const</span> struct <span class="keyword">hw_module_t</span>* <span class="keyword">module</span>, <span class="keyword">const</span> <span class="keyword">char</span>* id, <span class="keyword">uint32_t</span> halVersion, struct <span class="keyword">hw_device_t</span>** device);</span><br><span class="line">    <span class="keyword">int</span> (*set_torch_mode)(<span class="keyword">const</span> <span class="keyword">char</span>* camera_id, <span class="keyword">bool</span> enabled);</span><br><span class="line">    <span class="keyword">int</span> (*init)();</span><br><span class="line">    <span class="keyword">int</span> (*get_physical_camera_info)(<span class="keyword">int</span> physical_camera_id,  <span class="keyword">camera_metadata_t</span> **static_metadata);</span><br><span class="line">    <span class="keyword">int</span> (*is_stream_combination_supported)(<span class="keyword">int</span> camera_id, <span class="keyword">const</span> <span class="keyword">camera_stream_combination_t</span> *streams);</span><br><span class="line">    <span class="keyword">void</span> (*notify_device_state_change)(<span class="keyword">uint64_t</span> deviceState);</span><br><span class="line">    <span class="keyword">int</span> (*get_camera_device_version)(<span class="keyword">int</span> camera_id, <span class="keyword">uint32_t</span> *version);</span><br><span class="line">    <span class="keyword">void</span>* reserved[<span class="number">1</span>];</span><br><span class="line">&#125; <span class="keyword">camera_module_t</span>;</span><br></pre></td></tr></table></figure></details><details><summary>camera3_device_t</summary><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">camera3_device</span> &#123;</span></span><br><span class="line">    <span class="keyword">hw_device_t</span> common;</span><br><span class="line">    <span class="keyword">camera3_device_ops_t</span> *ops;</span><br><span class="line">    <span class="keyword">void</span> *priv;</span><br><span class="line">&#125; <span class="keyword">camera3_device_t</span>;</span><br></pre></td></tr></table></figure></details><ul><li>camera_module_t包含了hw_module_t，主要用于表示Camera模块，其中定义了诸如get_number_of_cameras以及set_callbacks等扩展方法</li><li>camera3_device_t包含了hw_device_t,主要用来表示Camera设备,其中定义了camera3_device_ops操作方法集合,用来实现正常获取图像数据以及控制Camera的功能</li></ul><h2 id="Camera-HAL3-的实现"><a href="#Camera-HAL3-的实现" class="headerlink" title="Camera HAL3 的实现"></a>Camera HAL3 的实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">CAMX_VISIBILITY_PUBLIC <span class="keyword">camera_module_t</span> HAL_MODULE_INFO_SYM =</span><br><span class="line">&#123;</span><br><span class="line">    .common =</span><br><span class="line">    &#123;</span><br><span class="line">        .tag                = HARDWARE_MODULE_TAG,</span><br><span class="line">        .module_api_version = CAMERA_MODULE_API_VERSION_CURRENT,</span><br><span class="line">        .hal_api_version    = HARDWARE_HAL_API_VERSION,</span><br><span class="line">        .id                 = CAMERA_HARDWARE_MODULE_ID,</span><br><span class="line">        .name               = <span class="string">&quot;QTI Camera HAL&quot;</span>,</span><br><span class="line">        .author             = <span class="string">&quot;Qualcomm Technologies, Inc.&quot;</span>,</span><br><span class="line">        .methods            = &amp;CamX::g_hwModuleMethods</span><br><span class="line">    &#125;,</span><br><span class="line">    .get_number_of_cameras  = CamX::get_number_of_cameras,</span><br><span class="line">    .get_camera_info        = CamX::get_camera_info,</span><br><span class="line">    .set_callbacks          = CamX::set_callbacks,</span><br><span class="line">    .get_vendor_tag_ops     = CamX::get_vendor_tag_ops,</span><br><span class="line">    .open_legacy            = <span class="literal">NULL</span>,</span><br><span class="line">    .set_torch_mode         = CamX::set_torch_mode,</span><br><span class="line">    .init                   = CamX::init</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>没错高通 camx hal3 的入口就是这个，在遵循HAL3规范的前提下，实例化各个接口。Provider 将会调用 hw_get_module() 来获取该入口。</p><p>各个接口映射到 camxhal3.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> Dispatch <span class="title">g_dispatchHAL3</span><span class="params">(&amp;g_jumpTableHAL3)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">JumpTableHAL3 g_jumpTableHAL3 =</span><br><span class="line">&#123;</span><br><span class="line">    open,</span><br><span class="line">    get_number_of_cameras,</span><br><span class="line">    get_camera_info,</span><br><span class="line">    set_callbacks,</span><br><span class="line">    get_vendor_tag_ops,</span><br><span class="line">    open_legacy,</span><br><span class="line">    set_torch_mode,</span><br><span class="line">    init,</span><br><span class="line">    get_tag_count,</span><br><span class="line">    get_all_tags,</span><br><span class="line">    get_section_name,</span><br><span class="line">    get_tag_name,</span><br><span class="line">    get_tag_type,</span><br><span class="line">    close,</span><br><span class="line">    initialize,</span><br><span class="line">    configure_streams,</span><br><span class="line">    construct_default_request_settings,</span><br><span class="line">    process_capture_request,</span><br><span class="line">    dump,</span><br><span class="line">    flush,</span><br><span class="line">    camera_device_status_change,</span><br><span class="line">    torch_mode_status_change,</span><br><span class="line">    process_capture_result,</span><br><span class="line">    notify</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="Provider-init-代码流程"><a href="#Provider-init-代码流程" class="headerlink" title="Provider init 代码流程"></a>Provider init 代码流程</h1><p><img src="/2020/01/01/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera%20Driver/%E9%AB%98%E9%80%9A%20Camx/%E9%AB%98%E9%80%9A%20Camx%20camera%20provider/image-20201021143242020.png" alt="init 代码流程"></p><p>在系统初始化的时候，系统会去运行”<a href="mailto:&#97;&#x6e;&#100;&#x72;&#111;&#105;&#x64;&#x2e;&#104;&#97;&#x72;&#100;&#119;&#x61;&#114;&#101;&#46;&#x63;&#x61;&#109;&#x65;&#x72;&#x61;&#x2e;&#x70;&#114;&#x6f;&#x76;&#x69;&#x64;&#x65;&#x72;&#64;&#50;&#46;&#52;&#x2d;&#115;&#x65;&#114;&#118;&#105;&#99;&#101;&#95;&#54;&#52;">&#97;&#x6e;&#100;&#x72;&#111;&#105;&#x64;&#x2e;&#104;&#97;&#x72;&#100;&#119;&#x61;&#114;&#101;&#46;&#x63;&#x61;&#109;&#x65;&#x72;&#x61;&#x2e;&#x70;&#114;&#x6f;&#x76;&#x69;&#x64;&#x65;&#x72;&#64;&#50;&#46;&#52;&#x2d;&#115;&#x65;&#114;&#118;&#105;&#99;&#101;&#95;&#54;&#52;</a>“程序启动Provider进程，并加入HW Service Manager中接受统一管理。在改过程中实例化一个 LegacyCameraProviderImpl_2_4 对象，通过 hw_get_module 标准方法 获取HAL 模块。这边指的是 <strong>camera.qcom.so</strong> 。</p><h2 id="Camera-Provider-Init-函数总括"><a href="#Camera-Provider-Init-函数总括" class="headerlink" title="Camera Provider Init 函数总括"></a>Camera Provider Init 函数总括</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hardware/interfaces/camera/provider/2.4/default/LegacyCameraProviderImpl_2_4.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">LegacyCameraProviderImpl_2_4::initialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">camera_module_t</span> *rawModule;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取 camera.qcom.so 可以理解为和 camxhal3entry.cpp 建立联系</span></span><br><span class="line">    <span class="keyword">int</span> err = hw_get_module(CAMERA_HARDWARE_MODULE_ID, (<span class="keyword">const</span> <span class="keyword">hw_module_t</span> **)&amp;rawModule); </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将 camera.qcom.so 获取的句柄保存在 mModule 对象中 ，该函数定义在 CameraModule.cpp </span></span><br><span class="line">    mModule = <span class="keyword">new</span> CameraModule(rawModule);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//我们可以跟进去看看 init() 非常明显 实际就是进行 camx 的初始化，camxhal3entry.cpp  &#123; CAMX:: init()&#125; </span></span><br><span class="line">    <span class="comment">//int CameraModule::init() 这个函数将会调用 getNumberOfCameras() </span></span><br><span class="line">    <span class="comment">//就此 camx-chi 的一系列初始化操作 拉开序幕</span></span><br><span class="line">    err = mModule-&gt;init(); </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置回调函数，用于接受camx-chi的数据和事件</span></span><br><span class="line">    err = mModule-&gt;setCallbacks(<span class="keyword">this</span>);</span><br><span class="line">    </span><br><span class="line">    mNumberOfLegacyCameras = mModule-&gt;getNumberOfCameras();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// mInitFailed</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>init 函数结束之后，Camera Provider进程便一直便存在于系统中,监听着来自Camera Service的调用。</p><h2 id="Camera-Provider-Init-分解"><a href="#Camera-Provider-Init-分解" class="headerlink" title="Camera Provider Init 分解"></a>Camera Provider Init 分解</h2><p>通过上面的总括可以理解为 <strong>Provider</strong> 最终目的获取 <strong>Camx-Chi</strong> 的 <strong>setting</strong> 以及 <strong>HW</strong> 资源。然后保存起来返回给上层，供后面使用。</p><p>二话不说先上一张大图</p><p><img src="/2020/01/01/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera%20Driver/%E9%AB%98%E9%80%9A%20Camx/%E9%AB%98%E9%80%9A%20Camx%20camera%20provider/image-20201026113612765.png"></p><h3 id="get-number-of-cameras-函数介绍"><a href="#get-number-of-cameras-函数介绍" class="headerlink" title="get_number_of_cameras 函数介绍"></a>get_number_of_cameras 函数介绍</h3><p>这个函数是一切美好的开始，她的最先调用就是上面介绍的provide init 函数的 <strong>CameraModule::init()</strong> </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//hardware/interfaces/camera/common/1.0/default/CameraModule.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CameraModule::init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    <span class="keyword">int</span> res = OK;</span><br><span class="line">    <span class="keyword">if</span> (getModuleApiVersion() &gt;= CAMERA_MODULE_API_VERSION_2_4 &amp;&amp;</span><br><span class="line">            mModule-&gt;init != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ATRACE_BEGIN(<span class="string">&quot;camera_module-&gt;init&quot;</span>);</span><br><span class="line">        res = mModule-&gt;init();</span><br><span class="line">        ATRACE_END();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将会走到 vendor/proprietary/camx/src/coer/hal/camxhal3.cpp中</span></span><br><span class="line">    mNumberOfCameras = getNumberOfCameras();</span><br><span class="line">    mCameraInfoMap.setCapacity(mNumberOfCameras);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>CameraModule::init()</strong> ，这个函数调用 <strong>getNumberOfCameras()</strong> 。最终调用到 <strong>get_number_of_cameras()</strong> 这个函数已经是干到camx了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//vendor/proprietary/camx/src/coer/hal/camxhal3.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">get_number_of_cameras</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    INT numCameras;</span><br><span class="line">    <span class="comment">//将会走到 vendor/proprietary/camx/src/coer/hal/camxhal3module.cpp中</span></span><br><span class="line">    <span class="comment">//会调用到 HAL3Module的构造函数</span></span><br><span class="line">    numCameras = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(HAL3Module::GetInstance()-&gt;GetNumCameras());</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> numCameras;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数主要有两个作用：</p><ul><li>是通过 <strong>HAL3Module</strong> 类的构造函数会获取 CAMX-CHI 的信息</li><li>加载 <strong>com.qti.chi.override.so</strong>  模块，映射 CAMX-CHI 之间的接口</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//vendor/proprietary/camx/src/coer/hal/camxhal3module.cpp</span></span><br><span class="line">HAL3Module::HAL3Module()</span><br><span class="line">&#123;</span><br><span class="line">    CamxResult result = CamxResultSuccess;</span><br><span class="line">    CSLCameraPlatform CSLPlatform = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    CAMX_LOG_CONFIG(CamxLogGroupHAL, <span class="string">&quot;***************************************************&quot;</span>);</span><br><span class="line">    CAMX_LOG_CONFIG(CamxLogGroupHAL, <span class="string">&quot;SHA1:     %s&quot;</span>, CAMX_SHA1);</span><br><span class="line">    CAMX_LOG_CONFIG(CamxLogGroupHAL, <span class="string">&quot;COMMITID: %s&quot;</span>, CAMX_COMMITID);</span><br><span class="line">    CAMX_LOG_CONFIG(CamxLogGroupHAL, <span class="string">&quot;BUILD TS: %s&quot;</span>, CAMX_BUILD_TS);</span><br><span class="line">    CAMX_LOG_CONFIG(CamxLogGroupHAL, <span class="string">&quot;***************************************************&quot;</span>);</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">//到了这个位置已经是很亲切了，干到camx了</span></span><br><span class="line">    m_pStaticSettings = HwEnvironment::GetInstance()-&gt;GetStaticSettings();</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="HwEnvironment-Initialize-函数介绍"><a href="#HwEnvironment-Initialize-函数介绍" class="headerlink" title="HwEnvironment::Initialize() 函数介绍"></a>HwEnvironment::Initialize() 函数介绍</h3><p>通过 <strong>HAL3Module</strong> 构造函数会调用 <strong>HwEnvironment</strong> 类的构造，主体功能在 <strong>HwEnvironment::Initialize()</strong> 中实现</p><details><summary>HwEnvironment::Initialize()</summary><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//vendor/proprietary/camx/src/coer/camxhwenvironment.cpp</span></span><br><span class="line"><span class="function">CamxResult <span class="title">HwEnvironment::Initialize</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CamxResult              result                  = CamxResultSuccess;</span><br><span class="line">    CSLInitializeParams     params                  = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    SettingsManager*        pStaticSettingsManager  = SettingsManager::Create(<span class="literal">NULL</span>);</span><br><span class="line">    ExternalComponentInfo*  pExternalComponent      = GetExternalComponent();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> != pStaticSettingsManager)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">const</span> StaticSettings* pStaticSettings = pStaticSettingsManager-&gt;GetStaticSettings();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> != pStaticSettings)</span><br><span class="line">        &#123;</span><br><span class="line">            params.mode                                           = pStaticSettings-&gt;CSLMode;</span><br><span class="line">            params.emulatedSensorParams.enableSensorSimulation    = pStaticSettings-&gt;enableSensorEmulation;</span><br><span class="line">            params.emulatedSensorParams.dumpSensorEmulationOutput = pStaticSettings-&gt;dumpSensorEmulationOutput;</span><br><span class="line"></span><br><span class="line">            OsUtils::StrLCpy(params.emulatedSensorParams.sensorEmulatorPath,</span><br><span class="line">                             pStaticSettings-&gt;sensorEmulatorPath,</span><br><span class="line">                             <span class="keyword">sizeof</span>(pStaticSettings-&gt;sensorEmulatorPath));</span><br><span class="line"></span><br><span class="line">            OsUtils::StrLCpy(params.emulatedSensorParams.sensorEmulator,</span><br><span class="line">                             pStaticSettings-&gt;sensorEmulator,</span><br><span class="line">                             <span class="keyword">sizeof</span>(pStaticSettings-&gt;sensorEmulator));</span><br><span class="line"></span><br><span class="line">            result = CSLInitialize(&amp;params);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (CamxResultSuccess == result)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// Query the camera platform</span></span><br><span class="line">                result = QueryHwContextStaticEntryMethods();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (CamxResultSuccess == result)</span><br><span class="line">            &#123;</span><br><span class="line">                m_pHwFactory = m_staticEntryMethods.CreateHwFactory();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">NULL</span> == m_pHwFactory)</span><br><span class="line">                &#123;</span><br><span class="line">                    CAMX_ASSERT_ALWAYS_MESSAGE(<span class="string">&quot;Failed to create the HW factory&quot;</span>);</span><br><span class="line">                    result = CamxResultEFailed;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (CamxResultSuccess == result)</span><br><span class="line">            &#123;</span><br><span class="line">                m_pSettingsManager = m_pHwFactory-&gt;CreateSettingsManager();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">NULL</span> == m_pSettingsManager)</span><br><span class="line">                &#123;</span><br><span class="line">                    CAMX_ASSERT_ALWAYS_MESSAGE(<span class="string">&quot;Failed to create the HW settings manager&quot;</span>);</span><br><span class="line">                    result = CamxResultEFailed;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (CamxResultSuccess == result)</span><br><span class="line">            &#123;</span><br><span class="line">                m_staticEntryMethods.GetHWBugWorkarounds(&amp;m_workarounds);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pStaticSettingsManager-&gt;Destroy();</span><br><span class="line">        pStaticSettingsManager = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    CAMX_ASSERT(<span class="literal">NULL</span> != pExternalComponent);</span><br><span class="line">    <span class="keyword">if</span> ((CamxResultSuccess == result) &amp;&amp; (<span class="literal">NULL</span> != pExternalComponent))</span><br><span class="line">    &#123;</span><br><span class="line">        result = ProbeChiComponents(pExternalComponent, &amp;m_numExternalComponent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (CamxResultSuccess == result)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Load the OEM sensor capacity customization functions</span></span><br><span class="line">        CAMXCustomizeCAMXInterface camxInterface;</span><br><span class="line">        camxInterface.pGetHWEnvironment = HwEnvironment::GetInstance;</span><br><span class="line">        CAMXCustomizeEntry(&amp;m_pOEMInterface, &amp;camxInterface);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (CamxResultSuccess != result)</span><br><span class="line">    &#123;</span><br><span class="line">        CAMX_LOG_ERROR(CamxLogGroupCore, <span class="string">&quot;FATAL ERROR: Raise SigAbort. HwEnvironment initialization failed&quot;</span>);</span><br><span class="line">        m_numberSensors = <span class="number">0</span>;</span><br><span class="line">        OsUtils::RaiseSignalAbort();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        m_initCapsStatus = InitCapsInitialize;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p>通过上面的代码可以看出 <strong>HwEnvironment::Initialize()</strong> 做的事情还是挺多的。下面我们开始分析</p><ol><li><p>获取camx的相关配置</p><p>SettingsManager*        pStaticSettingsManager  = SettingsManager::Create(NULL);</p><p>经过一系列调用最终会调到以下代码，加载配置参数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//vendor/proprietary/camx/src/coer/camxsettingsmanager.cpp</span></span><br><span class="line"><span class="function">CamxResult <span class="title">SettingsManager::Initialize</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    StaticSettings* pStaticSettings)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ......    </span><br><span class="line">        <span class="comment">// Populate the default settings</span></span><br><span class="line">        InitializeDefaultSettings();</span><br><span class="line">        InitializeDefaultDebugSettings();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Load the override settings from our override settings stores</span></span><br><span class="line">        result = LoadOverrideSettings(m_pOverrideSettingsStore);</span><br><span class="line">        result = LoadOverrideProperties(m_pOverrideSettingsStore, TRUE);</span><br><span class="line">        result = ValidateSettings();</span><br><span class="line"></span><br><span class="line">        DumpSettings();</span><br><span class="line">        m_pOverrideSettingsStore-&gt;DumpOverriddenSettings();</span><br><span class="line">    ......</span><br><span class="line">    UpdateLogSettings();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>利用加载好的配置参数去初始化相关模块</p><p>result = CSLInitialize(&amp;params);</p><p>经过一个跳转表格进入以下代码</p><details><summary>CamxResult CSLInitializeHW()</summary><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//vendor/proprietary/camx/src/csl/hw/camxcslhw.cpp</span></span><br><span class="line"><span class="function">CamxResult <span class="title">CSLInitializeHW</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CamxResult result                          = CamxResultEFailed;</span><br><span class="line">    CHAR       syncDeviceName[CSLHwMaxDevName] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (FALSE == CSLHwIsHwInstanceValid())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (TRUE == CSLHwEnumerateAndAddCSLHwDevice(CSLInternalHwVideodevice, CAM_VNODE_DEVICE_TYPE))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (TRUE == CSLHwEnumerateAndAddCSLHwDevice(CSLInternalHwVideoSubdevice, CAM_CPAS_DEVICE_TYPE))</span><br><span class="line">            &#123;</span><br><span class="line">                CAMX_LOG_VERBOSE(CamxLogGroupCSL, <span class="string">&quot;Platform family=%d, version=%d.%d.%d, cpas version=%d.%d.%d&quot;</span>,</span><br><span class="line">                    g_CSLHwInstance.pCameraPlatform.family,</span><br><span class="line">                    g_CSLHwInstance.pCameraPlatform.platformVersion.majorVersion,</span><br><span class="line">                    g_CSLHwInstance.pCameraPlatform.platformVersion.minorVersion,</span><br><span class="line">                    g_CSLHwInstance.pCameraPlatform.platformVersion.revVersion,</span><br><span class="line">                    g_CSLHwInstance.pCameraPlatform.CPASVersion.majorVersion,</span><br><span class="line">                    g_CSLHwInstance.pCameraPlatform.CPASVersion.minorVersion,</span><br><span class="line">                    g_CSLHwInstance.pCameraPlatform.CPASVersion.revVersion);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (FALSE == CSLHwEnumerateAndAddCSLHwDevice(CSLInternalHwVideoSubdeviceAll, <span class="number">0</span>))</span><br><span class="line">                &#123;</span><br><span class="line">                    CAMX_LOG_ERROR(CamxLogGroupCSL, <span class="string">&quot;No KMD devices found&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    CAMX_LOG_VERBOSE(CamxLogGroupCSL, <span class="string">&quot;Total KMD subdevices found =%d&quot;</span>, g_CSLHwInstance.kmdDeviceCount);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// Init the memory manager data structures here</span></span><br><span class="line">                CamX::Utils::Memset(g_CSLHwInstance.memManager.bufferInfo, <span class="number">0</span>, <span class="keyword">sizeof</span>(g_CSLHwInstance.memManager.bufferInfo));</span><br><span class="line">                <span class="comment">// Init the sync manager here</span></span><br><span class="line">                g_CSLHwInstance.lock-&gt;Lock();</span><br><span class="line">                g_CSLHwInstance.pSyncFW = CamX::SyncManager::GetInstance();</span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">NULL</span> != g_CSLHwInstance.pSyncFW)</span><br><span class="line">                &#123;</span><br><span class="line">                    CSLHwGetSyncHwDevice(syncDeviceName, CSLHwMaxDevName);</span><br><span class="line">                    CAMX_LOG_VERBOSE(CamxLogGroupCSL, <span class="string">&quot;Sync device found = %s&quot;</span>, syncDeviceName);</span><br><span class="line">                    result = g_CSLHwInstance.pSyncFW-&gt;Initialize(syncDeviceName);</span><br><span class="line">                    <span class="keyword">if</span> (CamxResultSuccess != result)</span><br><span class="line">                    &#123;</span><br><span class="line">                        CAMX_LOG_ERROR(CamxLogGroupCSL, <span class="string">&quot;CSL failed to initialize SyncFW&quot;</span>);</span><br><span class="line">                        result = g_CSLHwInstance.pSyncFW-&gt;Destroy();</span><br><span class="line">                        g_CSLHwInstance.pSyncFW = <span class="literal">NULL</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                g_CSLHwInstance.lock-&gt;Unlock();</span><br><span class="line">                CSLHwInstanceSetState(CSLHwValidState);</span><br><span class="line">                result = CamxResultSuccess;</span><br><span class="line">                CAMX_LOG_VERBOSE(CamxLogGroupCSL, <span class="string">&quot;Successfully acquired requestManager&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                CAMX_LOG_ERROR(CamxLogGroupCSL, <span class="string">&quot;Failed to acquire CPAS&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            CAMX_LOG_ERROR(CamxLogGroupCSL, <span class="string">&quot;Failed to acquire requestManager invalid&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        CAMX_LOG_ERROR(CamxLogGroupCSL, <span class="string">&quot;CSL in Invalid State&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p>这一部分我个人理解为，遍历所有kernel端的设备。获取相关接口以及需要的事件。与HAL层建立联系。具体分析以后可以单独写一篇文章分析</p></li><li><p>根据平台获取对应的入口方法</p><p>这个暂时不知道是个什么鬼，先这样理解</p><p>result = QueryHwContextStaticEntryMethods();</p><p>经过一系列的调用最终是跑到了这里</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//vendor/proprietary/camx/src/csl/hwl/titan17x/camxtitan17xhwl.cpp</span></span><br><span class="line"><span class="function">CamxResult <span class="title">Titan17xGetStaticEntryMethods</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    HwContextStaticEntry* pStaticEntry)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CamxResult result = CamxResultSuccess;</span><br><span class="line"></span><br><span class="line">    pStaticEntry-&gt;Create                               = &amp;Titan17xContext::Create;</span><br><span class="line">    pStaticEntry-&gt;GetStaticMetadataKeysInfo            = &amp;Titan17xContext::GetStaticMetadataKeysInfo;</span><br><span class="line">    pStaticEntry-&gt;GetStaticCaps                        = &amp;Titan17xContext::GetStaticCaps;</span><br><span class="line">    pStaticEntry-&gt;CreateHwFactory                      = &amp;Titan17xFactory::Create;</span><br><span class="line">    pStaticEntry-&gt;QueryVendorTagsInfo                  = &amp;Titan17xContext::QueryVendorTagsInfo;</span><br><span class="line">    pStaticEntry-&gt;GetHWBugWorkarounds                  = &amp;Titan17xContext::GetHWBugWorkarounds;</span><br><span class="line">    pStaticEntry-&gt;QueryExternalComponentVendorTagsInfo = &amp;Titan17xContext::QueryExternalComponentVendorTagsInfo;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>获取CHI各个节点的接口</p><p>result = ProbeChiComponents(pExternalComponent, &amp;m_numExternalComponent);</p><p>遍历所有chi相关的.so库，将各个接口保存起来。这一块的代码撸的比较少，先记录这么多</p></li></ol><p>到此处 HwEnvironment::Initialize() 这个函数就介绍的差不多了。日后慢慢完善</p><h3 id="HwEnvironment-InitCaps-函数介绍"><a href="#HwEnvironment-InitCaps-函数介绍" class="headerlink" title="HwEnvironment::InitCaps()  函数介绍"></a>HwEnvironment::InitCaps()  函数介绍</h3><details><summary>HwEnvironment::InitCaps()</summary><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//vendor/proprietary/camx/src/coer/camxhwenvironment.cpp</span></span><br><span class="line"><span class="function">VOID <span class="title">HwEnvironment::InitCaps</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CamxResult    result = CamxResultSuccess;</span><br><span class="line"></span><br><span class="line">    m_pHWEnvLock-&gt;Lock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (InitCapsRunning == m_initCapsStatus ||</span><br><span class="line">        InitCapsDone == m_initCapsStatus)</span><br><span class="line">    &#123;</span><br><span class="line">        m_pHWEnvLock-&gt;Unlock();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    m_initCapsStatus = InitCapsRunning;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (CamxResultSuccess == result)</span><br><span class="line">    &#123;</span><br><span class="line">        EnumerateDevices();</span><br><span class="line">        ProbeImageSensorModules();</span><br><span class="line">        EnumerateSensorDevices();</span><br><span class="line">        InitializeSensorSubModules();</span><br><span class="line">        InitializeSensorStaticCaps();</span><br><span class="line"></span><br><span class="line">        result = m_staticEntryMethods.GetStaticCaps(&amp;m_platformCaps[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">// copy the static capacity to remaining sensor&#x27;s</span></span><br><span class="line">        <span class="keyword">for</span> (UINT index = <span class="number">1</span>; index &lt; m_numberSensors; index++)</span><br><span class="line">        &#123;</span><br><span class="line">            Utils::Memcpy(&amp;m_platformCaps[index], &amp;m_platformCaps[<span class="number">0</span>], <span class="keyword">sizeof</span>(m_platformCaps[<span class="number">0</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> != m_pOEMInterface-&gt;pInitializeExtendedPlatformStaticCaps)</span><br><span class="line">        &#123;</span><br><span class="line">            m_pOEMInterface-&gt;pInitializeExtendedPlatformStaticCaps(&amp;m_platformCaps[<span class="number">0</span>], m_numberSensors);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    CAMX_ASSERT(CamxResultSuccess == result);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (CamxResultSuccess == result)</span><br><span class="line">    &#123;</span><br><span class="line">        InitializeHwEnvironmentStaticCaps();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    m_initCapsStatus = InitCapsDone;</span><br><span class="line"></span><br><span class="line">    m_pHWEnvLock-&gt;Unlock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><p>这一波操作应该就是枚举各个Camera模组，检测硬件是否可以通信成功。</p><ol><li><p>Probe Sensor </p><p>经过上述函数中 ProbeImageSensorModules() 会走到  ImageSensorModuleData::Probe()</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//vendor/proprietary/camx/src/core/camximagesensormoduledata.cpp</span></span><br><span class="line"><span class="function">CamxResult <span class="title">ImageSensorModuleData::Probe</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">                                                         BOOL*   pDetected,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                         INT32*  pDeviceIndex)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">//获取上下电时序</span></span><br><span class="line">    UINT powerUpCmdSize     = GetSensorDataObject()-&gt;GetPowerSequenceCmdSize(TRUE);</span><br><span class="line">    UINT powerDownCmdSize   = GetSensorDataObject()-&gt;GetPowerSequenceCmdSize(FALSE);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建命令包管理</span></span><br><span class="line">    result = CmdBufferManager::Create(<span class="string">&quot;ImageSensorPacketManager&quot;</span>, &amp;packetResourceParams, &amp;pPacketManager);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//向CSL下发probe命令</span></span><br><span class="line">    result = CSLImageSensorProbe(pProbePacket-&gt;GetMemHandle(), pProbePacket-&gt;GetOffset(), &amp;probeResult);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数的主要作用就是创建probe sensor 的命令包，然后下发到CSL</p><p>将命令包提交到 CSL 通过ioctl下发到 Kernel</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//vendor/qcom/proprietary/camx/src/csl/hw/camxcslhwinternalsensor.cpp</span></span><br><span class="line"><span class="function">CamxResult <span class="title">CSLHwInternalProbeSensorHW</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">                                          CSLMemHandle hPacket,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          SIZE_T       offset,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          INT32*       pDeviceIndex)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    ioctlCmd.op_code     = CAM_SENSOR_PROBE_CMD;</span><br><span class="line">    ioctlCmd.size        = <span class="keyword">sizeof</span>(ioctlCmd.handle);</span><br><span class="line">    ioctlCmd.handle_type = CAM_HANDLE_MEM_HANDLE;</span><br><span class="line">    ioctlCmd.reserved    = <span class="number">0</span>;</span><br><span class="line">    ioctlCmd.handle      = hPacket;</span><br><span class="line">    result = pLoophw-&gt;deviceOp.Ioctl(pLoophw, VIDIOC_CAM_CONTROL, &amp;ioctlCmd);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;概览&quot;&gt;&lt;a href=&quot;#概览&quot; class=&quot;headerlink&quot; title=&quot;概览&quot;&gt;&lt;/a&gt;概览&lt;/h1&gt;&lt;img src=&quot;/2020/01/01/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera%20Drive</summary>
      
    
    
    
    <category term="技术研发" scheme="https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/"/>
    
    <category term="Camera Driver" scheme="https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera-Driver/"/>
    
    <category term="高通 Camx" scheme="https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera-Driver/%E9%AB%98%E9%80%9A-Camx/"/>
    
    
  </entry>
  
  <entry>
    <title>Ubuntu 开发环境的搭建</title>
    <link href="https://zh-wiki.github.io/2020/01/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Ubuntu%20%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E7%9A%84%E6%90%AD%E5%BB%BA/"/>
    <id>https://zh-wiki.github.io/2020/01/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Ubuntu%20%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E7%9A%84%E6%90%AD%E5%BB%BA/</id>
    <published>2019-12-31T16:00:00.000Z</published>
    <updated>2020-10-23T06:20:25.472Z</updated>
    
    <content type="html"><![CDATA[<h2 id="VirtualBox-修复’modprobe-vboxdrv’-报错"><a href="#VirtualBox-修复’modprobe-vboxdrv’-报错" class="headerlink" title="VirtualBox 修复’modprobe vboxdrv’ 报错"></a>VirtualBox 修复’modprobe vboxdrv’ 报错</h2><ol><li><p>问题发生背景 </p><p>Linux 内核版本升级之后，virtualbox 的驱动没有更新成功。</p></li><li><p>解决方法</p><ol><li><p>更新整个系统</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt upgrade</span><br></pre></td></tr></table></figure></li><li><p>重新安装对应内核版本的头文件,和virtualbox的驱动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install --reinstall linux-headers-$(uname -r) virtualbox-dkms dkms</span><br></pre></td></tr></table></figure></li><li><p>加载驱动重启</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo modprobe vboxdrv</span><br><span class="line">reboot</span><br></pre></td></tr></table></figure></li></ol></li></ol><ol start="3"><li><p>注意事项</p><p>更新驱动的时候，会重新编译驱动，所以要选择对应的gcc编译器，太老的估计会凉。</p></li></ol><h2 id="支持多版本的gcc"><a href="#支持多版本的gcc" class="headerlink" title="支持多版本的gcc"></a>支持多版本的gcc</h2><ol><li><p>系统安装ok后默认gcc 版本是 v-7.x。我们先搞一个低版本的gcc</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install gcc-4.8</span><br><span class="line">sudo apt-get install g++-4.8</span><br><span class="line">sudo ln -sf /usr/bin/g++-4.8 /usr/bin/g++</span><br><span class="line">sudo ln -sf /usr/bin/gcc-4.8 /usr/bin/gcc</span><br></pre></td></tr></table></figure></li><li><p>管理多个版本的gcc</p><ol><li><p>查看存在几个版本的gcc</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -l /usr/bin/gcc</span><br></pre></td></tr></table></figure></li><li><p>分别为gcc和g++添加管理组</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-4.8 40</span><br><span class="line">sudo update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++-4.8 40</span><br></pre></td></tr></table></figure></li><li><p>能添加就能删除,从管理组中删除</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo update-alternatives --remove gcc /usr/bin/gcc-4.8</span><br></pre></td></tr></table></figure></li></ol></li><li><p>设置ok使用以下指令选择gcc的版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo update-alternatives --config gcc</span><br><span class="line">sudo update-alternatives --config g++</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;VirtualBox-修复’modprobe-vboxdrv’-报错&quot;&gt;&lt;a href=&quot;#VirtualBox-修复’modprobe-vboxdrv’-报错&quot; class=&quot;headerlink&quot; title=&quot;VirtualBox 修复’modprobe v</summary>
      
    
    
    
    <category term="计算机基础知识" scheme="https://zh-wiki.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="Ubuntu" scheme="https://zh-wiki.github.io/tags/Ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>Android 研发总结</title>
    <link href="https://zh-wiki.github.io/2020/01/01/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Android%20%E7%A0%94%E5%8F%91%E6%80%BB%E7%BB%93/%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/"/>
    <id>https://zh-wiki.github.io/2020/01/01/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Android%20%E7%A0%94%E5%8F%91%E6%80%BB%E7%BB%93/%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/</id>
    <published>2019-12-31T16:00:00.000Z</published>
    <updated>2020-10-26T07:08:24.220Z</updated>
    
    <content type="html"><![CDATA[<h3 id="如何编译-selinux"><a href="#如何编译-selinux" class="headerlink" title="如何编译 selinux"></a>如何编译 selinux</h3><ol><li>编译命令</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make selinux_policy</span><br></pre></td></tr></table></figure><ol start="2"><li><p>生成的文件</p><p>path : out/target/product/lime/vendor/etc/selinux</p></li></ol><h3 id="如何将最近指定时间-45min-内生成的文件-push-到-指定-的路径"><a href="#如何将最近指定时间-45min-内生成的文件-push-到-指定-的路径" class="headerlink" title="如何将最近指定时间(45min)内生成的文件 push 到 指定 的路径"></a>如何将最近指定时间(45min)内生成的文件 push 到 指定 的路径</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -mmin -45 -<span class="built_in">type</span> f|grep -v SHARED_LIBRARIES|grep -v STATIC_LIBRARIES|grep -Ei <span class="string">&quot;so|bin&quot;</span>|grep -v symbols|xargs -t -I <span class="string">&#x27;&#123;&#125;&#x27;</span> adb push &#123;&#125; /vendor/lib64/&#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="如何在安卓中自定义-log"><a href="#如何在安卓中自定义-log" class="headerlink" title="如何在安卓中自定义 log"></a>如何在安卓中自定义 log</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;android/log.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GC02M1B_DBG(fmt, args...) __android_log_print(ANDROID_LOG_ERROR, <span class="meta-string">&quot;GC02M1B&quot;</span>,fmt, ##args)</span></span><br></pre></td></tr></table></figure><h3 id="Trace-的使用"><a href="#Trace-的使用" class="headerlink" title="Trace 的使用"></a>Trace 的使用</h3><ol><li><p>systrace.py 的路径</p><p>path：项目代码/native/external/chromium-trace</p></li><li><p>如何打开 trace 的 html</p><p>在谷歌浏览器输入 chrome://tracing/</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;如何编译-selinux&quot;&gt;&lt;a href=&quot;#如何编译-selinux&quot; class=&quot;headerlink&quot; title=&quot;如何编译 selinux&quot;&gt;&lt;/a&gt;如何编译 selinux&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;编译命令&lt;/li&gt;
&lt;/ol&gt;
&lt;figure </summary>
      
    
    
    
    <category term="技术研发" scheme="https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/"/>
    
    <category term="Android 研发总结" scheme="https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Android-%E7%A0%94%E5%8F%91%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="Android" scheme="https://zh-wiki.github.io/tags/Android/"/>
    
  </entry>
  
</feed>
